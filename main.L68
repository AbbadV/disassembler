00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 5/12/2017 2:04:59 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : main.X68
00000000                             3  * Written by : bisrat for WeMissJava
00000000                             4  * Date       : 4/21/2017
00000000                             5  * Description: Displays welcome, Gets start and end address of memo to be decoded ,Define Out-start-addres,
00000000                             6  *               defines valid-flag (1 for code valid 0 for code invalid),defines constants for start and end 
00000000                             7  *               address of the program ,Sets out current add to out -start- add, Starts id running instruction
00000000                             8  *-----------------------------------------------------------
00000000  =0000000D                  9  CR              EQU     $0D                 ASCII code for carriage return
00000000  =0000000A                 10  LF              EQU     $0A                 ASCII code  for line feed  
00000000                            11  
00000000                            12  
00001000                            13  START:          ORG    $1000                first instruction of program
00001000                            14  
00001000                            15  *---------------------------------------
00001000                            16  *   THIS IS FOR TESTING, IGNORE THIS
00001000                            17  *---------------------------------------
00001000                            18  *   MOVE.W      #$2021,$13000   ; move.l  -(A1),D0
00001000                            19  *   MOVE.W      #$349A,$13002   ; move.w  (A2)+,(A2)
00001000                            20  *   MOVE.W      #$1510,$13004   ; move.b  (A0),-(A2)
00001000                            21  *   MOVE.W      #$2A7C,$13006   ; movea.l #$4166,A5
00001000                            22  *   MOVE.W      #$0000,$13008
00001000                            23  *   MOVE.W      #$4166,$1300A
00001000                            24  *   MOVE.W      #$7A4A,$1300C   ; moveq.l #$4A,D5
00001000                            25  *   MOVE.W      #$48E7,$1300E   ; movem.l D0-D7/A3,-(SP)
00001000                            26  *   MOVE.W      #$FF10,$13010
00001000                            27  *   MOVE.W      #$4C9F,$13012   ; movem.w (SP)+,D0-D7/A3
00001000                            28  *   MOVE.W      #$08FF,$13014
00001000                            29  *   MOVE.W      #$D842,$13016   ; add.w   D2,D4
00001000                            30  *   MOVE.W      #$D578,$13018   ; add.w   D2,$789A
00001000                            31  *   MOVE.W      #$789A,$1301A
00001000                            32  *   MOVE.W      #$DCB9,$1301C   ; add.l   $AAAA,D6
00001000                            33  *   MOVE.W      #$0000,$1301E
00001000                            34  *   MOVE.W      #$AAAA,$13020
00001000                            35  *   MOVE.W      #$DAFC,$13022   ; adda.w  #$40,A5
00001000                            36  *   MOVE.W      #$0040,$13024
00001000                            37  *   MOVE.W      #$4EB8,$13026   ; JSR     $1234
00001000                            38  *   MOVE.W      #$1234,$13028
00001000                            39  *   MOVE.W      #$4E75,$1302A   ; RTS
00001000                            40  *   MOVE.W      #$E404,$1302C   ; ASR.B   #2,D4
00001000                            41  *   MOVE.W      #$E3F8,$1302E   ; LSL.W   $5678
00001000                            42  *   MOVE.W      #$5678,$13030
00001000                            43  *   MOVE.W      #$6400,$13032   ; BCC     $13052
00001000                            44  *   MOVE.W      #$001E,$13034
00001000                            45  *   MOVE.W      #$6400,$13036   ; BCC     $13056
00001000                            46  *   MOVE.W      #$001E,$13038
00001000                            47  *   MOVE.W      #$6C00,$1303A   ; BGE     $1305A
00001000                            48  *   MOVE.W      #$001E,$1303C
00001000                            49  *   MOVE.W      #$6D00,$1303E   ; BLT     $1305E
00001000                            50  *   MOVE.W      #$001E,$13040
00001000                            51  *   MOVE.W      #$64FA,$13042   ; BCC     $13040
00001000                            52  *   MOVE.W      #$0644,$13044   ; ADDI.W  #$123,D4
00001000                            53  *   MOVE.W      #$0123,$13046   
00001000                            54  *   MOVE.W      #$5C44,$13048   ; ADDQ.W  #$6,D4
00001000                            55  *   MOVE.W      #$5043,$1304A   ; ADDQ.W  #$8,D3
00001000                            56  *   MOVE.W      #$0444,$1304C   ; SUBI.W  #$123,D4
00001000                            57  *   MOVE.W      #$0123,$1304E   
00001000                            58  *   MOVE.W      #$9842,$13050   ; SUB.W   D2,D4
00001000                            59  *   MOVE.W      #$9578,$13052   ; SUB.W   D2,$0999
00001000                            60  *   MOVE.W      #$0999,$13054
00001000                            61  *---------------------------------------
00001000                            62  
00001000                            63  *Display welcome 
00001000  43F9 0000755C             64                  LEA     welcome_msg,A1      load welcome message to A1
00001006  303C 000E                 65                  Move.W  #14,D0              display the string at A1
0000100A  4E4F                      66                  TRAP    #15                 run task 14
0000100C                            67                  
0000100C                            68  *read starting address message and convert to hex
0000100C                            69                          
0000100C  43F9 00007591             70  RD_START_INPUT  LEA     START_ADD_MSG,A1    load start address request msg
00001012  303C 000E                 71                  MOVE.W  #14,D0              print data in d0 to screen 
00001016  4E4F                      72                  TRAP    #15                 run task 14
00001018                            73                  
00001018  43F9 0000774C             74                  LEA     IN_START_A,A1     load starting adresss input from user 
0000101E  103C 0002                 75                  MOVE.B  #2,D0               read string from key board and store it in A1
00001022  4E4F                      76                  TRAP    #15                 run task 2
00001024  4EB9 0000115C             77                  JSR     CK_INPUT_SIZE       check that input length is between 1-8 characters
0000102A  B67C 0001                 78                  CMP     #1,D3               is input length ok?    
0000102E  6700 0008                 79                  BEQ     CONTINUE_START1     length ok ,keep on reading input 
00001032  4EB9 00001174             80                  JSR     INVALID_INP_ST       bad input length , display error and start over    
00001038  4EB9 00001194             81  CONTINUE_START1 JSR     CONVERT             go to conversion subroutine
0000103E  4EB9 000011D2             82                  JSR     MIN_MAX_CHECK       check if input is within the min& max limit for address 
00001044  B43C 0001                 83                  CMP.B   #1,D2               is input address within allowable interval
00001048  6700 0004                 84                  BEQ     CONTINUE_START2     input is within limits, keep reading
0000104C  66BE                      85                  BNE     RD_START_INPUT      input out of limits , ask for new input
0000104E                            86                  
0000104E  4EB9 0000120E             87  CONTINUE_START2 JSR     EVEN_CHECK          verify  input adress is even    
00001054  B43C 0001                 88                  CMP.B   #1,D2               is input address even?
00001058  66B2                      89                  BNE     RD_START_INPUT      input not even , ask for input again
0000105A  2446                      90                  MOVEA.L  D6,A2              start adress passed all input tests,save start address in A2
0000105C                            91                  
0000105C  43F9 000075C4             92  RD_END_INPUT    LEA     END_ADD_MSG,A1      load end address request msg
00001062  303C 000E                 93                  MOVE.W  #14,D0              display string at A1
00001066  4E4F                      94                  TRAP    #15                 run task 14
00001068                            95                  
00001068  43F9 00007754             96                  LEA     IN_END_A,A1     load starting adresss input from user 
0000106E  103C 0002                 97                  MOVE.B  #2,D0               read string from key board and store it in A1
00001072  4E4F                      98                  TRAP    #15                 run task 2
00001074                            99                  
00001074  4EB9 0000115C            100                  JSR     CK_INPUT_SIZE       check that input length is between 1-8 characters
0000107A  B67C 0001                101                  CMP     #1,D3               is input length ok?    
0000107E  6700 0008                102                  BEQ     CONTINUE_END1       length ok ,keep on reading input 
00001082  4EB9 00001184            103                  JSR     INVALID_INP_ED
00001088                           104                  
00001088  4EB9 00001194            105  CONTINUE_END1   JSR     CONVERT             go to conversion subroutine
0000108E  4EB9 000011D2            106                  JSR     MIN_MAX_CHECK       check if input is within the min& max limit for address 
00001094  B43C 0001                107                  CMP.B   #1,D2               is input address within allowable interval
00001098  6700 0004                108                  BEQ     CONTINUE_END2     input is within limits, keep reading
0000109C  66BE                     109                  BNE     RD_END_INPUT  
0000109E                           110                  
0000109E  4EB9 0000120E            111  CONTINUE_END2   JSR     EVEN_CHECK          verify  input adress is even    
000010A4  B43C 0001                112                  CMP.B   #1,D2               is input address even?
000010A8  66B2                     113                  BNE     RD_END_INPUT      input not even , ask for input again
000010AA  2646                     114                  MOVEA.L  D6,A3              start adress passed all input tests,save start address in A2
000010AC  23CA 0000774C            115                  MOVE.L  A2,IN_START_A       copy start input to IN_START_A
000010B2  23CA 00007750            116                  MOVE.L  A2,IN_CURR_A        copy current input to IN_CURR_A
000010B8  23CB 00007754            117                  MOVE.L  A3,IN_END_A         copy end input to IN_END_A
000010BE                           118  
000010BE                           119                  * start building the string a bit after the source code ends
000010BE                           120                  * (about $3000 to avoid conflicts)
000010BE  23FC 00003000 00007758   121                  MOVE.L  #$3000,OUT_START_A
000010C8  23F9 00007758 0000775C   122                  MOVE.L  OUT_START_A,OUT_CURR_A
000010D2                           123  
000010D2                           124                  * it starts valid, so make IS_VALID 1
000010D2  13FC 0001 00007760       125                  MOVE.B  #1,IS_VALID
000010DA                           126                  
000010DA                           127  MAIN_LOOP
000010DA  4EB9 0000122C            128      JSR         CMD_IDENTIFY
000010E0  2239 00007750            129      MOVE.L      IN_CURR_A,D1
000010E6  2439 00007754            130      MOVE.L      IN_END_A,D2
000010EC  B242                     131      CMP.W       D2,D1
000010EE  6E00 0004                132      BGT         END_MAIN_LOOP
000010F2  60E6                     133      BRA         MAIN_LOOP
000010F4                           134  
000010F4                           135  END_MAIN_LOOP
000010F4                           136  
000010F4                           137      * add a 00 to the very end of the output
000010F4  2279 0000775C            138      MOVEA.L     OUT_CURR_A,A1
000010FA  12FC 0000                139      MOVE.B      #0,(A1)+
000010FE                           140  
000010FE                           141      * --------------
000010FE                           142      * printing loop
000010FE                           143      * --------------
000010FE  2279 00007758            144      MOVEA.L     OUT_START_A,A1
00001104  1C3C 0000                145      MOVE.B      #0,D6   ; D6 is our counter
00001108                           146  
00001108                           147  FINAL_PRINT_LOOP
00001108  1219                     148      MOVE.B      (A1)+,D1    ; print a single character
0000110A                           149  
0000110A                           150      * the user enters the newlines themself, so don't print them
0000110A  B23C 000D                151      CMP.B       #$D,D1
0000110E  6700 0010                152      BEQ         FINAL_PRINT_LOOP_SKIP ; don't print it if it's a newline
00001112  B23C 000A                153      CMP.B       #$A,D1
00001116  6700 0008                154      BEQ         FINAL_PRINT_LOOP_SKIP ; don't print it if it's a newline
0000111A                           155  
0000111A  103C 0006                156      MOVE.B      #6,D0
0000111E  4E4F                     157      TRAP        #15
00001120                           158  
00001120                           159  FINAL_PRINT_LOOP_SKIP
00001120                           160    
00001120  4A01                     161      TST.B       D1
00001122  6700 0034                162      BEQ         FINAL_PRINT_LOOP_END
00001126                           163  
00001126  B23C 000D                164      CMP.B       #$D,D1    ; if it's a LF, we hit a newline, wait for enter
0000112A  66DC                     165      BNE         FINAL_PRINT_LOOP
0000112C                           166  
0000112C  5206                     167      ADDI.B      #1,D6     ; increment the counter
0000112E  BC3C 0020                168      CMP.B       #INSTRUCTIONS_PER_SCREEN,D6
00001132  6700 0014                169      BEQ         FINAL_PRINT_LOOP_WAIT
00001136                           170  
00001136                           171  FINAL_PRINT_LOOP_NEWLINE
00001136  103C 0006                172      MOVE.B      #6,D0
0000113A  123C 000A                173      MOVE.B      #$A,D1
0000113E  4E4F                     174      TRAP        #15
00001140  123C 000D                175      MOVE.B      #$D,D1
00001144  4E4F                     176      TRAP        #15
00001146                           177  
00001146  60C0                     178      BRA         FINAL_PRINT_LOOP
00001148                           179  
00001148                           180  FINAL_PRINT_LOOP_WAIT
00001148  4206                     181      CLR.B       D6
0000114A  103C 0005                182      MOVE.B      #5,D0     ; get a single character
0000114E  4E4F                     183      TRAP        #15
00001150  B23C 000D                184      CMP.B       #$D,D1    ; and compare it with $D (carridge return or ENTER)
00001154  66F2                     185      BNE         FINAL_PRINT_LOOP_WAIT ; if it's not that, wait again
00001156                           186  
00001156  60B0                     187      BRA         FINAL_PRINT_LOOP
00001158                           188  
00001158                           189  FINAL_PRINT_LOOP_END
00001158                           190  
00001158                           191      * MOVE.B    #13,D0
00001158                           192      * TRAP      #15
00001158                           193  
00001158  FFFF FFFF                194      SIMHALT             ; halt simulator
0000115C                           195  
0000115C                           196  * this was bisrat's old loop
0000115C                           197  * MAIN_LOOP       CMP.L   IN_CURR_A,IN_END_A     IS CURRENT LESS THAN END?               
0000115C                           198                  * BLE     IDINSRUCTION              go to idinstruction
0000115C                           199                  * simHalt
0000115C                           200  
0000115C                           201  
0000115C                           202  
0000115C                           203  * check input string length is 1 minimum and 8 max
0000115C                           204  
0000115C  7400                     205  CK_INPUT_SIZE   MOVE.L  #0,D2               set d2 to zero 
0000115E  7600                     206                  MOVE.L  #0,D3               set d3 to zero 
00001160  7808                     207                  MOVE.L  #8,D4
00001162  B242                     208                  CMP.W   D2,D1              IS string length zero?
00001164  6700 000E                209                  BEQ     INVALID_INP_ST      length is 0, print input error message 
00001168  B204                     210                  CMP.B   D4,D1             compare string length to 8
0000116A  6E00 0008                211                  BGT     INVALID_INP_ST       input greater than 8 chrs ,display error message
0000116E  163C 0001                212                  MOVE.B  #1,D3              save 1 in d3 meaning input size is ok 
00001172                           213                  *CLR.L   D1 
00001172  4E75                     214                  RTS
00001174                           215   *print invalid input error message 
00001174                           216     
00001174  43F9 0000760A            217  INVALID_INP_ST  LEA     INPUT_ERROR_MSG,A1  load input error message to A1
0000117A  303C 000E                218                  MOVE.W  #14,D0              print data in d0 to screen 
0000117E  4E4F                     219                  TRAP    #15                 run task 14
00001180  6000 FE8A                220                  BRA     RD_START_INPUT      prompt user for input again
00001184                           221   
00001184  43F9 0000760A            222  INVALID_INP_ED  LEA     INPUT_ERROR_MSG,A1  load input error message to A1
0000118A  303C 000E                223                  MOVE.W  #14,D0              print data in d0 to screen 
0000118E  4E4F                     224                  TRAP    #15                 run task 14
00001190  6000 FECA                225                  BRA     RD_END_INPUT      prompt user for input again
00001194                           226  *convert to ASCII
00001194  4286                     227  CONVERT         CLR.L    D6
00001196  B23C 0000                228  CNV_LOOP        CMP.B   #0,D1              are all characters of the input are converted?
0000119A  6700 0012                229                  BEQ     FINISH 
0000119E  4284                     230                  CLR.L   D4                 use cleared d4 for input storage
000011A0  1819                     231                  MOVE.B  (A1)+,D4           save the first character input in to D4   
000011A2  0C04 0039                232                  CMPI.B   #$39,D4           subtract $39 from character to check if its a digit                   
000011A6  6F00 0010                233                  BLE     DIGIT_TO_HEX       use digit converter character is less than or equal to $39
000011AA  6E00 0004                234                  BGT     ALPHA_TO_HEX
000011AE  4E75                     235  FINISH          RTS                
000011B0                           236  *convert num to hex                
000011B0  0404 0037                237  ALPHA_TO_HEX    SUBI.B  #$37,D4            convert alpahbet to hex number, keep it in D4
000011B4  6000 000A                238                  BRA     KEEP_COUNT         manage the unconverted count 
000011B8                           239             
000011B8                           240  *convert letters to hex
000011B8  0404 0030                241  DIGIT_TO_HEX    SUBI.B  #$30,D4            convert digit to hexadecimal number , keep it in D4
000011BC  6000 0002                242                  BRA     KEEP_COUNT         manage the unconverted count 
000011C0                           243  *update count  
000011C0  DC04                     244  KEEP_COUNT      ADD.B   D4,D6              save the conversion in the hex holder D6
000011C2  5301                     245                  SUBI.B  #$1,D1             decrease the unconverted input count by 1 
000011C4  0C01 0000                246                  CMPI.B  #$0,D1             are we done converting all input ?
000011C8  67CC                     247                  BEQ     CNV_LOOP           we are done counting , go to convert     
000011CA  7A00                     248                  MOVE.L  #0,D5              set up D5=0 for later
000011CC  E986                     249                  ASL.L   #4,D6              shift d4 contents left by 4 to receive next input
000011CE  DC05                     250                  ADD.B   D5,D6              adjust zeros 
000011D0  60C4                     251                  BRA     CNV_LOOP           updating the count is done go back to convert
000011D2                           252                  
000011D2                           253  * check if user input is between the interval [$7000,FFFFFE]
000011D2                           254                  
000011D2  7400                     255  MIN_MAX_CHECK   MOVE.L  #0,D2               reset d2 to store data 
000011D4  243C 00007000            256                  MOVE.L  #$00007000,D2       save min input limit in d2
000011DA  BC82                     257                  CMP.L   D2,D6               is input less than min?
000011DC  6D00 0014                258                  BLT     BELOW_MIN_ERROR     input is less, display error msg
000011E0  243C 00FFFFFE            259                  MOVE.L  #$00FFFFFE,D2       save max input limit in d2
000011E6  BC82                     260                  CMP.L   D2,D6               is input greater than max?
000011E8  6E00 0016                261                  BGT     ABOVE_MAX_ERROR     input is higher than max
000011EC  143C 0001                262                  MOVE.B  #1,D2               input checks out , mark d2=1
000011F0  4E75                     263                  RTS
000011F2                           264  *display min & max errors to console                 
000011F2  43F9 00007679            265  BELOW_MIN_ERROR LEA     ADDR_BELOW_MSG,A1    load input address below min msg
000011F8  303C 000E                266                  MOVE    #14,D0               display the string at A1
000011FC  4E4F                     267                  TRAP    #15                  run task 14  
000011FE  4E75                     268                  RTS
00001200  43F9 000076C6            269  ABOVE_MAX_ERROR LEA     ADDR_ABOVE_MSG,A1    load input address above max msg 
00001206  303C 000E                270                  MOVE    #14,D0               display the string at A1
0000120A  4E4F                     271                  TRAP    #15                  run task 14 
0000120C  4E75                     272                  RTS         
0000120E                           273  *check if the input adress is even(odd not allowed)     
0000120E                           274   
0000120E  2E06                     275  EVEN_CHECK     MOVE.L   D6,D7
00001210  0207 0001                276                  ANDI.B  #1,D7                and input with bit one 
00001214  6704                     277                  BEQ.S   EVEN                 input is even
00001216  6000 0008                278                  BRA     INPUT_ODD           input is odd ,display message
0000121A                           279     
0000121A  143C 0001                280  EVEN            MOVE.B   #1,D2               input is even ,mark D1=1 
0000121E  4E75                     281                  RTS                          passed even test,return to stack
00001220                           282                  
00001220  43F9 00007714            283  INPUT_ODD       LEA      EVEN_CHECK_MSG,A1   load odd address enteresd msg
00001226  303C 000E                284                  MOVE    #14,D0               dispaly string at A1
0000122A  4E4F                     285                  TRAP    #15                  run task 14
0000122C                           286                  
0000122C                           287  * Put variables and constants here
0000122C                           288     * INCLUDE 'opcode_subroutine.x68'
0000122C                           289      *INCLUDE 'ea_subroutine.x68'
0000122C                           290      *INCLUDE 'io_subroutine.x68'
0000122C                           291      *INCLUDE 'variables.x68'
0000122C                           292      *INCLUDE 'strings.x68'
0000122C                           293      INCLUDE     'CmdIdentify.X68'
0000122C                           294  
0000122C                           295  CMD_IDENTIFY
0000122C                           296  
0000122C  48E7 FFFE                297          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00001230                           298    
00001230  227C 00000000            299          MOVEA.L   #0,A1
00001236  2279 00007750            300          MOVEA.L   IN_CURR_A,A1  ; A1 is a pointer to the current position
0000123C  2679 0000775C            301          MOVEA.L   OUT_CURR_A,A3 ; A3 is a pointer to the current output pos
00001242  2209                     302          MOVE.L    A1,D1
00001244                           303  
00001244  4EB9 00001A5C            304          JSR       PRINT_NUM     ; print the address to the screen
0000124A  16FC 0009                305          MOVE.B    #9,(A3)+      ; print tab character
0000124E  23CB 0000775C            306          MOVE.L    A3,OUT_CURR_A
00001254  3211                     307          MOVE.W    (A1),D1       ; D1 is the current opcode
00001256                           308  
00001256                           309          * check ASL (memory signature)
00001256  3401                     310          MOVE.W    D1,D2        ; move the value into D2 for temp storage
00001258  363C FFC0                311          MOVE.W    #ASLM_P,D3   ; move values into registers for CMD_CHECK
0000125C  383C E1C0                312          MOVE.W    #ASLM_S,D4  
00001260  3A3C 2A5E                313          MOVE.W    #ASL_SUB,D5
00001264  4EB9 000016C2            314          JSR       CMD_CHECK
0000126A  BC3C 0001                315          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
0000126E  6700 044C                316          BEQ       END_IDENTIFY  ; skip to the end if it's equal
00001272                           317  
00001272                           318          * check ASR (memory signature)
00001272  3401                     319          MOVE.W    D1,D2        ; move the value into D2 for temp storage
00001274  363C FFC0                320          MOVE.W    #ASRM_P,D3   ; move values into registers for CMD_CHECK
00001278  383C E0C0                321          MOVE.W    #ASRM_S,D4  
0000127C  3A3C 2A8C                322          MOVE.W    #ASR_SUB,D5
00001280  4EB9 000016C2            323          JSR       CMD_CHECK
00001286  BC3C 0001                324          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
0000128A  6700 0430                325          BEQ       END_IDENTIFY  ; skip to the end if it's equal
0000128E                           326  
0000128E                           327          * check LSL (memory signature)
0000128E  3401                     328          MOVE.W    D1,D2        ; move the value into D2 for temp storage
00001290  363C FFC0                329          MOVE.W    #LSLM_P,D3   ; move values into registers for CMD_CHECK
00001294  383C E3C0                330          MOVE.W    #LSLM_S,D4  
00001298  3A3C 2ABA                331          MOVE.W    #LSL_SUB,D5
0000129C  4EB9 000016C2            332          JSR       CMD_CHECK
000012A2  BC3C 0001                333          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
000012A6  6700 0414                334          BEQ       END_IDENTIFY  ; skip to the end if it's equal
000012AA                           335  
000012AA                           336          * check LSR (memory signature)
000012AA  3401                     337          MOVE.W    D1,D2        ; move the value into D2 for temp storage
000012AC  363C FFC0                338          MOVE.W    #LSRM_P,D3   ; move values into registers for CMD_CHECK
000012B0  383C E2C0                339          MOVE.W    #LSRM_S,D4  
000012B4  3A3C 2AE8                340          MOVE.W    #LSR_SUB,D5
000012B8  4EB9 000016C2            341          JSR       CMD_CHECK
000012BE  BC3C 0001                342          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
000012C2  6700 03F8                343          BEQ       END_IDENTIFY  ; skip to the end if it's equal
000012C6                           344  
000012C6                           345          * check ROL (memory signature)
000012C6  3401                     346          MOVE.W    D1,D2        ; move the value into D2 for temp storage
000012C8  363C FFC0                347          MOVE.W    #ROLM_P,D3   ; move values into registers for CMD_CHECK
000012CC  383C E7C0                348          MOVE.W    #ROLM_S,D4  
000012D0  3A3C 2B16                349          MOVE.W    #ROL_SUB,D5
000012D4  4EB9 000016C2            350          JSR       CMD_CHECK
000012DA  BC3C 0001                351          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
000012DE  6700 03DC                352          BEQ       END_IDENTIFY  ; skip to the end if it's equal
000012E2                           353  
000012E2                           354          * check ROR (memory signature)
000012E2  3401                     355          MOVE.W    D1,D2        ; move the value into D2 for temp storage
000012E4  363C FFC0                356          MOVE.W    #RORM_P,D3   ; move values into registers for CMD_CHECK
000012E8  383C E6C0                357          MOVE.W    #RORM_S,D4  
000012EC  3A3C 2B44                358          MOVE.W    #ROR_SUB,D5
000012F0  4EB9 000016C2            359          JSR       CMD_CHECK
000012F6  BC3C 0001                360          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
000012FA  6700 03C0                361          BEQ       END_IDENTIFY  ; skip to the end if it's equal
000012FE                           362          
000012FE                           363          * check SUBI
000012FE  3401                     364          MOVE.W    D1,D2         ; move the value into D2 for temp storage
00001300  363C FF00                365          MOVE.W    #SUBI_P,D3    ; move values into registers for CMD_CHECK
00001304  383C 0400                366          MOVE.W    #SUBI_S,D4  
00001308  3A3C 1B64                367          MOVE.W    #SUBI_SUB,D5
0000130C  4EB9 000016C2            368          JSR       CMD_CHECK
00001312  BC3C 0001                369          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
00001316  6700 03A4                370          BEQ       END_IDENTIFY  ; skip to the end if it's equal
0000131A                           371  
0000131A                           372          * check ADDI
0000131A  3401                     373          MOVE.W    D1,D2         ; move the value into D2 for temp storage
0000131C  363C FF00                374          MOVE.W    #ADDI_P,D3    ; move values into registers for CMD_CHECK
00001320  383C 0600                375          MOVE.W    #ADDI_S,D4  
00001324  3A3C 1CE2                376          MOVE.W    #ADDI_SUB,D5
00001328  4EB9 000016C2            377          JSR       CMD_CHECK
0000132E  BC3C 0001                378          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
00001332  6700 0388                379          BEQ       END_IDENTIFY  ; skip to the end if it's equal
00001336                           380  
00001336                           381          * check MOVEA
00001336  3401                     382          MOVE.W    D1,D2         ; move the value into D2 for temp storage
00001338  363C C1C0                383          MOVE.W    #MOVEA_P,D3    ; move values into registers for CMD_CHECK
0000133C  383C 0040                384          MOVE.W    #MOVEA_S,D4  
00001340  3A3C 1E60                385          MOVE.W    #MOVEA_SUB,D5
00001344  4EB9 000016C2            386          JSR       CMD_CHECK
0000134A  BC3C 0001                387          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
0000134E  6700 036C                388          BEQ       END_IDENTIFY  ; skip to the end if it's equal
00001352                           389  
00001352                           390          * check MOVE
00001352  3401                     391          MOVE.W    D1,D2         ; move the value into D2 for temp storage
00001354  363C C000                392          MOVE.W    #MOVE_P,D3    ; move values into registers for CMD_CHECK
00001358  383C 0000                393          MOVE.W    #MOVE_S,D4  
0000135C  3A3C 1EB8                394          MOVE.W    #MOVE_SUB,D5
00001360  4EB9 000016C2            395          JSR       CMD_CHECK
00001366  BC3C 0001                396          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
0000136A  6700 0350                397          BEQ       END_IDENTIFY  ; skip to the end if it's equal
0000136E                           398  
0000136E                           399          * check NOP
0000136E  3401                     400          MOVE.W    D1,D2        ; move the value into D2 for temp storage
00001370  363C FFFF                401          MOVE.W    #NOP_P,D3    ; move values into registers for CMD_CHECK
00001374  383C 4E71                402          MOVE.W    #NOP_S,D4  
00001378  3A3C 1F10                403          MOVE.W    #NOP_SUB,D5
0000137C  4EB9 000016C2            404          JSR       CMD_CHECK
00001382  BC3C 0001                405          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
00001386  6700 0334                406          BEQ       END_IDENTIFY  ; skip to the end if it's equal
0000138A                           407  
0000138A                           408          * check RTS
0000138A  3401                     409          MOVE.W    D1,D2        ; move the value into D2 for temp storage
0000138C  363C FFFF                410          MOVE.W    #RTS_P,D3    ; move values into registers for CMD_CHECK
00001390  383C 4E75                411          MOVE.W    #RTS_S,D4  
00001394  3A3C 1F50                412          MOVE.W    #RTS_SUB,D5
00001398  4EB9 000016C2            413          JSR       CMD_CHECK
0000139E  BC3C 0001                414          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
000013A2  6700 0318                415          BEQ       END_IDENTIFY  ; skip to the end if it's equal
000013A6                           416  
000013A6                           417          * check JSR
000013A6  3401                     418          MOVE.W    D1,D2        ; move the value into D2 for temp storage
000013A8  363C FFC0                419          MOVE.W    #JSR_P,D3    ; move values into registers for CMD_CHECK
000013AC  383C 4E80                420          MOVE.W    #JSR_S,D4  
000013B0  3A3C 1F98                421          MOVE.W    #JSR_SUB,D5
000013B4  4EB9 000016C2            422          JSR       CMD_CHECK
000013BA  BC3C 0001                423          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
000013BE  6700 02FC                424          BEQ       END_IDENTIFY  ; skip to the end if it's equal
000013C2                           425  
000013C2                           426          * check MOVEM
000013C2  3401                     427          MOVE.W    D1,D2         ; move the value into D2 for temp storage
000013C4  363C FB80                428          MOVE.W    #MOVEM_P,D3    ; move values into registers for CMD_CHECK
000013C8  383C 4880                429          MOVE.W    #MOVEM_S,D4  
000013CC  3A3C 2052                430          MOVE.W    #MOVEM_SUB,D5
000013D0  4EB9 000016C2            431          JSR       CMD_CHECK
000013D6  BC3C 0001                432          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
000013DA  6700 02E0                433          BEQ       END_IDENTIFY  ; skip to the end if it's equal
000013DE                           434          
000013DE                           435           * check LEA
000013DE  3401                     436          MOVE.W    D1,D2         ; move the value into D2 for temp storage
000013E0  363C F1C0                437          MOVE.W    #LEA_P,D3    ; move values into registers for CMD_CHECK
000013E4  383C 41C0                438          MOVE.W    #LEA_S,D4  
000013E8  3A3C 21B0                439          MOVE.W    #LEA_SUB,D5
000013EC  4EB9 000016C2            440          JSR       CMD_CHECK
000013F2  BC3C 0001                441          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
000013F6  6700 02C4                442          BEQ       END_IDENTIFY  ; skip to the end if it's equal       
000013FA                           443  
000013FA                           444          * check ADDQ
000013FA  3401                     445          MOVE.W    D1,D2         ; move the value into D2 for temp storage
000013FC  363C F100                446          MOVE.W    #ADDQ_P,D3    ; move values into registers for CMD_CHECK
00001400  383C 5000                447          MOVE.W    #ADDQ_S,D4  
00001404  3A3C 221A                448          MOVE.W    #ADDQ_SUB,D5
00001408  4EB9 000016C2            449          JSR       CMD_CHECK
0000140E  BC3C 0001                450          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
00001412  6700 02A8                451          BEQ       END_IDENTIFY  ; skip to the end if it's equal
00001416                           452  
00001416                           453          * check BRA
00001416  3401                     454          MOVE.W    D1,D2        ; move the value into D2 for temp storage
00001418  363C FF00                455          MOVE.W    #BRA_P,D3    ; move values into registers for CMD_CHECK
0000141C  383C 6000                456          MOVE.W    #BRA_S,D4  
00001420  3A3C 2360                457          MOVE.W    #BRA_SUB,D5
00001424  4EB9 000016C2            458          JSR       CMD_CHECK
0000142A  BC3C 0001                459          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
0000142E  6700 028C                460          BEQ       END_IDENTIFY  ; skip to the end if it's equal
00001432                           461  
00001432                           462          * check BCC
00001432  3401                     463          MOVE.W    D1,D2        ; move the value into D2 for temp storage
00001434  363C FF00                464          MOVE.W    #BCC_P,D3    ; move values into registers for CMD_CHECK
00001438  383C 6400                465          MOVE.W    #BCC_S,D4  
0000143C  3A3C 23D6                466          MOVE.W    #BCC_SUB,D5
00001440  4EB9 000016C2            467          JSR       CMD_CHECK
00001446  BC3C 0001                468          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
0000144A  6700 0270                469          BEQ       END_IDENTIFY  ; skip to the end if it's equal
0000144E                           470  
0000144E                           471          * check BGE
0000144E  3401                     472          MOVE.W    D1,D2        ; move the value into D2 for temp storage
00001450  363C FF00                473          MOVE.W    #BGE_P,D3    ; move values into registers for CMD_CHECK
00001454  383C 6C00                474          MOVE.W    #BGE_S,D4  
00001458  3A3C 2406                475          MOVE.W    #BGE_SUB,D5
0000145C  4EB9 000016C2            476          JSR       CMD_CHECK
00001462  BC3C 0001                477          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
00001466  6700 0254                478          BEQ       END_IDENTIFY  ; skip to the end if it's equal
0000146A                           479  
0000146A                           480          * check BLT
0000146A  3401                     481          MOVE.W    D1,D2        ; move the value into D2 for temp storage
0000146C  363C FF00                482          MOVE.W    #BLT_P,D3    ; move values into registers for CMD_CHECK
00001470  383C 6D00                483          MOVE.W    #BLT_S,D4  
00001474  3A3C 2438                484          MOVE.W    #BLT_SUB,D5
00001478  4EB9 000016C2            485          JSR       CMD_CHECK
0000147E  BC3C 0001                486          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
00001482  6700 0238                487          BEQ       END_IDENTIFY  ; skip to the end if it's equal
00001486                           488  
00001486                           489          * check MOVEQ
00001486  3401                     490          MOVE.W    D1,D2          ; move the value into D2 for temp storage
00001488  363C F100                491          MOVE.W    #MOVEQ_P,D3    ; move values into registers for CMD_CHECK
0000148C  383C 7000                492          MOVE.W    #MOVEQ_S,D4  
00001490  3A3C 246A                493          MOVE.W    #MOVEQ_SUB,D5
00001494  4EB9 000016C2            494          JSR       CMD_CHECK
0000149A  BC3C 0001                495          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
0000149E  6700 021C                496          BEQ       END_IDENTIFY  ; skip to the end if it's equal
000014A2                           497  
000014A2                           498          * check DIVU
000014A2  3401                     499          MOVE.W    D1,D2         ; move the value into D2 for temp storage
000014A4  363C F1C0                500          MOVE.W    #DIVU_P,D3    ; move values into registers for CMD_CHECK
000014A8  383C 80C0                501          MOVE.W    #DIVU_S,D4  
000014AC  3A3C 24F2                502          MOVE.W    #DIVU_SUB,D5
000014B0  4EB9 000016C2            503          JSR       CMD_CHECK
000014B6  BC3C 0001                504          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
000014BA  6700 0200                505          BEQ       END_IDENTIFY  ; skip to the end if it's equal
000014BE                           506  
000014BE                           507          * check OR
000014BE  3401                     508          MOVE.W    D1,D2        ; move the value into D2 for temp storage
000014C0  363C F000                509          MOVE.W    #OR_P,D3     ; move values into registers for CMD_CHECK
000014C4  383C 8000                510          MOVE.W    #OR_S,D4  
000014C8  3A3C 27DC                511          MOVE.W    #OR_SUB,D5
000014CC  4EB9 000016C2            512          JSR       CMD_CHECK
000014D2  BC3C 0001                513          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
000014D6  6700 01E4                514          BEQ       END_IDENTIFY  ; skip to the end if it's equal
000014DA                           515  
000014DA                           516          * check SUB
000014DA  3401                     517          MOVE.W    D1,D2         ; move the value into D2 for temp storage
000014DC  363C F000                518          MOVE.W    #SUB_P,D3     ; move values into registers for CMD_CHECK
000014E0  383C 9000                519          MOVE.W    #SUB_S,D4  
000014E4  3A3C 2520                520          MOVE.W    #SUB_SUB,D5
000014E8  4EB9 000016C2            521          JSR       CMD_CHECK
000014EE  BC3C 0001                522          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
000014F2  6700 01C8                523          BEQ       END_IDENTIFY  ; skip to the end if it's equal
000014F6                           524  
000014F6                           525          * check MULS
000014F6  3401                     526          MOVE.W    D1,D2         ; move the value into D2 for temp storage
000014F8  363C F1C0                527          MOVE.W    #MULS_P,D3    ; move values into registers for CMD_CHECK
000014FC  383C C1C0                528          MOVE.W    #MULS_S,D4  
00001500  3A3C 267A                529          MOVE.W    #MULS_SUB,D5
00001504  4EB9 000016C2            530          JSR       CMD_CHECK
0000150A  BC3C 0001                531          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
0000150E  6700 01AC                532          BEQ       END_IDENTIFY  ; skip to the end if it's equal
00001512                           533  
00001512                           534          * check ADDA
00001512  3401                     535          MOVE.W    D1,D2         ; move the value into D2 for temp storage
00001514  363C F0C0                536          MOVE.W    #ADDA_P,D3    ; move values into registers for CMD_CHECK
00001518  383C D0C0                537          MOVE.W    #ADDA_S,D4  
0000151C  3A3C 29B8                538          MOVE.W    #ADDA_SUB,D5
00001520  4EB9 000016C2            539          JSR       CMD_CHECK
00001526  BC3C 0001                540          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
0000152A  6700 0190                541          BEQ       END_IDENTIFY  ; skip to the end if it's equal
0000152E                           542  
0000152E                           543          * check AND
0000152E  3401                     544          MOVE.W    D1,D2        ; move the value into D2 for temp storage
00001530  363C F000                545          MOVE.W    #AND_P,D3    ; move values into registers for CMD_CHECK
00001534  383C C000                546          MOVE.W    #AND_S,D4  
00001538  3A3C 26EE                547          MOVE.W    #AND_SUB,D5
0000153C  4EB9 000016C2            548          JSR       CMD_CHECK
00001542  BC3C 0001                549          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
00001546  6700 0174                550          BEQ       END_IDENTIFY  ; skip to the end if it's equal
0000154A                           551  
0000154A                           552          * check ADD
0000154A  3401                     553          MOVE.W    D1,D2        ; move the value into D2 for temp storage
0000154C  363C F000                554          MOVE.W    #ADD_P,D3    ; move values into registers for CMD_CHECK
00001550  383C D000                555          MOVE.W    #ADD_S,D4  
00001554  3A3C 28CA                556          MOVE.W    #ADD_SUB,D5
00001558  4EB9 000016C2            557          JSR       CMD_CHECK
0000155E  BC3C 0001                558          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
00001562  6700 0158                559          BEQ       END_IDENTIFY  ; skip to the end if it's equal
00001566                           560          * check ASRM
00001566  3401                     561          MOVE.W    D1,D2        ; move the value into D2 for temp storage
00001568  363C FFC0                562          MOVE.W    #ASRM_P,D3    ; move values into registers for CMD_CHECK
0000156C  383C E0C0                563          MOVE.W    #ASRM_S,D4  
00001570  3A3C 2A8C                564          MOVE.W    #ASR_SUB,D5
00001574  4EB9 000016C2            565          JSR       CMD_CHECK
0000157A  BC3C 0001                566          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
0000157E  6700 013C                567          BEQ       END_IDENTIFY  ; skip to the end if it's equal        
00001582                           568  
00001582                           569          * check ASLM
00001582  3401                     570          MOVE.W    D1,D2        ; move the value into D2 for temp storage
00001584  363C FFC0                571          MOVE.W    #ASLM_P,D3    ; move values into registers for CMD_CHECK
00001588  383C E1C0                572          MOVE.W    #ASLM_S,D4  
0000158C  3A3C 2A5E                573          MOVE.W    #ASL_SUB,D5
00001590  4EB9 000016C2            574          JSR       CMD_CHECK
00001596  BC3C 0001                575          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
0000159A  6700 0120                576          BEQ       END_IDENTIFY  ; skip to the end if it's equal  
0000159E                           577          
0000159E                           578          * check LSLM
0000159E  3401                     579          MOVE.W    D1,D2        ; move the value into D2 for temp storage
000015A0  363C FFC0                580          MOVE.W    #LSLM_P,D3    ; move values into registers for CMD_CHECK
000015A4  383C E3C0                581          MOVE.W    #LSLM_S,D4  
000015A8  3A3C 2ABA                582          MOVE.W    #LSL_SUB,D5
000015AC  4EB9 000016C2            583          JSR       CMD_CHECK
000015B2  BC3C 0001                584          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
000015B6  6700 0104                585          BEQ       END_IDENTIFY  ; skip to the end if it's equal
000015BA                           586          
000015BA                           587          * check LSRM
000015BA  3401                     588          MOVE.W    D1,D2        ; move the value into D2 for temp storage
000015BC  363C FFC0                589          MOVE.W    #LSRM_P,D3    ; move values into registers for CMD_CHECK
000015C0  383C E2C0                590          MOVE.W    #LSRM_S,D4  
000015C4  3A3C 2AE8                591          MOVE.W    #LSR_SUB,D5
000015C8  4EB9 000016C2            592          JSR       CMD_CHECK
000015CE  BC3C 0001                593          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
000015D2  6700 00E8                594          BEQ       END_IDENTIFY  ; skip to the end if it's equal
000015D6                           595  
000015D6                           596          * check RORM
000015D6  3401                     597          MOVE.W    D1,D2        ; move the value into D2 for temp storage
000015D8  363C FFC0                598          MOVE.W    #RORM_P,D3    ; move values into registers for CMD_CHECK
000015DC  383C E6C0                599          MOVE.W    #RORM_S,D4  
000015E0  3A3C 2B44                600          MOVE.W    #ROR_SUB,D5
000015E4  4EB9 000016C2            601          JSR       CMD_CHECK
000015EA  BC3C 0001                602          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
000015EE  6700 00CC                603          BEQ       END_IDENTIFY  ; skip to the end if it's equal
000015F2                           604          
000015F2                           605          * check ROLM
000015F2  3401                     606          MOVE.W    D1,D2        ; move the value into D2 for temp storage
000015F4  363C FFC0                607          MOVE.W    #ROLM_P,D3    ; move values into registers for CMD_CHECK
000015F8  383C E7C0                608          MOVE.W    #ROLM_S,D4  
000015FC  3A3C 2B16                609          MOVE.W    #ROL_SUB,D5
00001600  4EB9 000016C2            610          JSR       CMD_CHECK
00001606  BC3C 0001                611          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
0000160A  6700 00B0                612          BEQ       END_IDENTIFY  ; skip to the end if it's equal  
0000160E                           613  
0000160E                           614          * check ASR
0000160E  3401                     615          MOVE.W    D1,D2        ; move the value into D2 for temp storage
00001610  363C E118                616          MOVE.W    #ASR_P,D3    ; move values into registers for CMD_CHECK
00001614  383C E000                617          MOVE.W    #ASR_S,D4  
00001618  3A3C 2A8C                618          MOVE.W    #ASR_SUB,D5
0000161C  4EB9 000016C2            619          JSR       CMD_CHECK
00001622  BC3C 0001                620          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
00001626  6700 0094                621          BEQ       END_IDENTIFY  ; skip to the end if it's equal
0000162A                           622  
0000162A                           623          * check ASL
0000162A  3401                     624          MOVE.W    D1,D2        ; move the value into D2 for temp storage
0000162C  363C E118                625          MOVE.W    #ASL_P,D3    ; move values into registers for CMD_CHECK
00001630  383C E100                626          MOVE.W    #ASL_S,D4  
00001634  3A3C 2A5E                627          MOVE.W    #ASL_SUB,D5
00001638  4EB9 000016C2            628          JSR       CMD_CHECK
0000163E  BC3C 0001                629          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
00001642  6700 0078                630          BEQ       END_IDENTIFY  ; skip to the end if it's equal
00001646                           631         
00001646                           632          * check LSL
00001646  3401                     633          MOVE.W    D1,D2        ; move the value into D2 for temp storage
00001648  363C E118                634          MOVE.W    #LSL_P,D3    ; move values into registers for CMD_CHECK
0000164C  383C E108                635          MOVE.W    #LSL_S,D4  
00001650  3A3C 2ABA                636          MOVE.W    #LSL_SUB,D5
00001654  4EB9 000016C2            637          JSR       CMD_CHECK
0000165A  BC3C 0001                638          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
0000165E  6700 005C                639          BEQ       END_IDENTIFY  ; skip to the end if it's equal
00001662                           640  
00001662                           641          * check LSR
00001662  3401                     642          MOVE.W    D1,D2        ; move the value into D2 for temp storage
00001664  363C E118                643          MOVE.W    #LSR_P,D3    ; move values into registers for CMD_CHECK
00001668  383C E008                644          MOVE.W    #LSR_S,D4  
0000166C  3A3C 2AE8                645          MOVE.W    #LSR_SUB,D5
00001670  4EB9 000016C2            646          JSR       CMD_CHECK
00001676  BC3C 0001                647          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
0000167A  6700 0040                648          BEQ       END_IDENTIFY  ; skip to the end if it's equal
0000167E                           649          
0000167E                           650          * check ROR
0000167E  3401                     651          MOVE.W    D1,D2        ; move the value into D2 for temp storage
00001680  363C F118                652          MOVE.W    #ROR_P,D3    ; move values into registers for CMD_CHECK
00001684  383C E018                653          MOVE.W    #ROR_S,D4  
00001688  3A3C 2B44                654          MOVE.W    #ROR_SUB,D5
0000168C  4EB9 000016C2            655          JSR       CMD_CHECK
00001692  BC3C 0001                656          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
00001696  6700 0024                657          BEQ       END_IDENTIFY  ; skip to the end if it's equal 
0000169A                           658  
0000169A                           659          * check ROL
0000169A  3401                     660          MOVE.W    D1,D2        ; move the value into D2 for temp storage
0000169C  363C F118                661          MOVE.W    #ROL_P,D3    ; move values into registers for CMD_CHECK
000016A0  383C E118                662          MOVE.W    #ROL_S,D4  
000016A4  3A3C 2B16                663          MOVE.W    #ROL_SUB,D5
000016A8  4EB9 000016C2            664          JSR       CMD_CHECK
000016AE  BC3C 0001                665          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
000016B2  6700 0008                666          BEQ       END_IDENTIFY  ; skip to the end if it's equal     
000016B6                           667  
000016B6                           668  
000016B6                           669  
000016B6                           670          * if we hit here it's not a valid command
000016B6  4EB9 00001AB8            671          JSR       BAD_COMMAND_SUB
000016BC                           672  
000016BC                           673  END_IDENTIFY
000016BC                           674  
000016BC  4CDF 7FFF                675          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
000016C0  4E75                     676          RTS       ; return
000016C2                           677  
000016C2                           678  
000016C2                           679  CMD_CHECK
000016C2  48E7 0040                680          MOVEM.L   A1,-(SP)   ; A1 is the only thing we need to keep from the
000016C6                           681                               ; parent routine
000016C6                           682          
000016C6  1C3C 0000                683          MOVE.B    #0,D6      ; we're storing the answer in D6
000016CA                           684  
000016CA  C443                     685          AND.W     D3,D2      ; get rid of all the unimportant parts
000016CC  B444                     686          CMP.W     D4,D2      ; compare the result with the signature of the cmd
000016CE  6600 000A                687          BNE       NEGATIVE   ; if they don't match skip everything else
000016D2                           688  
000016D2  2245                     689          MOVEA.L   D5,A1
000016D4  4E91                     690          JSR       (A1)        ; jump to the subroutine at D5
000016D6  1C3C 0001                691          MOVE.B    #1,D6
000016DA                           692   
000016DA                           693  NEGATIVE
000016DA  4CDF 0200                694          MOVEM.L   (SP)+,A1
000016DE  4E75                     695          RTS
000016E0                           696  
000016E0                           697  
000016E0                           698          INCLUDE 'PRINT_SIZE_EARLY.X68'
000016E0                           699  
000016E0                           700  PRINT_SIZE_EARLY_SUB
000016E0                           701  
000016E0                           702            * we want to modify A3 (it's like a pass-by-reference parameter)
000016E0                           703            * so we skip A3
000016E0  48E7 DFEE                704            MOVEM.L   D0-D1/D3-D7/A0-A2/A4-A6,-(SP)
000016E4                           705  
000016E4                           706            * D1 stores the opcode, so we isolate the size info and shift it
000016E4                           707            * to the end
000016E4  0241 3000                708            ANDI.W    #$3000,D1
000016E8  E049                     709            LSR.W     #8,D1
000016EA  E849                     710            LSR.W     #4,D1
000016EC                           711  
000016EC                           712            * we always print the period (2E in ASCII)
000016EC  16FC 002E                713            MOVE.B    #$2E,(A3)+
000016F0                           714  
000016F0                           715            * switch to the correct subroutine
000016F0  B23C 0001                716            CMP.B     #1,D1
000016F4  6700 0012                717            BEQ       PRINT_SIZE_EARLY_BYTE
000016F8  B23C 0003                718            CMP.B     #3,D1
000016FC  6700 001A                719            BEQ       PRINT_SIZE_EARLY_WORD
00001700  B23C 0002                720            CMP.B     #2,D1
00001704  6700 0022                721            BEQ       PRINT_SIZE_EARLY_LONG
00001708                           722  
00001708                           723  PRINT_SIZE_EARLY_BYTE
00001708  13FC 0000 00007761       724            MOVE.B    #0,SIZE_BUFFER
00001710  16FC 0042                725            MOVE.B    #$42,(A3)+
00001714  6000 0022                726            BRA       PRINT_SIZE_EARLY_END
00001718                           727  
00001718                           728  PRINT_SIZE_EARLY_WORD
00001718  13FC 0001 00007761       729            MOVE.B    #1,SIZE_BUFFER
00001720  16FC 0057                730            MOVE.B    #$57,(A3)+
00001724  6000 0012                731            BRA       PRINT_SIZE_EARLY_END
00001728                           732  
00001728                           733  PRINT_SIZE_EARLY_LONG
00001728  13FC 0002 00007761       734            MOVE.B    #2,SIZE_BUFFER
00001730  16FC 004C                735            MOVE.B    #$4C,(A3)+
00001734  6000 0002                736            BRA       PRINT_SIZE_EARLY_END
00001738                           737  
00001738                           738  PRINT_SIZE_EARLY_END
00001738                           739            * print a tab and return
00001738  16FC 0009                740            MOVE.B    #9,(A3)+
0000173C                           741  
0000173C  4CDF 77FB                742            MOVEM.L   (SP)+,D0-D1/D3-D7/A0-A2/A4-A6
00001740  4E75                     743            RTS
00001740  4E75                     744  -------------------- end include --------------------
00001742                           745          INCLUDE 'PRINT_SIZE_LATE.X68'
00001742                           746  
00001742                           747  PRINT_SIZE_LATE_SUB
00001742                           748  
00001742                           749            * we want to modify A3 (it's like a pass-by-reference parameter)
00001742                           750            * so we skip A3
00001742  48E7 DFEE                751            MOVEM.L   D0-D1/D3-D7/A0-A2/A4-A6,-(SP)
00001746                           752  
00001746                           753            * D1 stores the opcode, so we isolate the size info and shift it
00001746                           754            * to the end
00001746  EC49                     755            LSR.W     #6,D1
00001748  0241 0003                756            ANDI.W    #$3,D1
0000174C                           757  
0000174C                           758            * we always print the period (2E in ASCII)
0000174C  16FC 002E                759            MOVE.B    #$2E,(A3)+
00001750                           760  
00001750                           761            * switch to the correct subroutine
00001750  B23C 0000                762            CMP.B     #0,D1
00001754  6700 0012                763            BEQ       PRINT_SIZE_LATE_BYTE
00001758  B23C 0001                764            CMP.B     #1,D1
0000175C  6700 001A                765            BEQ       PRINT_SIZE_LATE_WORD
00001760  B23C 0002                766            CMP.B     #2,D1
00001764  6700 0022                767            BEQ       PRINT_SIZE_LATE_LONG
00001768                           768  
00001768                           769  PRINT_SIZE_LATE_BYTE
00001768  13FC 0000 00007761       770            MOVE.B    #0,SIZE_BUFFER
00001770  16FC 0042                771            MOVE.B    #$42,(A3)+
00001774  6000 0022                772            BRA       PRINT_SIZE_LATE_END
00001778                           773  
00001778                           774  PRINT_SIZE_LATE_WORD
00001778  13FC 0001 00007761       775            MOVE.B    #1,SIZE_BUFFER
00001780  16FC 0057                776            MOVE.B    #$57,(A3)+
00001784  6000 0012                777            BRA       PRINT_SIZE_LATE_END
00001788                           778  
00001788                           779  PRINT_SIZE_LATE_LONG
00001788  13FC 0002 00007761       780            MOVE.B    #2,SIZE_BUFFER
00001790  16FC 004C                781            MOVE.B    #$4C,(A3)+
00001794  6000 0002                782            BRA       PRINT_SIZE_LATE_END
00001798                           783  
00001798                           784  PRINT_SIZE_LATE_END
00001798                           785            * print a tab and return
00001798  16FC 0009                786            MOVE.B    #9,(A3)+
0000179C                           787  
0000179C  4CDF 77FB                788            MOVEM.L   (SP)+,D0-D1/D3-D7/A0-A2/A4-A6
000017A0  4E75                     789            RTS
000017A0  4E75                     790  -------------------- end include --------------------
000017A2                           791          INCLUDE 'PRINT_SOURCE.X68'
000017A2                           792  PRINT_SOURCE_SUB
000017A2                           793  
000017A2                           794            * we want to modify A1 & A3 (it's like a pass-by-reference parameter)
000017A2                           795            * so we skip A1 & A3
000017A2  48E7 C0AE                796            MOVEM.L   D0-D1/A0/A2/A4-A6,-(SP)
000017A6                           797  
000017A6                           798            * D1 stores the opcode, so we isolate the source info and shift it
000017A6                           799            * to the end
000017A6  2E01                     800            MOVE.L    D1,D7 ; keep a backup
000017A8  1C02                     801            MOVE.B    D2,D6 ; keep a backup
000017AA  0241 003F                802            ANDI.W    #$3F,D1
000017AE                           803  
000017AE                           804            * D2 is the mode, so isolate and shift
000017AE  1401                     805            MOVE.B    D1,D2
000017B0  0202 0038                806            ANDI.B    #$38,D2
000017B4  E60A                     807            LSR.B     #$3,D2
000017B6                           808  
000017B6                           809            * if it's not 7, it's Dn, An, (An), (An)+, etc
000017B6  B43C 0007                810            CMP.B     #7,D2
000017BA  6700 000C                811            BEQ       PRINT_SOURCE_MEM
000017BE  4EB9 000017DE            812            JSR       PRINT_SOURCE_REGISTER
000017C4  6000 000C                813            BRA       PRINT_SOURCE_END
000017C8                           814  
000017C8                           815  PRINT_SOURCE_MEM
000017C8  4EB9 0000185A            816            JSR       PRINT_SOURCE_MEMORY
000017CE  6000 0002                817            BRA       PRINT_SOURCE_END
000017D2                           818  
000017D2                           819  PRINT_SOURCE_END
000017D2  23CB 0000775C            820            MOVE.L    A3,OUT_CURR_A
000017D8  4CDF 7503                821            MOVEM.L   (SP)+,D0-D1/A0/A2/A4-A6
000017DC  4E75                     822            RTS
000017DE                           823  
000017DE                           824  
000017DE                           825  PRINT_SOURCE_REGISTER
000017DE  1601                     826            MOVE.B    D1,D3       ; copy Xn into D3
000017E0  0203 0007                827            ANDI.B    #7,D3       ; isolate the 3 bits that matter
000017E4  0603 0030                828            ADDI.B    #$30,D3     ; add to convert to ASCII
000017E8                           829  
000017E8  B43C 0000                830            CMP.B     #0,D2
000017EC  6700 0024                831            BEQ       PRINT_SOURCE_REGISTER_DN
000017F0  B43C 0001                832            CMP.B     #1,D2
000017F4  6700 0024                833            BEQ       PRINT_SOURCE_REGISTER_AN
000017F8  B43C 0002                834            CMP.B     #2,D2
000017FC  6700 0024                835            BEQ       PRINT_SOURCE_REGISTER_ANPAREN
00001800  B43C 0003                836            CMP.B     #3,D2
00001804  6700 002C                837            BEQ       PRINT_SOURCE_REGISTER_ANPLUS
00001808  B43C 0004                838            CMP.B     #4,D2
0000180C  6700 0038                839            BEQ       PRINT_SOURCE_REGISTER_ANMINUS
00001810                           840  
00001810  4E75                     841            RTS       ; quit if nothing is found
00001812                           842  
00001812                           843  PRINT_SOURCE_REGISTER_DN
00001812  16FC 0044                844            MOVE.B    #'D',(A3)+
00001816  16C3                     845            MOVE.B    D3,(A3)+
00001818  4E75                     846            RTS
0000181A                           847  
0000181A                           848  PRINT_SOURCE_REGISTER_AN
0000181A  16FC 0041                849            MOVE.B    #'A',(A3)+
0000181E  16C3                     850            MOVE.B    D3,(A3)+
00001820  4E75                     851            RTS
00001822                           852  
00001822                           853  PRINT_SOURCE_REGISTER_ANPAREN
00001822  16FC 0028                854            MOVE.B    #'(',(A3)+
00001826  16FC 0041                855            MOVE.B    #'A',(A3)+
0000182A  16C3                     856            MOVE.B    D3,(A3)+
0000182C  16FC 0029                857            MOVE.B    #')',(A3)+
00001830  4E75                     858            RTS
00001832                           859  
00001832                           860  PRINT_SOURCE_REGISTER_ANPLUS
00001832  16FC 0028                861            MOVE.B    #'(',(A3)+
00001836  16FC 0041                862            MOVE.B    #'A',(A3)+
0000183A  16C3                     863            MOVE.B    D3,(A3)+
0000183C  16FC 0029                864            MOVE.B    #')',(A3)+
00001840  16FC 002B                865            MOVE.B    #'+',(A3)+
00001844  4E75                     866            RTS
00001846                           867  
00001846                           868  PRINT_SOURCE_REGISTER_ANMINUS
00001846  16FC 002D                869            MOVE.B    #'-',(A3)+
0000184A  16FC 0028                870            MOVE.B    #'(',(A3)+
0000184E  16FC 0041                871            MOVE.B    #'A',(A3)+
00001852  16C3                     872            MOVE.B    D3,(A3)+
00001854  16FC 0029                873            MOVE.B    #')',(A3)+
00001858  4E75                     874            RTS
0000185A                           875  
0000185A                           876  
0000185A                           877  PRINT_SOURCE_MEMORY
0000185A                           878  
0000185A  1601                     879            MOVE.B    D1,D3       ; copy type into D3
0000185C  0203 0007                880            ANDI.B    #7,D3       ; isolate the 3 bits that matter
00001860                           881            
00001860  B63C 0000                882            CMP.B     #0,D3
00001864  6700 0012                883            BEQ       PRINT_SOURCE_MEMORY_ABS_W
00001868  B63C 0001                884            CMP.B     #1,D3
0000186C  6700 0026                885            BEQ       PRINT_SOURCE_MEMORY_ABS_L
00001870  B63C 0004                886            CMP.B     #4,D3
00001874  6700 0038                887            BEQ       PRINT_SOURCE_MEMORY_IMM
00001878                           888  
00001878                           889  PRINT_SOURCE_MEMORY_ABS_W
00001878  16FC 0024                890            MOVE.B    #'$',(A3)+
0000187C                           891  
0000187C  7800                     892            MOVE.L    #0,D4
0000187E  3819                     893            MOVE.W    (A1)+,D4
00001880                           894  
00001880  2A01                     895            MOVE.L    D1,D5
00001882  2204                     896            MOVE.L    D4,D1
00001884  23CB 0000775C            897            MOVE.L    A3,OUT_CURR_A
0000188A  4EB9 00001A5C            898            JSR       PRINT_NUM
00001890  2205                     899            MOVE.L    D5,D1
00001892  4E75                     900            RTS
00001894                           901  
00001894                           902  PRINT_SOURCE_MEMORY_ABS_L
00001894  16FC 0024                903            MOVE.B    #'$',(A3)+
00001898                           904  
00001898  2819                     905            MOVE.L    (A1)+,D4
0000189A                           906  
0000189A  2A01                     907            MOVE.L    D1,D5
0000189C  2204                     908            MOVE.L    D4,D1
0000189E  23CB 0000775C            909            MOVE.L    A3,OUT_CURR_A
000018A4  4EB9 00001A5C            910            JSR       PRINT_NUM
000018AA  2205                     911            MOVE.L    D5,D1
000018AC  4E75                     912            RTS
000018AE                           913  
000018AE                           914  PRINT_SOURCE_MEMORY_IMM
000018AE                           915            * check if it's long or short addressing
000018AE  0C39 0002 00007761       916            CMP.B     #2,SIZE_BUFFER
000018B6  6700 0006                917            BEQ       PRINT_SOURCE_MEMORY_IMM_L
000018BA  6000 0020                918            BRA       PRINT_SOURCE_MEMORY_IMM_W
000018BE                           919  
000018BE                           920  PRINT_SOURCE_MEMORY_IMM_L
000018BE  16FC 0023                921            MOVE.B    #'#',(A3)+
000018C2  16FC 0024                922            MOVE.B    #'$',(A3)+
000018C6                           923  
000018C6  2819                     924            MOVE.L    (A1)+,D4
000018C8                           925  
000018C8  2A01                     926            MOVE.L    D1,D5
000018CA  2204                     927            MOVE.L    D4,D1
000018CC  23CB 0000775C            928            MOVE.L    A3,OUT_CURR_A
000018D2  4EB9 00001A5C            929            JSR       PRINT_NUM
000018D8  2205                     930            MOVE.L    D5,D1
000018DA  4E75                     931            RTS
000018DC                           932            
000018DC                           933  PRINT_SOURCE_MEMORY_IMM_W
000018DC  16FC 0023                934            MOVE.B    #'#',(A3)+
000018E0  16FC 0024                935            MOVE.B    #'$',(A3)+
000018E4                           936  
000018E4  7800                     937            MOVE.L    #0,D4
000018E6  3819                     938            MOVE.W    (A1)+,D4
000018E8                           939  
000018E8  2A01                     940            MOVE.L    D1,D5
000018EA  2204                     941            MOVE.L    D4,D1
000018EC  23CB 0000775C            942            MOVE.L    A3,OUT_CURR_A
000018F2  4EB9 00001A5C            943            JSR       PRINT_NUM
000018F8  2205                     944            MOVE.L    D5,D1
000018FA  4E75                     945            RTS
000018FA  4E75                     946  -------------------- end include --------------------
000018FC                           947          INCLUDE 'PRINT_DEST.X68'
000018FC                           948  PRINT_DEST_SUB
000018FC                           949  
000018FC                           950            * we want to modify A3 (it's like a pass-by-reference parameter)
000018FC                           951            * so we skip A3
000018FC  48E7 C0AE                952            MOVEM.L   D0-D1/A0/A2/A4-A6,-(SP)
00001900                           953  
00001900                           954            * D1 stores the opcode, so we isolate the source info and shift it
00001900                           955            * to the end
00001900  0241 0FC0                956            ANDI.W    #$FC0,D1
00001904                           957  
00001904                           958            * D2 is the mode, so isolate and shift
00001904  3401                     959            MOVE.W    D1,D2
00001906  0242 01C0                960            ANDI.W    #$1C0,D2
0000190A  EC4A                     961            LSR.W     #6,D2
0000190C                           962  
0000190C                           963            * if it's not 7, it's Dn, An, (An), (An)+, etc
0000190C  B43C 0007                964            CMP.B     #7,D2
00001910  6700 000C                965            BEQ       PRINT_DEST_MEM
00001914  4EB9 0000192E            966            JSR       PRINT_DEST_REGISTER
0000191A  6000 000C                967            BRA       PRINT_DEST_END
0000191E                           968  
0000191E                           969  PRINT_DEST_MEM
0000191E  4EB9 000019AE            970            JSR       PRINT_DEST_MEMORY
00001924  6000 0002                971            BRA       PRINT_DEST_END
00001928                           972  
00001928                           973  PRINT_DEST_END
00001928  4CDF 7503                974            MOVEM.L   (SP)+,D0-D1/A0/A2/A4-A6
0000192C  4E75                     975            RTS
0000192E                           976  
0000192E                           977  
0000192E                           978  PRINT_DEST_REGISTER
0000192E  3601                     979            MOVE.W    D1,D3       ; copy Xn into D3
00001930  0243 0E00                980            ANDI.W    #$E00,D3    ; isolate the 3 bits that matter
00001934  E04B                     981            LSR.W     #8,D3
00001936  E24B                     982            LSR.W     #1,D3
00001938  0643 0030                983            ADDI.W    #$30,D3     ; add to convert to ASCII
0000193C                           984  
0000193C  B43C 0000                985            CMP.B     #0,D2
00001940  6700 0024                986            BEQ       PRINT_DEST_REGISTER_DN
00001944  B43C 0001                987            CMP.B     #1,D2
00001948  6700 0024                988            BEQ       PRINT_DEST_REGISTER_AN
0000194C  B43C 0002                989            CMP.B     #2,D2
00001950  6700 0024                990            BEQ       PRINT_DEST_REGISTER_ANPAREN
00001954  B43C 0003                991            CMP.B     #3,D2
00001958  6700 002C                992            BEQ       PRINT_DEST_REGISTER_ANPLUS
0000195C  B43C 0004                993            CMP.B     #4,D2
00001960  6700 0038                994            BEQ       PRINT_DEST_REGISTER_ANMINUS
00001964                           995  
00001964  4E75                     996            RTS       ; quit if nothing is found
00001966                           997  
00001966                           998  PRINT_DEST_REGISTER_DN
00001966  16FC 0044                999            MOVE.B    #'D',(A3)+
0000196A  16C3                    1000            MOVE.B    D3,(A3)+
0000196C  4E75                    1001            RTS
0000196E                          1002  
0000196E                          1003  PRINT_DEST_REGISTER_AN
0000196E  16FC 0041               1004            MOVE.B    #'A',(A3)+
00001972  16C3                    1005            MOVE.B    D3,(A3)+
00001974  4E75                    1006            RTS
00001976                          1007  
00001976                          1008  PRINT_DEST_REGISTER_ANPAREN
00001976  16FC 0028               1009            MOVE.B    #'(',(A3)+
0000197A  16FC 0041               1010            MOVE.B    #'A',(A3)+
0000197E  16C3                    1011            MOVE.B    D3,(A3)+
00001980  16FC 0029               1012            MOVE.B    #')',(A3)+
00001984  4E75                    1013            RTS
00001986                          1014  
00001986                          1015  PRINT_DEST_REGISTER_ANPLUS
00001986  16FC 0028               1016            MOVE.B    #'(',(A3)+
0000198A  16FC 0041               1017            MOVE.B    #'A',(A3)+
0000198E  16C3                    1018            MOVE.B    D3,(A3)+
00001990  16FC 0029               1019            MOVE.B    #')',(A3)+
00001994  16FC 002B               1020            MOVE.B    #'+',(A3)+
00001998  4E75                    1021            RTS
0000199A                          1022  
0000199A                          1023  PRINT_DEST_REGISTER_ANMINUS
0000199A  16FC 002D               1024            MOVE.B    #'-',(A3)+
0000199E  16FC 0028               1025            MOVE.B    #'(',(A3)+
000019A2  16FC 0041               1026            MOVE.B    #'A',(A3)+
000019A6  16C3                    1027            MOVE.B    D3,(A3)+
000019A8  16FC 0029               1028            MOVE.B    #')',(A3)+
000019AC  4E75                    1029            RTS
000019AE                          1030  
000019AE                          1031  
000019AE                          1032  PRINT_DEST_MEMORY
000019AE                          1033  
000019AE  3601                    1034            MOVE.W    D1,D3       ; copy type into D3
000019B0  0243 0E00               1035            ANDI.W    #$E00,D3    ; isolate the 3 bits that matter
000019B4  E04B                    1036            LSR.W     #8,D3
000019B6  E24B                    1037            LSR.W     #1,D3
000019B8                          1038            
000019B8  B63C 0000               1039            CMP.B     #0,D3
000019BC  6700 0012               1040            BEQ       PRINT_DEST_MEMORY_ABS_W
000019C0  B63C 0001               1041            CMP.B     #1,D3
000019C4  6700 0026               1042            BEQ       PRINT_DEST_MEMORY_ABS_L
000019C8  B63C 0004               1043            CMP.B     #4,D3
000019CC  6700 0038               1044            BEQ       PRINT_DEST_MEMORY_IMM
000019D0                          1045  
000019D0                          1046  PRINT_DEST_MEMORY_ABS_W
000019D0  16FC 0024               1047            MOVE.B    #'$',(A3)+
000019D4                          1048  
000019D4  7800                    1049            MOVE.L    #0,D4
000019D6  3819                    1050            MOVE.W    (A1)+,D4
000019D8                          1051  
000019D8  2A01                    1052            MOVE.L    D1,D5
000019DA  2204                    1053            MOVE.L    D4,D1
000019DC  23CB 0000775C           1054            MOVE.L    A3,OUT_CURR_A
000019E2  4EB9 00001A5C           1055            JSR       PRINT_NUM
000019E8  2205                    1056            MOVE.L    D5,D1
000019EA  4E75                    1057            RTS
000019EC                          1058  
000019EC                          1059  PRINT_DEST_MEMORY_ABS_L
000019EC  16FC 0024               1060            MOVE.B    #'$',(A3)+
000019F0                          1061  
000019F0  2819                    1062            MOVE.L    (A1)+,D4
000019F2                          1063  
000019F2  2A01                    1064            MOVE.L    D1,D5
000019F4  2204                    1065            MOVE.L    D4,D1
000019F6  23CB 0000775C           1066            MOVE.L    A3,OUT_CURR_A
000019FC  4EB9 00001A5C           1067            JSR       PRINT_NUM
00001A02  2205                    1068            MOVE.L    D5,D1
00001A04  4E75                    1069            RTS
00001A06                          1070  
00001A06                          1071  PRINT_DEST_MEMORY_IMM
00001A06                          1072            * check if it's long or short addressing
00001A06  2801                    1073            MOVE.L    D1,D4
00001A08  E08C                    1074            LSR.L     #8,D4
00001A0A  E88C                    1075            LSR.L     #4,D4
00001A0C  0284 00000003           1076            ANDI.L    #3,D4
00001A12                          1077  
00001A12  B03C 0002               1078            CMP.B     #2,D0
00001A16  6700 0006               1079            BEQ       PRINT_DEST_MEMORY_IMM_L
00001A1A  6000 0020               1080            BRA       PRINT_DEST_MEMORY_IMM_W
00001A1E                          1081  
00001A1E                          1082  PRINT_DEST_MEMORY_IMM_L
00001A1E  16FC 0023               1083            MOVE.B    #'#',(A3)+
00001A22  16FC 0024               1084            MOVE.B    #'$',(A3)+
00001A26                          1085  
00001A26  2819                    1086            MOVE.L    (A1)+,D4
00001A28                          1087  
00001A28  2A01                    1088            MOVE.L    D1,D5
00001A2A  2204                    1089            MOVE.L    D4,D1
00001A2C  23CB 0000775C           1090            MOVE.L    A3,OUT_CURR_A
00001A32  4EB9 00001A5C           1091            JSR       PRINT_NUM
00001A38  2205                    1092            MOVE.L    D5,D1
00001A3A  4E75                    1093            RTS
00001A3C                          1094            
00001A3C                          1095  PRINT_DEST_MEMORY_IMM_W
00001A3C  16FC 0023               1096            MOVE.B    #'#',(A3)+
00001A40  16FC 0024               1097            MOVE.B    #'$',(A3)+
00001A44                          1098  
00001A44  7800                    1099            MOVE.L    #0,D4
00001A46  3819                    1100            MOVE.W    (A1)+,D4
00001A48                          1101  
00001A48  2A01                    1102            MOVE.L    D1,D5
00001A4A  2204                    1103            MOVE.L    D4,D1
00001A4C  23CB 0000775C           1104            MOVE.L    A3,OUT_CURR_A
00001A52  4EB9 00001A5C           1105            JSR       PRINT_NUM
00001A58  2205                    1106            MOVE.L    D5,D1
00001A5A  4E75                    1107            RTS
00001A5A  4E75                    1108  -------------------- end include --------------------
00001A5C                          1109          INCLUDE 'PRINT_NUM.X68'
00001A5C                          1110  PRINT_NUM
00001A5C  48E7 FF6E               1111          MOVEM.L     D0-D7/A1-A2/A4-A6,-(SP)
00001A60  2679 0000775C           1112          MOVEA.L     OUT_CURR_A,A3
00001A66  4BF9 00007762           1113          LEA         PRINT_NUM_STACK,A5
00001A6C  363C 0000               1114          MOVE.W      #0,D3  ; D3 is our counter
00001A70                          1115                          ; like the i in "for(int i=0;i<9;i++)"
00001A70                          1116  
00001A70                          1117          * get the last digit into D2
00001A70                          1118  PRINT_NUM_LOOP1
00001A70  2401                    1119          MOVE.L      D1,D2
00001A72  E889                    1120          LSR.L       #4,D1
00001A74  0282 0000000F           1121          ANDI.L      #$F,D2
00001A7A  4EB9 00001AA4           1122          JSR         PRINT_NUM_CONV
00001A80  1AC2                    1123          MOVE.B      D2,(A5)+ ; push onto temporary stack
00001A82  5243                    1124          ADDI.W      #1,D3
00001A84  4A81                    1125          TST.L       D1      ; if the next digit is a 0, stop
00001A86  6700 0004               1126          BEQ         PRINT_NUM_LOOP1_END
00001A8A  60E4                    1127          BRA         PRINT_NUM_LOOP1
00001A8C                          1128  
00001A8C                          1129  PRINT_NUM_LOOP1_END
00001A8C                          1130  
00001A8C                          1131  PRINT_NUM_LOOP2
00001A8C  4A43                    1132          TST.W       D3
00001A8E  6700 0008               1133          BEQ         PRINT_NUM_LOOP2_END ; stop once we print all out numbers
00001A92  16E5                    1134          MOVE.B      -(A5),(A3)+         ; add our number to our output
00001A94  5343                    1135          SUBI.W      #1,D3
00001A96  60F4                    1136          BRA         PRINT_NUM_LOOP2
00001A98                          1137        
00001A98                          1138  PRINT_NUM_LOOP2_END
00001A98                          1139  
00001A98  23CB 0000775C           1140          MOVE.L      A3,OUT_CURR_A
00001A9E  4CDF 76FF               1141          MOVEM.L     (SP)+,D0-D7/A1-A2/A4-A6
00001AA2  4E75                    1142          RTS
00001AA4                          1143  
00001AA4                          1144  PRINT_NUM_CONV
00001AA4  B43C 0009               1145          CMP.B       #9,D2
00001AA8  6300 0008               1146          BLS         PRINT_NUM_CONV_DIG    ; BLS because we want to ignore +/-
00001AAC  0602 0037               1147          ADDI.B      #$37,D2   ; it's a digit A-F, add the right number and RTS
00001AB0  4E75                    1148          RTS
00001AB2                          1149  
00001AB2                          1150  PRINT_NUM_CONV_DIG
00001AB2  0602 0030               1151          ADDI.B      #$30,D2   ; it's a digit 0-9, add the right number and RTS
00001AB6  4E75                    1152          RTS
00001AB8                          1153  
00001AB8                          1154  -------------------- end include --------------------
00001AB8                          1155  
00001AB8                          1156          INCLUDE 'BAD_COMMAND.X68'
00001AB8                          1157  
00001AB8                          1158  BAD_COMMAND_SUB
00001AB8  48E7 FFFE               1159          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00001ABC                          1160  
00001ABC  227C 00000000           1161          MOVEA.L   #0,A1             ; load the current opcode into a register
00001AC2  2279 00007750           1162          MOVEA.L   IN_CURR_A,A1
00001AC8  3219                    1163          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00001ACA                          1164  
00001ACA  267C 00000000           1165          MOVEA.L   #0,A3
00001AD0  2679 0000775C           1166          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00001AD6  49F9 0000776A           1167          LEA       BAD_COMMAND_STR,A4 ; move the to-be-printed string to A4
00001ADC                          1168  
00001ADC                          1169          * we need to append the string at NOP_STR to the output string
00001ADC                          1170          * we do this char by char (byte by byte) until we see a NULL (0)
00001ADC                          1171          * in NOP_STR
00001ADC                          1172  
00001ADC                          1173          * the code is invalid of we find a bad command
00001ADC  13FC 0000 00007760      1174          MOVE.B    #0,IS_VALID
00001AE4                          1175  
00001AE4                          1176  BCMD_COPY
00001AE4  4A14                    1177          TST.B     (A4)  ; test the contents of A4
00001AE6  6700 0006               1178          BEQ       BCMD_DONE  ; if we hit a 00, we're done copying
00001AEA                          1179  
00001AEA  16DC                    1180          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00001AEC  60F6                    1181          BRA       BCMD_COPY     ; do it again
00001AEE                          1182  
00001AEE                          1183  BCMD_DONE
00001AEE                          1184  
00001AEE                          1185          * convert the opcode into ASCII
00001AEE                          1186          * digit 1
00001AEE  3401                    1187          MOVE.W    D1,D2
00001AF0  E04A                    1188          LSR.W     #8,D2   ; get the first digit all on it's own
00001AF2  E84A                    1189          LSR.W     #4,D2
00001AF4  0242 000F               1190          ANDI.W    #$F,D2
00001AF8  4EB9 00001B48           1191          JSR       DIGIT_TO_ASCII 
00001AFE  16C2                    1192          MOVE.B    D2,(A3)+
00001B00                          1193  
00001B00                          1194          * digit 2
00001B00  3401                    1195          MOVE.W    D1,D2
00001B02  E04A                    1196          LSR.W     #8,D2   ; get the second digit all on it's own
00001B04  0242 000F               1197          ANDI.W    #$F,D2
00001B08  4EB9 00001B48           1198          JSR       DIGIT_TO_ASCII 
00001B0E  16C2                    1199          MOVE.B    D2,(A3)+
00001B10                          1200  
00001B10                          1201          * digit 3
00001B10  3401                    1202          MOVE.W    D1,D2
00001B12  E84A                    1203          LSR.W     #4,D2   ; get the third digit all on it's own
00001B14  0242 000F               1204          ANDI.W    #$F,D2
00001B18  4EB9 00001B48           1205          JSR       DIGIT_TO_ASCII 
00001B1E  16C2                    1206          MOVE.B    D2,(A3)+
00001B20                          1207  
00001B20                          1208          * digit 4
00001B20  3401                    1209          MOVE.W    D1,D2
00001B22  0242 000F               1210          ANDI.W    #$F,D2  ; get the last digit all on it's own
00001B26  4EB9 00001B48           1211          JSR       DIGIT_TO_ASCII 
00001B2C  16C2                    1212          MOVE.B    D2,(A3)+
00001B2E                          1213  
00001B2E                          1214          * newline
00001B2E  16FC 000A               1215          MOVE.B    #$0A,(A3)+
00001B32  16FC 000D               1216          MOVE.B    #$0D,(A3)+
00001B36                          1217  
00001B36  23C9 00007750           1218          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
00001B3C  23CB 0000775C           1219          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
00001B42                          1220  
00001B42  4CDF 7FFF               1221          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
00001B46  4E75                    1222          RTS       ; return
00001B48                          1223  
00001B48                          1224  
00001B48                          1225  DIGIT_TO_ASCII
00001B48                          1226  
00001B48  B43C 0000               1227          CMP.B   #0,D2
00001B4C  6D00 0010               1228          BLT     NAN
00001B50  B43C 0009               1229          CMP.B   #9,D2
00001B54  6E00 0008               1230          BGT     NAN
00001B58                          1231  
00001B58  0602 0030               1232          ADDI.B  #$30,D2
00001B5C  4E75                    1233          RTS
00001B5E                          1234  
00001B5E                          1235  NAN
00001B5E  0602 0037               1236          ADDI.B  #$37,D2
00001B62                          1237  
00001B62  4E75                    1238          RTS
00001B64                          1239          
00001B64                          1240  
00001B64                          1241  -------------------- end include --------------------
00001B64                          1242          INCLUDE 'SUBI_SUB.X68'
00001B64                          1243  
00001B64                          1244  SUBI_SUB
00001B64  48E7 FFFE               1245          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00001B68                          1246  
00001B68                          1247          * sets up the data registers
00001B68                          1248          *
00001B68                          1249          * A1 - the current opcode's address
00001B68                          1250          * A3 - the current position of the output
00001B68                          1251          * A4 - the location of the text for printing
00001B68                          1252          *
00001B68                          1253          * D1 - the actual opcode
00001B68                          1254          *
00001B68  227C 00000000           1255          MOVEA.L   #0,A1             ; load the current opcode into a register
00001B6E  2279 00007750           1256          MOVEA.L   IN_CURR_A,A1
00001B74  3219                    1257          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00001B76                          1258  
00001B76  267C 00000000           1259          MOVEA.L   #0,A3
00001B7C  2679 0000775C           1260          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00001B82  49F9 000077B7           1261          LEA       SUBI_STR,A4     ; move the to-be-printed string to A4
00001B88                          1262  
00001B88                          1263          * we need to append the string at SUBI_STR to the output string
00001B88                          1264          * we do this char by char (byte by byte) until we see a NULL (0)
00001B88                          1265          * in SUBI_STR
00001B88                          1266  
00001B88                          1267  SUBI_COPY
00001B88  4A14                    1268          TST.B     (A4)      ; test the contents of A4
00001B8A  6700 0006               1269          BEQ       SUBI_DONE  ; if we hit a 00, we're done copying
00001B8E                          1270  
00001B8E  16DC                    1271          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00001B90  60F6                    1272          BRA       SUBI_COPY      ; do it again
00001B92                          1273          
00001B92                          1274  SUBI_DONE
00001B92                          1275    
00001B92                          1276          * D4 = size       ( 0 = B, 1 = W, 2 = L)
00001B92                          1277          * D5 = direction  ( 0 = Dn first, 1 = <ea> first)
00001B92                          1278  
00001B92  3401                    1279          MOVE.W    D1,D2
00001B94  EC4A                    1280          LSR.W     #6,D2
00001B96  0242 0007               1281          ANDI.W    #7,D2
00001B9A                          1282  
00001B9A  B47C 0000               1283          CMP.W     #0,D2
00001B9E  6700 002E               1284          BEQ       SUBI_BYTE_DN
00001BA2  B47C 0001               1285          CMP.W     #1,D2
00001BA6  6700 0032               1286          BEQ       SUBI_WORD_DN
00001BAA  B47C 0002               1287          CMP.W     #2,D2
00001BAE  6700 0036               1288          BEQ       SUBI_LONG_DN
00001BB2                          1289  
00001BB2  B47C 0004               1290          CMP.W     #4,D2
00001BB6  6700 003A               1291          BEQ       SUBI_BYTE_EA
00001BBA  B47C 0005               1292          CMP.W     #5,D2
00001BBE  6700 003E               1293          BEQ       SUBI_WORD_EA
00001BC2  B47C 0006               1294          CMP.W     #6,D2
00001BC6  6700 0042               1295          BEQ       SUBI_LONG_EA
00001BCA                          1296          
00001BCA                          1297          * if nothing is found just jump to the end
00001BCA  6000 004A               1298          BRA       SUBI_PARAM_DONE
00001BCE                          1299  
00001BCE                          1300  SUBI_BYTE_DN
00001BCE  183C 0000               1301          MOVE.B    #0,D4
00001BD2  1A3C 0000               1302          MOVE.B    #0,D5
00001BD6  6000 003E               1303          BRA       SUBI_PARAM_DONE
00001BDA                          1304  
00001BDA                          1305  SUBI_WORD_DN
00001BDA  183C 0001               1306          MOVE.B    #1,D4
00001BDE  1A3C 0000               1307          MOVE.B    #0,D5
00001BE2  6000 0032               1308          BRA       SUBI_PARAM_DONE
00001BE6                          1309  
00001BE6                          1310  SUBI_LONG_DN
00001BE6  183C 0002               1311          MOVE.B    #2,D4
00001BEA  1A3C 0000               1312          MOVE.B    #0,D5
00001BEE  6000 0026               1313          BRA       SUBI_PARAM_DONE
00001BF2                          1314  
00001BF2                          1315  SUBI_BYTE_EA
00001BF2  183C 0000               1316          MOVE.B    #0,D4
00001BF6  1A3C 0001               1317          MOVE.B    #1,D5
00001BFA  6000 001A               1318          BRA       SUBI_PARAM_DONE
00001BFE                          1319          
00001BFE                          1320  SUBI_WORD_EA
00001BFE  183C 0001               1321          MOVE.B    #1,D4
00001C02  1A3C 0001               1322          MOVE.B    #1,D5
00001C06  6000 000E               1323          BRA       SUBI_PARAM_DONE
00001C0A                          1324  
00001C0A                          1325  SUBI_LONG_EA
00001C0A  183C 0002               1326          MOVE.B    #2,D4
00001C0E  1A3C 0001               1327          MOVE.B    #1,D5
00001C12  6000 0002               1328          BRA       SUBI_PARAM_DONE
00001C16                          1329  
00001C16                          1330  SUBI_PARAM_DONE
00001C16                          1331          
00001C16                          1332          * -------------------
00001C16                          1333          * print the size
00001C16                          1334          * -------------------
00001C16                          1335  
00001C16  16FC 002E               1336          MOVE.B    #'.',(A3)+
00001C1A  B83C 0000               1337          CMP.B     #0,D4
00001C1E  6700 0016               1338          BEQ       SUBI_PRINT_SIZE_BYTE
00001C22  B83C 0001               1339          CMP.B     #1,D4
00001C26  6700 0016               1340          BEQ       SUBI_PRINT_SIZE_WORD
00001C2A  B83C 0002               1341          CMP.B     #2,D4
00001C2E  6700 0016               1342          BEQ       SUBI_PRINT_SIZE_LONG
00001C32                          1343  
00001C32  6000 001A               1344          BRA       SUBI_PRINT_SIZE_DONE
00001C36                          1345  
00001C36                          1346  SUBI_PRINT_SIZE_BYTE
00001C36  16FC 0042               1347          MOVE.B    #'B',(A3)+
00001C3A  6000 0012               1348          BRA       SUBI_PRINT_SIZE_DONE
00001C3E                          1349  SUBI_PRINT_SIZE_WORD
00001C3E  16FC 0057               1350          MOVE.B    #'W',(A3)+
00001C42  6000 000A               1351          BRA       SUBI_PRINT_SIZE_DONE
00001C46                          1352  SUBI_PRINT_SIZE_LONG
00001C46  16FC 004C               1353          MOVE.B    #'L',(A3)+
00001C4A  6000 0002               1354          BRA       SUBI_PRINT_SIZE_DONE
00001C4E                          1355  
00001C4E                          1356  SUBI_PRINT_SIZE_DONE
00001C4E  16FC 0009               1357          MOVE.B    #9,(A3)+
00001C52  16FC 0023               1358          MOVE.B    #'#',(A3)+
00001C56  16FC 0024               1359          MOVE.B    #'$',(A3)+
00001C5A                          1360  
00001C5A                          1361          * --------------------
00001C5A                          1362          * print address number
00001C5A                          1363          * --------------------
00001C5A  B83C 0002               1364          CMP.B     #2,D4       ; if we're using long addressing, get next long
00001C5E  6700 000C               1365          BEQ       SUBI_PRINT_AL
00001C62  4EB9 00001CB2           1366          JSR       SUBI_PRINT_ADDR_WORD
00001C68  6000 0008               1367          BRA       SUBI_PRINT_ADDR_DONE
00001C6C                          1368  
00001C6C                          1369  SUBI_PRINT_AL
00001C6C  4EB9 00001CCA           1370          JSR       SUBI_PRINT_ADDR_LONG
00001C72                          1371  
00001C72                          1372  SUBI_PRINT_ADDR_DONE
00001C72                          1373  
00001C72  16FC 002C               1374          MOVE.B    #',',(A3)+
00001C76                          1375  
00001C76                          1376          * JSR       SUBI_EA_TO_DN
00001C76  4EB8 17A2               1377          JSR       PRINT_SOURCE_SUB    ; the "source" is actually the source here
00001C7A                          1378  
00001C7A                          1379  SUBI_END
00001C7A                          1380  
00001C7A  16FC 000A               1381          MOVE.B    #$0A,(A3)+
00001C7E  16FC 000D               1382          MOVE.B    #$0D,(A3)+
00001C82                          1383  
00001C82  23C9 00007750           1384          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
00001C88  23CB 0000775C           1385          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
00001C8E                          1386  
00001C8E  4CDF 7FFF               1387          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
00001C92  4E75                    1388          RTS       ; return
00001C94                          1389  
00001C94                          1390  SUBI_EA_TO_DN
00001C94                          1391  
00001C94  4EB8 17A2               1392          JSR       PRINT_SOURCE_SUB    ; the "source" is actually the source here
00001C98  16FC 002C               1393          MOVE.B    #',',(A3)+
00001C9C  16FC 0044               1394          MOVE.B    #'D',(A3)+
00001CA0  3401                    1395          MOVE.W    D1,D2
00001CA2  E04A                    1396          LSR.W     #8,D2
00001CA4  E24A                    1397          LSR.W     #1,D2
00001CA6  0242 0007               1398          ANDI.W    #7,D2
00001CAA  0642 0030               1399          ADDI.W    #$30,D2
00001CAE  16C2                    1400          MOVE.B    D2,(A3)+
00001CB0                          1401  
00001CB0  4E75                    1402          RTS
00001CB2                          1403  
00001CB2                          1404  SUBI_PRINT_ADDR_WORD
00001CB2  48E7 4000               1405          MOVEM.L   D1,-(SP) ; move the old registers onto the stack
00001CB6                          1406  
00001CB6  4281                    1407          CLR.L     D1
00001CB8  3219                    1408          MOVE.W    (A1)+,D1      ; move the next word into D1
00001CBA  23CB 0000775C           1409          MOVE.L    A3,OUT_CURR_A ; update the output pos before we print
00001CC0  4EB8 1A5C               1410          JSR       PRINT_NUM     ; print the number in D1
00001CC4                          1411  
00001CC4  4CDF 0002               1412          MOVEM.L   (SP)+,D1 ; move the old registers back to the stack
00001CC8  4E75                    1413          RTS
00001CCA                          1414  SUBI_PRINT_ADDR_LONG
00001CCA  48E7 4000               1415          MOVEM.L   D1,-(SP) ; move the old registers onto the stack
00001CCE                          1416  
00001CCE  4281                    1417          CLR.L     D1
00001CD0  2219                    1418          MOVE.L    (A1)+,D1      ; move the next word into D1
00001CD2  23CB 0000775C           1419          MOVE.L    A3,OUT_CURR_A ; update the output pos before we print
00001CD8  4EB8 1A5C               1420          JSR       PRINT_NUM     ; print the number in D1
00001CDC                          1421  
00001CDC  4CDF 0002               1422          MOVEM.L   (SP)+,D1 ; move the old registers back to the stack
00001CE0  4E75                    1423          RTS
00001CE0  4E75                    1424  -------------------- end include --------------------
00001CE2                          1425          INCLUDE 'ADDI_SUB.X68'
00001CE2                          1426  
00001CE2                          1427  ADDI_SUB
00001CE2  48E7 FFFE               1428          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00001CE6                          1429  
00001CE6                          1430          * sets up the data registers
00001CE6                          1431          *
00001CE6                          1432          * A1 - the current opcode's address
00001CE6                          1433          * A3 - the current position of the output
00001CE6                          1434          * A4 - the location of the text for printing
00001CE6                          1435          *
00001CE6                          1436          * D1 - the actual opcode
00001CE6                          1437          *
00001CE6  227C 00000000           1438          MOVEA.L   #0,A1             ; load the current opcode into a register
00001CEC  2279 00007750           1439          MOVEA.L   IN_CURR_A,A1
00001CF2  3219                    1440          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00001CF4                          1441  
00001CF4  267C 00000000           1442          MOVEA.L   #0,A3
00001CFA  2679 0000775C           1443          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00001D00  49F9 000077A9           1444          LEA       ADDI_STR,A4     ; move the to-be-printed string to A4
00001D06                          1445  
00001D06                          1446          * we need to append the string at ADDI_STR to the output string
00001D06                          1447          * we do this char by char (byte by byte) until we see a NULL (0)
00001D06                          1448          * in ADDI_STR
00001D06                          1449  
00001D06                          1450  ADDI_COPY
00001D06  4A14                    1451          TST.B     (A4)      ; test the contents of A4
00001D08  6700 0006               1452          BEQ       ADDI_DONE  ; if we hit a 00, we're done copying
00001D0C                          1453  
00001D0C  16DC                    1454          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00001D0E  60F6                    1455          BRA       ADDI_COPY      ; do it again
00001D10                          1456          
00001D10                          1457  ADDI_DONE
00001D10                          1458    
00001D10                          1459          * D4 = size       ( 0 = B, 1 = W, 2 = L)
00001D10                          1460          * D5 = direction  ( 0 = Dn first, 1 = <ea> first)
00001D10                          1461  
00001D10  3401                    1462          MOVE.W    D1,D2
00001D12  EC4A                    1463          LSR.W     #6,D2
00001D14  0242 0007               1464          ANDI.W    #7,D2
00001D18                          1465  
00001D18  B47C 0000               1466          CMP.W     #0,D2
00001D1C  6700 002E               1467          BEQ       ADDI_BYTE_DN
00001D20  B47C 0001               1468          CMP.W     #1,D2
00001D24  6700 0032               1469          BEQ       ADDI_WORD_DN
00001D28  B47C 0002               1470          CMP.W     #2,D2
00001D2C  6700 0036               1471          BEQ       ADDI_LONG_DN
00001D30                          1472  
00001D30  B47C 0004               1473          CMP.W     #4,D2
00001D34  6700 003A               1474          BEQ       ADDI_BYTE_EA
00001D38  B47C 0005               1475          CMP.W     #5,D2
00001D3C  6700 003E               1476          BEQ       ADDI_WORD_EA
00001D40  B47C 0006               1477          CMP.W     #6,D2
00001D44  6700 0042               1478          BEQ       ADDI_LONG_EA
00001D48                          1479          
00001D48                          1480          * if nothing is found just jump to the end
00001D48  6000 004A               1481          BRA       ADDI_PARAM_DONE
00001D4C                          1482  
00001D4C                          1483  ADDI_BYTE_DN
00001D4C  183C 0000               1484          MOVE.B    #0,D4
00001D50  1A3C 0000               1485          MOVE.B    #0,D5
00001D54  6000 003E               1486          BRA       ADDI_PARAM_DONE
00001D58                          1487  
00001D58                          1488  ADDI_WORD_DN
00001D58  183C 0001               1489          MOVE.B    #1,D4
00001D5C  1A3C 0000               1490          MOVE.B    #0,D5
00001D60  6000 0032               1491          BRA       ADDI_PARAM_DONE
00001D64                          1492  
00001D64                          1493  ADDI_LONG_DN
00001D64  183C 0002               1494          MOVE.B    #2,D4
00001D68  1A3C 0000               1495          MOVE.B    #0,D5
00001D6C  6000 0026               1496          BRA       ADDI_PARAM_DONE
00001D70                          1497  
00001D70                          1498  ADDI_BYTE_EA
00001D70  183C 0000               1499          MOVE.B    #0,D4
00001D74  1A3C 0001               1500          MOVE.B    #1,D5
00001D78  6000 001A               1501          BRA       ADDI_PARAM_DONE
00001D7C                          1502          
00001D7C                          1503  ADDI_WORD_EA
00001D7C  183C 0001               1504          MOVE.B    #1,D4
00001D80  1A3C 0001               1505          MOVE.B    #1,D5
00001D84  6000 000E               1506          BRA       ADDI_PARAM_DONE
00001D88                          1507  
00001D88                          1508  ADDI_LONG_EA
00001D88  183C 0002               1509          MOVE.B    #2,D4
00001D8C  1A3C 0001               1510          MOVE.B    #1,D5
00001D90  6000 0002               1511          BRA       ADDI_PARAM_DONE
00001D94                          1512  
00001D94                          1513  ADDI_PARAM_DONE
00001D94                          1514          
00001D94                          1515          * -------------------
00001D94                          1516          * print the size
00001D94                          1517          * -------------------
00001D94                          1518  
00001D94  16FC 002E               1519          MOVE.B    #'.',(A3)+
00001D98  B83C 0000               1520          CMP.B     #0,D4
00001D9C  6700 0016               1521          BEQ       ADDI_PRINT_SIZE_BYTE
00001DA0  B83C 0001               1522          CMP.B     #1,D4
00001DA4  6700 0016               1523          BEQ       ADDI_PRINT_SIZE_WORD
00001DA8  B83C 0002               1524          CMP.B     #2,D4
00001DAC  6700 0016               1525          BEQ       ADDI_PRINT_SIZE_LONG
00001DB0                          1526  
00001DB0  6000 001A               1527          BRA       ADDI_PRINT_SIZE_DONE
00001DB4                          1528  
00001DB4                          1529  ADDI_PRINT_SIZE_BYTE
00001DB4  16FC 0042               1530          MOVE.B    #'B',(A3)+
00001DB8  6000 0012               1531          BRA       ADDI_PRINT_SIZE_DONE
00001DBC                          1532  ADDI_PRINT_SIZE_WORD
00001DBC  16FC 0057               1533          MOVE.B    #'W',(A3)+
00001DC0  6000 000A               1534          BRA       ADDI_PRINT_SIZE_DONE
00001DC4                          1535  ADDI_PRINT_SIZE_LONG
00001DC4  16FC 004C               1536          MOVE.B    #'L',(A3)+
00001DC8  6000 0002               1537          BRA       ADDI_PRINT_SIZE_DONE
00001DCC                          1538  
00001DCC                          1539  ADDI_PRINT_SIZE_DONE
00001DCC  16FC 0009               1540          MOVE.B    #9,(A3)+
00001DD0  16FC 0023               1541          MOVE.B    #'#',(A3)+
00001DD4  16FC 0024               1542          MOVE.B    #'$',(A3)+
00001DD8                          1543  
00001DD8                          1544          * --------------------
00001DD8                          1545          * print address number
00001DD8                          1546          * --------------------
00001DD8  B83C 0002               1547          CMP.B     #2,D4       ; if we're using long addressing, get next long
00001DDC  6700 000C               1548          BEQ       ADDI_PRINT_AL
00001DE0  4EB9 00001E30           1549          JSR       ADDI_PRINT_ADDR_WORD
00001DE6  6000 0008               1550          BRA       ADDI_PRINT_ADDR_DONE
00001DEA                          1551  
00001DEA                          1552  ADDI_PRINT_AL
00001DEA  4EB9 00001E48           1553          JSR       ADDI_PRINT_ADDR_LONG
00001DF0                          1554  
00001DF0                          1555  ADDI_PRINT_ADDR_DONE
00001DF0                          1556  
00001DF0  16FC 002C               1557          MOVE.B    #',',(A3)+
00001DF4                          1558  
00001DF4                          1559          * JSR       ADDI_EA_TO_DN
00001DF4  4EB8 17A2               1560          JSR       PRINT_SOURCE_SUB    ; the "source" is actually the source here
00001DF8                          1561  
00001DF8                          1562  ADDI_END
00001DF8                          1563  
00001DF8  16FC 000A               1564          MOVE.B    #$0A,(A3)+
00001DFC  16FC 000D               1565          MOVE.B    #$0D,(A3)+
00001E00                          1566  
00001E00  23C9 00007750           1567          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
00001E06  23CB 0000775C           1568          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
00001E0C                          1569  
00001E0C  4CDF 7FFF               1570          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
00001E10  4E75                    1571          RTS       ; return
00001E12                          1572  
00001E12                          1573  ADDI_EA_TO_DN
00001E12                          1574  
00001E12  4EB8 17A2               1575          JSR       PRINT_SOURCE_SUB    ; the "source" is actually the source here
00001E16  16FC 002C               1576          MOVE.B    #',',(A3)+
00001E1A  16FC 0044               1577          MOVE.B    #'D',(A3)+
00001E1E  3401                    1578          MOVE.W    D1,D2
00001E20  E04A                    1579          LSR.W     #8,D2
00001E22  E24A                    1580          LSR.W     #1,D2
00001E24  0242 0007               1581          ANDI.W    #7,D2
00001E28  0642 0030               1582          ADDI.W    #$30,D2
00001E2C  16C2                    1583          MOVE.B    D2,(A3)+
00001E2E                          1584  
00001E2E  4E75                    1585          RTS
00001E30                          1586  
00001E30                          1587  ADDI_PRINT_ADDR_WORD
00001E30  48E7 4000               1588          MOVEM.L   D1,-(SP) ; move the old registers onto the stack
00001E34                          1589  
00001E34  4281                    1590          CLR.L     D1
00001E36  3219                    1591          MOVE.W    (A1)+,D1      ; move the next word into D1
00001E38  23CB 0000775C           1592          MOVE.L    A3,OUT_CURR_A ; update the output pos before we print
00001E3E  4EB8 1A5C               1593          JSR       PRINT_NUM     ; print the number in D1
00001E42                          1594  
00001E42  4CDF 0002               1595          MOVEM.L   (SP)+,D1 ; move the old registers back to the stack
00001E46  4E75                    1596          RTS
00001E48                          1597  ADDI_PRINT_ADDR_LONG
00001E48  48E7 4000               1598          MOVEM.L   D1,-(SP) ; move the old registers onto the stack
00001E4C                          1599  
00001E4C  4281                    1600          CLR.L     D1
00001E4E  2219                    1601          MOVE.L    (A1)+,D1      ; move the next word into D1
00001E50  23CB 0000775C           1602          MOVE.L    A3,OUT_CURR_A ; update the output pos before we print
00001E56  4EB8 1A5C               1603          JSR       PRINT_NUM     ; print the number in D1
00001E5A                          1604  
00001E5A  4CDF 0002               1605          MOVEM.L   (SP)+,D1 ; move the old registers back to the stack
00001E5E  4E75                    1606          RTS
00001E5E  4E75                    1607  -------------------- end include --------------------
00001E60                          1608          INCLUDE 'MOVEA_SUB.X68'
00001E60                          1609  
00001E60                          1610  MOVEA_SUB
00001E60  48E7 FFFE               1611          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00001E64                          1612  
00001E64                          1613          * sets up the data registers
00001E64                          1614          *
00001E64                          1615          * A1 - the current opcode's address
00001E64                          1616          * A3 - the current position of the output
00001E64                          1617          * A4 - the location of the text for printing
00001E64                          1618          *
00001E64                          1619          * D1 - the actual opcode
00001E64                          1620          *
00001E64  227C 00000000           1621          MOVEA.L   #0,A1             ; load the current opcode into a register
00001E6A  2279 00007750           1622          MOVEA.L   IN_CURR_A,A1
00001E70  3219                    1623          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00001E72                          1624  
00001E72  267C 00000000           1625          MOVEA.L   #0,A3
00001E78  2679 0000775C           1626          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00001E7E  49F9 00007777           1627          LEA       MOVEA_STR,A4     ; move the to-be-printed string to A4
00001E84                          1628  
00001E84                          1629          * we need to append the string at MOVEA_STR to the output string
00001E84                          1630          * we do this char by char (byte by byte) until we see a NULL (0)
00001E84                          1631          * in MOVEA_STR
00001E84                          1632  
00001E84                          1633  MOVEA_COPY
00001E84  4A14                    1634          TST.B     (A4)      ; test the contents of A4
00001E86  6700 0006               1635          BEQ       MOVEA_DONE  ; if we hit a 00, we're done copying
00001E8A                          1636  
00001E8A  16DC                    1637          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00001E8C  60F6                    1638          BRA       MOVEA_COPY      ; do it again
00001E8E                          1639          
00001E8E                          1640  MOVEA_DONE
00001E8E                          1641  
00001E8E  4EB8 16E0               1642          JSR       PRINT_SIZE_EARLY_SUB
00001E92  4EB8 17A2               1643          JSR       PRINT_SOURCE_SUB
00001E96  16FC 002C               1644          MOVE.B    #',',(A3)+
00001E9A  4EB8 18FC               1645          JSR       PRINT_DEST_SUB
00001E9E  16FC 000A               1646          MOVE.B    #$0A,(A3)+
00001EA2  16FC 000D               1647          MOVE.B    #$0D,(A3)+
00001EA6                          1648  
00001EA6  23C9 00007750           1649          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
00001EAC  23CB 0000775C           1650          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
00001EB2                          1651  
00001EB2  4CDF 7FFF               1652          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
00001EB6  4E75                    1653          RTS       ; return
00001EB8                          1654  
00001EB8                          1655  
00001EB8                          1656  -------------------- end include --------------------
00001EB8                          1657          INCLUDE 'MOVE_SUB.X68'
00001EB8                          1658  
00001EB8                          1659  MOVE_SUB
00001EB8  48E7 FFFE               1660          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00001EBC                          1661  
00001EBC                          1662          * sets up the data registers
00001EBC                          1663          *
00001EBC                          1664          * A1 - the current opcode's address
00001EBC                          1665          * A3 - the current position of the output
00001EBC                          1666          * A4 - the location of the text for printing
00001EBC                          1667          *
00001EBC                          1668          * D1 - the actual opcode
00001EBC                          1669          *
00001EBC  227C 00000000           1670          MOVEA.L   #0,A1             ; load the current opcode into a register
00001EC2  2279 00007750           1671          MOVEA.L   IN_CURR_A,A1
00001EC8  3219                    1672          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00001ECA                          1673  
00001ECA  267C 00000000           1674          MOVEA.L   #0,A3
00001ED0  2679 0000775C           1675          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00001ED6  49F9 0000777D           1676          LEA       MOVE_STR,A4     ; move the to-be-printed string to A4
00001EDC                          1677  
00001EDC                          1678          * we need to append the string at MOVE_STR to the output string
00001EDC                          1679          * we do this char by char (byte by byte) until we see a NULL (0)
00001EDC                          1680          * in MOVE_STR
00001EDC                          1681  
00001EDC                          1682  MOVE_COPY
00001EDC  4A14                    1683          TST.B     (A4)      ; test the contents of A4
00001EDE  6700 0006               1684          BEQ       MOVE_DONE  ; if we hit a 00, we're done copying
00001EE2                          1685  
00001EE2  16DC                    1686          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00001EE4  60F6                    1687          BRA       MOVE_COPY      ; do it again
00001EE6                          1688          
00001EE6                          1689  MOVE_DONE
00001EE6                          1690  
00001EE6  4EB8 16E0               1691          JSR       PRINT_SIZE_EARLY_SUB
00001EEA  4EB8 17A2               1692          JSR       PRINT_SOURCE_SUB
00001EEE  16FC 002C               1693          MOVE.B    #',',(A3)+
00001EF2  4EB8 18FC               1694          JSR       PRINT_DEST_SUB
00001EF6  16FC 000A               1695          MOVE.B    #$0A,(A3)+
00001EFA  16FC 000D               1696          MOVE.B    #$0D,(A3)+
00001EFE                          1697  
00001EFE  23C9 00007750           1698          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
00001F04  23CB 0000775C           1699          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
00001F0A                          1700  
00001F0A  4CDF 7FFF               1701          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
00001F0E  4E75                    1702          RTS       ; return
00001F10                          1703  
00001F10                          1704  
00001F10                          1705  -------------------- end include --------------------
00001F10                          1706          INCLUDE 'NOP_SUB.X68'
00001F10                          1707  
00001F10                          1708  NOP_SUB
00001F10  48E7 FFFE               1709          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00001F14                          1710  
00001F14  227C 00000000           1711          MOVEA.L   #0,A1             ; load the current opcode into a register
00001F1A  2279 00007750           1712          MOVEA.L   IN_CURR_A,A1
00001F20  3219                    1713          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00001F22                          1714  
00001F22  267C 00000000           1715          MOVEA.L   #0,A3
00001F28  2679 0000775C           1716          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00001F2E  49F9 00007771           1717          LEA       NOP_STR,A4     ; move the to-be-printed string to A4
00001F34                          1718  
00001F34                          1719          * we need to append the string at NOP_STR to the output string
00001F34                          1720          * we do this char by char (byte by byte) until we see a NULL (0)
00001F34                          1721          * in NOP_STR
00001F34                          1722  
00001F34                          1723  NOP_COPY
00001F34  4A14                    1724          TST.B     (A4)      ; test the contents of A4
00001F36  6700 0006               1725          BEQ       NOP_DONE  ; if we hit a 00, we're done copying
00001F3A                          1726  
00001F3A  16DC                    1727          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00001F3C  60F6                    1728          BRA       NOP_COPY      ; do it again
00001F3E                          1729          
00001F3E                          1730  NOP_DONE
00001F3E                          1731  
00001F3E  23C9 00007750           1732          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
00001F44  23CB 0000775C           1733          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
00001F4A                          1734  
00001F4A  4CDF 7FFF               1735          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
00001F4E  4E75                    1736          RTS       ; return
00001F50                          1737  
00001F50                          1738  
00001F50                          1739  -------------------- end include --------------------
00001F50                          1740          INCLUDE 'RTS_SUB.X68'
00001F50                          1741  RTS_SUB
00001F50  48E7 FFFE               1742          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00001F54                          1743  
00001F54                          1744          * sets up the data registers
00001F54                          1745          *
00001F54                          1746          * A1 - the current opcode's address
00001F54                          1747          * A3 - the current position of the output
00001F54                          1748          * A4 - the location of the text for printing
00001F54                          1749          *
00001F54                          1750          * D1 - the actual opcode
00001F54                          1751          *
00001F54  227C 00000000           1752          MOVEA.L   #0,A1             ; load the current opcode into a register
00001F5A  2279 00007750           1753          MOVEA.L   IN_CURR_A,A1
00001F60  3219                    1754          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00001F62                          1755  
00001F62  267C 00000000           1756          MOVEA.L   #0,A3
00001F68  2679 0000775C           1757          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00001F6E  49F9 00007782           1758          LEA       RTS_STR,A4     ; move the to-be-printed string to A4
00001F74                          1759  
00001F74                          1760          * we need to append the string at ###_STR to the output string
00001F74                          1761          * we do this char by char (byte by byte) until we see a NULL (0)
00001F74                          1762          * in ###_STR
00001F74                          1763  
00001F74                          1764  RTS_COPY
00001F74  4A14                    1765          TST.B     (A4)      ; test the contents of A4
00001F76  6700 0006               1766          BEQ       RTS_DONE  ; if we hit a 00, we're done copying
00001F7A                          1767  
00001F7A  16DC                    1768          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00001F7C  60F6                    1769          BRA       RTS_COPY      ; do it again
00001F7E                          1770          
00001F7E                          1771  RTS_DONE
00001F7E                          1772  
00001F7E                          1773          * ----------------------------------------------------
00001F7E                          1774          * ----------------------------------------------------
00001F7E                          1775          *
00001F7E                          1776          * At this point the name is printed and nothing else
00001F7E                          1777          *
00001F7E                          1778          * most if not all of your code is going to go here
00001F7E                          1779          *
00001F7E                          1780          * ----------------------------------------------------
00001F7E                          1781          * ----------------------------------------------------
00001F7E                          1782  
00001F7E  16FC 000A               1783          MOVE.B    #$0A,(A3)+
00001F82  16FC 000D               1784          MOVE.B    #$0D,(A3)+
00001F86                          1785  
00001F86  23C9 00007750           1786          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
00001F8C  23CB 0000775C           1787          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
00001F92                          1788  
00001F92  4CDF 7FFF               1789          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
00001F96  4E75                    1790          RTS       ; return
00001F98                          1791  
00001F98                          1792  
00001F98                          1793  
00001F98                          1794  -------------------- end include --------------------
00001F98                          1795          INCLUDE 'JSR_SUB.X68'
00001F98                          1796  JSR_SUB
00001F98  48E7 FFFE               1797          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00001F9C                          1798  
00001F9C                          1799          * sets up the data registers
00001F9C                          1800          *
00001F9C                          1801          * A1 - the current opcode's address
00001F9C                          1802          * A3 - the current position of the output
00001F9C                          1803          * A4 - the location of the text for printing
00001F9C                          1804          *
00001F9C                          1805          * D1 - the actual opcode
00001F9C                          1806          *
00001F9C  227C 00000000           1807          MOVEA.L   #0,A1             ; load the current opcode into a register
00001FA2  2279 00007750           1808          MOVEA.L   IN_CURR_A,A1
00001FA8  3219                    1809          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00001FAA                          1810  
00001FAA  267C 00000000           1811          MOVEA.L   #0,A3
00001FB0  2679 0000775C           1812          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00001FB6  49F9 00007786           1813          LEA       JSR_STR,A4     ; move the to-be-printed string to A4
00001FBC                          1814  
00001FBC                          1815          * we need to append the string at ###_STR to the output string
00001FBC                          1816          * we do this char by char (byte by byte) until we see a NULL (0)
00001FBC                          1817          * in ###_STR
00001FBC                          1818  
00001FBC                          1819  JSR_COPY
00001FBC  4A14                    1820          TST.B     (A4)      ; test the contents of A4
00001FBE  6700 0006               1821          BEQ       JSR_DONE  ; if we hit a 00, we're done copying
00001FC2                          1822  
00001FC2  16DC                    1823          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00001FC4  60F6                    1824          BRA       JSR_COPY      ; do it again
00001FC6                          1825          
00001FC6                          1826  JSR_DONE
00001FC6                          1827  
00001FC6  16FC 0009               1828          MOVE.B    #9,(A3)+
00001FCA  16FC 0024               1829          MOVE.B    #'$',(A3)+
00001FCE                          1830  
00001FCE  2801                    1831          MOVE.L D1,D4
00001FD0  7600                    1832          MOVE.L  #0,D3
00001FD2                          1833          
00001FD2  C87C 0001               1834          AND #1,D4
00001FD6  B87C 0000               1835          CMP #0,D4
00001FDA  6700 0014               1836          BEQ JSR_ABSW
00001FDE                          1837          
00001FDE  4EB9 00002002           1838  JSR_ABSL        JSR JSR_GETBYTE
00001FE4  5203                    1839                    ADDQ.B    #1,D3
00001FE6  B63C 0004               1840                    CMP.B     #4,D3
00001FEA  66F2                    1841                    BNE   JSR_ABSL
00001FEC  6000 004A               1842                    BRA JSR_FINISH
00001FF0                          1843  
00001FF0  4EB9 00002002           1844  JSR_ABSW    JSR JSR_GETBYTE
00001FF6  5203                    1845                    ADDQ.B    #1,D3
00001FF8  B63C 0002               1846                    CMP.B     #2,D3
00001FFC  66F2                    1847                    BNE   JSR_ABSW
00001FFE  6000 0038               1848                    BRA JSR_FINISH  
00002002                          1849                                  
00002002                          1850  JSR_GETBYTE
00002002  1A19                    1851      MOVE.B  (A1)+,D5
00002004  1C05                    1852      MOVE.B  D5,D6
00002006  CC3C 00F0               1853      AND.B   #$F0,D6
0000200A  E80E                    1854      LSR.B   #4,D6
0000200C  4EB9 00002024           1855      JSR JSR_CONVERT
00002012  16C6                    1856      MOVE.B  D6,(A3)+
00002014  1C05                    1857      MOVE.B  D5,D6
00002016  CC3C 000F               1858      AND.B   #$F,D6
0000201A  4EB9 00002024           1859      JSR JSR_CONVERT
00002020  16C6                    1860      MOVE.B  D6,(A3)+
00002022  4E75                    1861      RTS
00002024                          1862  JSR_CONVERT
00002024  BC3C 000A               1863      CMP.B   #10,D6
00002028  6D00 0008               1864      BLT JSR_DIGIT
0000202C  0606 0037               1865      ADD.B   #$37,D6
00002030  4E75                    1866      RTS
00002032                          1867  JSR_DIGIT
00002032  0606 0030               1868      ADD.B #$30,D6
00002036  4E75                    1869      RTS         
00002038                          1870  
00002038                          1871  JSR_FINISH
00002038  16FC 000A               1872          MOVE.B  #$A,(A3)+
0000203C  16FC 000D               1873          MOVE.B  #$D,(A3)+
00002040                          1874          
00002040  23C9 00007750           1875          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
00002046  23CB 0000775C           1876          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
0000204C                          1877  
0000204C  4CDF 7FFF               1878          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
00002050  4E75                    1879          RTS       ; return
00002052                          1880  
00002052                          1881  
00002052                          1882  
00002052                          1883  
00002052                          1884  -------------------- end include --------------------
00002052                          1885          INCLUDE 'MOVEM_SUB.X68'
00002052                          1886  
00002052                          1887  MOVEM_SUB
00002052  48E7 FFFE               1888          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00002056                          1889  
00002056                          1890          * sets up the data registers
00002056                          1891          *
00002056                          1892          * A1 - the current opcode's address
00002056                          1893          * A3 - the current position of the output
00002056                          1894          * A4 - the location of the text for printing
00002056                          1895          *
00002056                          1896          * D1 - the actual opcode
00002056                          1897          *
00002056  227C 00000000           1898          MOVEA.L   #0,A1             ; load the current opcode into a register
0000205C  2279 00007750           1899          MOVEA.L   IN_CURR_A,A1
00002062  3219                    1900          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00002064                          1901  
00002064  267C 00000000           1902          MOVEA.L   #0,A3
0000206A  2679 0000775C           1903          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00002070  49F9 0000778A           1904          LEA       MOVEM_STR,A4     ; move the to-be-printed string to A4
00002076                          1905  
00002076                          1906          * we need to append the string at MOVEM_STR to the output string
00002076                          1907          * we do this char by char (byte by byte) until we see a NULL (0)
00002076                          1908          * in MOVEM_STR
00002076                          1909  
00002076                          1910  MOVEM_COPY
00002076  4A14                    1911          TST.B     (A4)      ; test the contents of A4
00002078  6700 0006               1912          BEQ       MOVEM_DONE  ; if we hit a 00, we're done copying
0000207C                          1913  
0000207C  16DC                    1914          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
0000207E  60F6                    1915          BRA       MOVEM_COPY      ; do it again
00002080                          1916          
00002080                          1917  MOVEM_DONE
00002080                          1918  
00002080                          1919          * print the size (determined by this bit 0000 0000 0100 0000)
00002080                          1920          *                ( 0 = word, 1 = long)
00002080  16FC 002E               1921          MOVE.B    #'.',(A3)+
00002084  1401                    1922          MOVE.B    D1,D2
00002086  0202 0040               1923          ANDI.B    #$40,D2
0000208A  EC0A                    1924          LSR.B     #6,D2
0000208C  4A02                    1925          TST.B     D2
0000208E  6700 000A               1926          BEQ       MOVEM_SIZE_W
00002092  16FC 004C               1927          MOVE.B    #'L',(A3)+
00002096  6000 0006               1928          BRA       MOVEM_DIRECTION
0000209A                          1929  
0000209A                          1930  MOVEM_SIZE_W
0000209A  16FC 0057               1931          MOVE.B    #'W',(A3)+
0000209E                          1932  
0000209E                          1933  MOVEM_DIRECTION
0000209E  16FC 0009               1934          MOVE.B    #9,(A3)+
000020A2                          1935  
000020A2  3401                    1936          MOVE.W    D1,D2
000020A4  0242 0400               1937          ANDI.W    #$400,D2
000020A8  E04A                    1938          LSR.W     #8,D2
000020AA  E44A                    1939          LSR.W     #2,D2
000020AC  4A02                    1940          TST.B     D2
000020AE  6700 000C               1941          BEQ       MOVEM_RTM
000020B2  4EB9 00002146           1942          JSR       MOVEM_MEM_TO_REG
000020B8  6000 0008               1943          BRA       MOVEM_END
000020BC                          1944          
000020BC                          1945  MOVEM_RTM
000020BC  4EB9 000020DC           1946          JSR       MOVEM_REG_TO_MEM
000020C2                          1947  
000020C2                          1948  MOVEM_END
000020C2                          1949          * -----------------
000020C2                          1950          * print the newline
000020C2                          1951          * -----------------
000020C2  16FC 000A               1952          MOVE.B    #$0A,(A3)+
000020C6  16FC 000D               1953          MOVE.B    #$0D,(A3)+
000020CA                          1954  
000020CA  23C9 00007750           1955          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
000020D0  23CB 0000775C           1956          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
000020D6                          1957  
000020D6  4CDF 7FFF               1958          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
000020DA  4E75                    1959          RTS       ; return
000020DC                          1960  
000020DC                          1961  
000020DC                          1962  MOVEM_REG_TO_MEM
000020DC  3819                    1963          MOVE.W    (A1)+,D4      ; D4 is the next word (which registers to move)
000020DE  1A3C 0008               1964          MOVE.B    #8,D5         ; D5 is our counter (it starts at 8)
000020E2                          1965  
000020E2                          1966  MOVEM_REG_TO_MEM_D_LOOP
000020E2  5305                    1967          SUBI.B    #1,D5         ; pre-decrement our counter
000020E4                          1968  
000020E4  3C04                    1969          MOVE.W    D4,D6         ; isolate the current bit
000020E6  E04E                    1970          LSR.W     #8,D6
000020E8  EA6E                    1971          LSR.W     D5,D6
000020EA  0206 0001               1972          ANDI.B    #1,D6
000020EE  4A06                    1973          TST.B     D6            ; if it's 0, that register's not present
000020F0                          1974                                  ; so skip
000020F0  6700 0012               1975          BEQ       MOVEM_REG_TO_MEM_D_SKIP
000020F4                          1976  
000020F4  16FC 0044               1977          MOVE.B    #'D',(A3)+    ; print a D
000020F8  1E3C 0037               1978          MOVE.B    #'7',D7       ; start with ASCII 7
000020FC  9E05                    1979          SUB.B     D5,D7         ; subtract to get the real ASCII char
000020FE  16C7                    1980          MOVE.B    D7,(A3)+      ; print it
00002100  16FC 002F               1981          MOVE.B    #'/',(A3)+
00002104                          1982  
00002104                          1983  MOVEM_REG_TO_MEM_D_SKIP
00002104  4A05                    1984          TST.B     D5
00002106  6700 0004               1985          BEQ       MOVEM_REG_TO_MEM_D_DONE
0000210A  60D6                    1986          BRA       MOVEM_REG_TO_MEM_D_LOOP
0000210C                          1987  
0000210C                          1988  MOVEM_REG_TO_MEM_D_DONE
0000210C                          1989  
0000210C  1A3C 0008               1990          MOVE.B    #8,D5         ; D5 is our counter (it starts at 8)
00002110                          1991  
00002110                          1992  MOVEM_REG_TO_MEM_A_LOOP
00002110  5305                    1993          SUBI.B    #1,D5         ; pre-decrement our counter
00002112                          1994  
00002112  3C04                    1995          MOVE.W    D4,D6         ; isolate the current bit
00002114  EA6E                    1996          LSR.W     D5,D6
00002116  0206 0001               1997          ANDI.B    #1,D6
0000211A  4A06                    1998          TST.B     D6            ; if it's 0, that register's not present
0000211C                          1999                                  ; so skip
0000211C  6700 0012               2000          BEQ       MOVEM_REG_TO_MEM_A_SKIP
00002120                          2001  
00002120  16FC 0041               2002          MOVE.B    #'A',(A3)+    ; print a A
00002124  1E3C 0037               2003          MOVE.B    #'7',D7       ; start with ASCII 7
00002128  9E05                    2004          SUB.B     D5,D7         ; subtract to get the real ASCII char
0000212A  16C7                    2005          MOVE.B    D7,(A3)+      ; print it
0000212C  16FC 002F               2006          MOVE.B    #'/',(A3)+
00002130                          2007  
00002130                          2008  MOVEM_REG_TO_MEM_A_SKIP
00002130  4A05                    2009          TST.B     D5
00002132  6700 0004               2010          BEQ       MOVEM_REG_TO_MEM_A_DONE
00002136  60D8                    2011          BRA       MOVEM_REG_TO_MEM_A_LOOP
00002138                          2012  
00002138                          2013  MOVEM_REG_TO_MEM_A_DONE
00002138                          2014  
00002138                          2015          * we just printed the list of D0-D7/A0-A7, now we print the register
00002138  173C 002C               2016          MOVE.B    #',',-(A3)    ; overwrite the last /
0000213C  16FC 002C               2017          MOVE.B    #',',(A3)+
00002140                          2018  
00002140  4EB8 17A2               2019          JSR   PRINT_SOURCE_SUB ; it's not technically the source, but it's in
00002144                          2020                                 ; it's place, so just roll with it
00002144  4E75                    2021          RTS
00002146                          2022  
00002146                          2023  
00002146                          2024  
00002146                          2025  MOVEM_MEM_TO_REG
00002146  4EB8 17A2               2026          JSR   PRINT_SOURCE_SUB ; it's not technically the source, but it's in
0000214A                          2027                                 ; it's place, so just roll with it
0000214A  16FC 002C               2028          MOVE.B    #',',(A3)+
0000214E                          2029  
0000214E  3819                    2030          MOVE.W    (A1)+,D4      ; D4 is the next word (which registers to move)
00002150  1A3C 0008               2031          MOVE.B    #8,D5         ; D5 is our counter (it starts at 8)
00002154                          2032  
00002154                          2033  MOVEM_MEM_TO_REG_A_LOOP
00002154  5305                    2034          SUBI.B    #1,D5         ; pre-decrement our counter
00002156                          2035  
00002156  3C04                    2036          MOVE.W    D4,D6         ; isolate the current bit
00002158  E04E                    2037          LSR.W     #8,D6
0000215A  EA6E                    2038          LSR.W     D5,D6
0000215C  0206 0001               2039          ANDI.B    #1,D6
00002160  4A06                    2040          TST.B     D6            ; if it's 0, that register's not present
00002162                          2041                                  ; so skip
00002162  6700 0012               2042          BEQ       MOVEM_MEM_TO_REG_A_SKIP
00002166                          2043  
00002166  16FC 0041               2044          MOVE.B    #'A',(A3)+    ; print a A
0000216A  1E3C 0030               2045          MOVE.B    #'0',D7       ; start with ASCII 7
0000216E  DE05                    2046          ADD.B     D5,D7         ; subtract to get the real ASCII char
00002170  16C7                    2047          MOVE.B    D7,(A3)+      ; print it
00002172  16FC 002F               2048          MOVE.B    #'/',(A3)+
00002176                          2049  
00002176                          2050  MOVEM_MEM_TO_REG_A_SKIP
00002176  4A05                    2051          TST.B     D5
00002178  6700 0004               2052          BEQ       MOVEM_MEM_TO_REG_A_DONE
0000217C  60D6                    2053          BRA       MOVEM_MEM_TO_REG_A_LOOP
0000217E                          2054  
0000217E                          2055  MOVEM_MEM_TO_REG_A_DONE
0000217E                          2056  
0000217E  1A3C 0008               2057          MOVE.B    #8,D5         ; D5 is our counter (it starts at 8)
00002182                          2058  
00002182                          2059  MOVEM_MEM_TO_REG_D_LOOP
00002182  5305                    2060          SUBI.B    #1,D5         ; pre-decrement our counter
00002184                          2061  
00002184  3C04                    2062          MOVE.W    D4,D6         ; isolate the current bit
00002186  EA6E                    2063          LSR.W     D5,D6
00002188  0206 0001               2064          ANDI.B    #1,D6
0000218C  4A06                    2065          TST.B     D6            ; if it's 0, that register's not present
0000218E                          2066                                  ; so skip
0000218E  6700 0012               2067          BEQ       MOVEM_MEM_TO_REG_D_SKIP
00002192                          2068  
00002192  16FC 0044               2069          MOVE.B    #'D',(A3)+    ; print a D
00002196  1E3C 0030               2070          MOVE.B    #'0',D7       ; start with ASCII 7
0000219A  DE05                    2071          ADD.B     D5,D7         ; subtract to get the real ASCII char
0000219C  16C7                    2072          MOVE.B    D7,(A3)+      ; print it
0000219E  16FC 002F               2073          MOVE.B    #'/',(A3)+
000021A2                          2074  
000021A2                          2075  MOVEM_MEM_TO_REG_D_SKIP
000021A2  4A05                    2076          TST.B     D5
000021A4  6700 0004               2077          BEQ       MOVEM_MEM_TO_REG_D_DONE
000021A8  60D8                    2078          BRA       MOVEM_MEM_TO_REG_D_LOOP
000021AA                          2079  
000021AA                          2080  MOVEM_MEM_TO_REG_D_DONE
000021AA                          2081  
000021AA                          2082  
000021AA                          2083          * we just printed the list of D0-D7/A0-A7, now we print the register
000021AA  173C 00FF               2084          MOVE.B    #$FF,-(A3)    ; backspace the last /
000021AE                          2085  
000021AE  4E75                    2086          RTS
000021B0                          2087  
000021B0                          2088  -------------------- end include --------------------
000021B0                          2089          INCLUDE 'LEA_SUB.X68'
000021B0                          2090  LEA_SUB
000021B0  48E7 FFFE               2091          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
000021B4                          2092  
000021B4                          2093          * sets up the data registers
000021B4                          2094          *
000021B4                          2095          * A1 - the current opcode's address
000021B4                          2096          * A3 - the current position of the output
000021B4                          2097          * A4 - the location of the text for printing
000021B4                          2098          *
000021B4                          2099          * D1 - the actual opcode
000021B4                          2100          *
000021B4  227C 00000000           2101          MOVEA.L   #0,A1             ; load the current opcode into a register
000021BA  2279 00007750           2102          MOVEA.L   IN_CURR_A,A1
000021C0  3219                    2103          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
000021C2                          2104  
000021C2  267C 00000000           2105          MOVEA.L   #0,A3
000021C8  2679 0000775C           2106          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
000021CE  49F9 00007790           2107          LEA       LEA_STR,A4     ; move the to-be-printed string to A4
000021D4                          2108  
000021D4                          2109          * we need to append the string at ###_STR to the output string
000021D4                          2110          * we do this char by char (byte by byte) until we see a NULL (0)
000021D4                          2111          * in ###_STR
000021D4                          2112  
000021D4                          2113  LEA_COPY
000021D4  4A14                    2114          TST.B     (A4)      ; test the contents of A4
000021D6  6700 0006               2115          BEQ       LEA_DONE  ; if we hit a 00, we're done copying
000021DA                          2116  
000021DA  16DC                    2117          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
000021DC  60F6                    2118          BRA       LEA_COPY      ; do it again
000021DE                          2119          
000021DE                          2120  LEA_DONE 
000021DE  16FC 0009               2121           MOVE.B #$09,(A3)+
000021E2  4EB8 17A2               2122           JSR      PRINT_SOURCE_SUB
000021E6  16FC 002C               2123           MOVE.B   #$2C,(A3)+        ; print comma 
000021EA  16FC 0041               2124           MOVE.B #'A',(A3)+
000021EE  4283                    2125           CLR.L    D3                ; clear d3 for later use 
000021F0  3601                    2126           MOVE.W   D1,D3           ;copy An to D3
000021F2  0243 0E00               2127           ANDI.W   #$0E00,D3        ; mask off the non address reg bits
000021F6  E08B                    2128           LSR.L    #$08,D3           ; shift 8 bits left 
000021F8  E28B                    2129           LSR.L    #$01,D3           ; shift additional 1 bit  
000021FA  0603 0030               2130           ADDI.B   #$30,D3             ; convert to ASCII
000021FE  16C3                    2131           MOVE.B   D3,(A3)+          ; print the n in An
00002200  16FC 000A               2132           MOVE.B    #$0A,(A3)+
00002204  16FC 000D               2133           MOVE.B    #$0D,(A3)+
00002208                          2134  
00002208                          2135           *JSR      PRINT_DEST_SUB
00002208                          2136           
00002208                          2137  
00002208                          2138          * ----------------------------------------------------
00002208                          2139          * ----------------------------------------------------
00002208                          2140          *
00002208                          2141          * At this point the name is printed and nothing else
00002208                          2142          *
00002208                          2143          * most if not all of your code is going to go here
00002208                          2144          
00002208                          2145          *
00002208                          2146          * ----------------------------------------------------
00002208                          2147          * ----------------------------------------------------
00002208                          2148  
00002208  23C9 00007750           2149          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
0000220E  23CB 0000775C           2150          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
00002214                          2151  
00002214  4CDF 7FFF               2152          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
00002218  4E75                    2153          RTS       ; return
0000221A                          2154  
0000221A                          2155  
0000221A                          2156  
0000221A                          2157  
0000221A                          2158  -------------------- end include --------------------
0000221A                          2159          INCLUDE 'ADDQ_SUB.X68'
0000221A                          2160  
0000221A                          2161  ADDQ_SUB
0000221A  48E7 FFFE               2162          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
0000221E                          2163  
0000221E                          2164          * sets up the data registers
0000221E                          2165          *
0000221E                          2166          * A1 - the current opcode's address
0000221E                          2167          * A3 - the current position of the output
0000221E                          2168          * A4 - the location of the text for printing
0000221E                          2169          *
0000221E                          2170          * D1 - the actual opcode
0000221E                          2171          *
0000221E  227C 00000000           2172          MOVEA.L   #0,A1             ; load the current opcode into a register
00002224  2279 00007750           2173          MOVEA.L   IN_CURR_A,A1
0000222A  3219                    2174          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
0000222C                          2175  
0000222C  267C 00000000           2176          MOVEA.L   #0,A3
00002232  2679 0000775C           2177          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00002238  49F9 000077AE           2178          LEA       ADDQ_STR,A4     ; move the to-be-printed string to A4
0000223E                          2179  
0000223E                          2180          * we need to append the string at ADDQ_STR to the output string
0000223E                          2181          * we do this char by char (byte by byte) until we see a NULL (0)
0000223E                          2182          * in ADDQ_STR
0000223E                          2183  
0000223E                          2184  ADDQ_COPY
0000223E  4A14                    2185          TST.B     (A4)      ; test the contents of A4
00002240  6700 0006               2186          BEQ       ADDQ_DONE  ; if we hit a 00, we're done copying
00002244                          2187  
00002244  16DC                    2188          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00002246  60F6                    2189          BRA       ADDQ_COPY      ; do it again
00002248                          2190          
00002248                          2191  ADDQ_DONE
00002248                          2192    
00002248                          2193          * D4 = size       ( 0 = B, 1 = W, 2 = L)
00002248                          2194          * D5 = direction  ( 0 = Dn first, 1 = <ea> first)
00002248                          2195  
00002248  3401                    2196          MOVE.W    D1,D2
0000224A  EC4A                    2197          LSR.W     #6,D2
0000224C  0242 0007               2198          ANDI.W    #7,D2
00002250                          2199  
00002250  B47C 0000               2200          CMP.W     #0,D2
00002254  6700 002E               2201          BEQ       ADDQ_BYTE_DN
00002258  B47C 0001               2202          CMP.W     #1,D2
0000225C  6700 0032               2203          BEQ       ADDQ_WORD_DN
00002260  B47C 0002               2204          CMP.W     #2,D2
00002264  6700 0036               2205          BEQ       ADDQ_LONG_DN
00002268                          2206  
00002268  B47C 0004               2207          CMP.W     #4,D2
0000226C  6700 003A               2208          BEQ       ADDQ_BYTE_EA
00002270  B47C 0005               2209          CMP.W     #5,D2
00002274  6700 003E               2210          BEQ       ADDQ_WORD_EA
00002278  B47C 0006               2211          CMP.W     #6,D2
0000227C  6700 0042               2212          BEQ       ADDQ_LONG_EA
00002280                          2213          
00002280                          2214          * if nothing is found just jump to the end
00002280  6000 004A               2215          BRA       ADDQ_PARAM_DONE
00002284                          2216  
00002284                          2217  ADDQ_BYTE_DN
00002284  183C 0000               2218          MOVE.B    #0,D4
00002288  1A3C 0000               2219          MOVE.B    #0,D5
0000228C  6000 003E               2220          BRA       ADDQ_PARAM_DONE
00002290                          2221  
00002290                          2222  ADDQ_WORD_DN
00002290  183C 0001               2223          MOVE.B    #1,D4
00002294  1A3C 0000               2224          MOVE.B    #0,D5
00002298  6000 0032               2225          BRA       ADDQ_PARAM_DONE
0000229C                          2226  
0000229C                          2227  ADDQ_LONG_DN
0000229C  183C 0002               2228          MOVE.B    #2,D4
000022A0  1A3C 0000               2229          MOVE.B    #0,D5
000022A4  6000 0026               2230          BRA       ADDQ_PARAM_DONE
000022A8                          2231  
000022A8                          2232  ADDQ_BYTE_EA
000022A8  183C 0000               2233          MOVE.B    #0,D4
000022AC  1A3C 0001               2234          MOVE.B    #1,D5
000022B0  6000 001A               2235          BRA       ADDQ_PARAM_DONE
000022B4                          2236          
000022B4                          2237  ADDQ_WORD_EA
000022B4  183C 0001               2238          MOVE.B    #1,D4
000022B8  1A3C 0001               2239          MOVE.B    #1,D5
000022BC  6000 000E               2240          BRA       ADDQ_PARAM_DONE
000022C0                          2241  
000022C0                          2242  ADDQ_LONG_EA
000022C0  183C 0002               2243          MOVE.B    #2,D4
000022C4  1A3C 0001               2244          MOVE.B    #1,D5
000022C8  6000 0002               2245          BRA       ADDQ_PARAM_DONE
000022CC                          2246  
000022CC                          2247  ADDQ_PARAM_DONE
000022CC                          2248          
000022CC                          2249          * -------------------
000022CC                          2250          * print the size
000022CC                          2251          * -------------------
000022CC                          2252  
000022CC  16FC 002E               2253          MOVE.B    #'.',(A3)+
000022D0  B83C 0000               2254          CMP.B     #0,D4
000022D4  6700 0016               2255          BEQ       ADDQ_PRINT_SIZE_BYTE
000022D8  B83C 0001               2256          CMP.B     #1,D4
000022DC  6700 0016               2257          BEQ       ADDQ_PRINT_SIZE_WORD
000022E0  B83C 0002               2258          CMP.B     #2,D4
000022E4  6700 0016               2259          BEQ       ADDQ_PRINT_SIZE_LONG
000022E8                          2260  
000022E8  6000 001A               2261          BRA       ADDQ_PRINT_SIZE_DONE
000022EC                          2262  
000022EC                          2263  ADDQ_PRINT_SIZE_BYTE
000022EC  16FC 0042               2264          MOVE.B    #'B',(A3)+
000022F0  6000 0012               2265          BRA       ADDQ_PRINT_SIZE_DONE
000022F4                          2266  ADDQ_PRINT_SIZE_WORD
000022F4  16FC 0057               2267          MOVE.B    #'W',(A3)+
000022F8  6000 000A               2268          BRA       ADDQ_PRINT_SIZE_DONE
000022FC                          2269  ADDQ_PRINT_SIZE_LONG
000022FC  16FC 004C               2270          MOVE.B    #'L',(A3)+
00002300  6000 0002               2271          BRA       ADDQ_PRINT_SIZE_DONE
00002304                          2272  
00002304                          2273  ADDQ_PRINT_SIZE_DONE
00002304  16FC 0009               2274          MOVE.B    #9,(A3)+
00002308  16FC 0023               2275          MOVE.B    #'#',(A3)+
0000230C  16FC 0024               2276          MOVE.B    #'$',(A3)+
00002310                          2277  
00002310  4EB9 00002338           2278          JSR       ADDQ_PRINT_NUM
00002316  16FC 002C               2279          MOVE.B    #',',(A3)+
0000231A  4EB8 17A2               2280          JSR       PRINT_SOURCE_SUB    ; the "source" is actually the source here
0000231E                          2281  
0000231E                          2282  ADDQ_END
0000231E                          2283  
0000231E  16FC 000A               2284          MOVE.B    #$0A,(A3)+
00002322  16FC 000D               2285          MOVE.B    #$0D,(A3)+
00002326                          2286  
00002326  23C9 00007750           2287          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
0000232C  23CB 0000775C           2288          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
00002332                          2289  
00002332  4CDF 7FFF               2290          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
00002336  4E75                    2291          RTS       ; return
00002338                          2292  
00002338                          2293  ADDQ_PRINT_NUM
00002338  48E7 4000               2294          MOVEM.L   D1,-(SP) ; move the old registers onto the stack
0000233C                          2295  
0000233C  E049                    2296          LSR.W     #8,D1
0000233E  E249                    2297          LSR.W     #1,D1
00002340  C2BC 00000007           2298          AND.L     #7,D1   ; isolate the number part of the opcode
00002346                          2299  
00002346  4A41                    2300          TST.W     D1
00002348  6600 0006               2301          BNE       ADDQ_ZERO_IS_EIGHT
0000234C                          2302  
0000234C  123C 0008               2303          MOVE.B    #8,D1
00002350                          2304  
00002350                          2305  ADDQ_ZERO_IS_EIGHT
00002350                          2306  
00002350  23CB 0000775C           2307          MOVE.L    A3,OUT_CURR_A ; update the output pos before we print
00002356  4EB8 1A5C               2308          JSR       PRINT_NUM     ; print the number in D1
0000235A                          2309  
0000235A  4CDF 0002               2310          MOVEM.L   (SP)+,D1 ; move the old registers back to the stack
0000235E  4E75                    2311          RTS
0000235E  4E75                    2312  -------------------- end include --------------------
00002360                          2313          INCLUDE 'BRA_SUB.X68'
00002360                          2314  BRA_SUB
00002360  48E7 FFFE               2315          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00002364                          2316  
00002364                          2317          * sets up the data registers
00002364                          2318          *
00002364                          2319          * A1 - the current opcode's address
00002364                          2320          * A3 - the current position of the output
00002364                          2321          * A4 - the location of the text for printing
00002364                          2322          *
00002364                          2323          * D1 - the actual opcode
00002364                          2324          *
00002364  227C 00000000           2325          MOVEA.L   #0,A1             ; load the current opcode into a register
0000236A  2279 00007750           2326          MOVEA.L   IN_CURR_A,A1
00002370  2609                    2327          MOVE.L  A1,D3
00002372  5483                    2328          ADDQ.L  #2,D3
00002374  3219                    2329          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00002376                          2330  
00002376  267C 00000000           2331          MOVEA.L   #0,A3
0000237C  2679 0000775C           2332          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00002382  49F9 00007794           2333          LEA       BRA_STR,A4     ; move the to-be-printed string to A4
00002388                          2334  
00002388                          2335          * we need to append the string at ###_STR to the output string
00002388                          2336          * we do this char by char (byte by byte) until we see a NULL (0)
00002388                          2337          * in ###_STR
00002388                          2338  
00002388                          2339  BRA_COPY
00002388  4A14                    2340          TST.B     (A4)      ; test the contents of A4
0000238A  6700 0006               2341          BEQ       BRA_DONE  ; if we hit a 00, we're done copying
0000238E                          2342  
0000238E  16DC                    2343          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00002390  60F6                    2344          BRA       BRA_COPY      ; do it again
00002392                          2345          
00002392                          2346  BRA_DONE
00002392  1401                    2347          MOVE.B  D1,D2
00002394  C47C 00FF               2348          AND.W   #$FF,D2
00002398  B47C 0000               2349          CMP #0,D2
0000239C  6700 002E               2350          BEQ BRA_GETWORD
000023A0                          2351  
000023A0                          2352  
000023A0  1C01                    2353          MOVE.B  D1,D6
000023A2  DC03                    2354          ADD.B   D3,D6
000023A4  1606                    2355          MOVE.B D6,D3
000023A6  2203                    2356          MOVE.L D3,D1
000023A8                          2357  
000023A8                          2358  BRA_FINISH
000023A8  23CB 0000775C           2359          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
000023AE                          2360  
000023AE  4EB8 1A5C               2361          JSR PRINT_NUM
000023B2                          2362          
000023B2                          2363  
000023B2                          2364  
000023B2                          2365          
000023B2  16FC 000A               2366          MOVE.B  #$A,(A3)+
000023B6  16FC 000D               2367          MOVE.B  #$D,(A3)+
000023BA                          2368  
000023BA  23C9 00007750           2369          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
000023C0  23CB 0000775C           2370          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
000023C6                          2371  
000023C6  4CDF 7FFF               2372          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
000023CA  4E75                    2373          RTS       ; return
000023CC                          2374  
000023CC                          2375  BRA_GETWORD
000023CC  7400                    2376          MOVE.L #0,D2
000023CE  3419                    2377          MOVE.W  (A1)+,D2
000023D0  D483                    2378          ADD.L   D3,D2
000023D2  2202                    2379          MOVE.L  D2,D1
000023D4  60D2                    2380          BRA BRA_FINISH
000023D6                          2381  
000023D6                          2382  
000023D6                          2383  
000023D6                          2384  
000023D6                          2385  
000023D6                          2386  
000023D6                          2387  
000023D6                          2388  
000023D6                          2389  
000023D6                          2390  -------------------- end include --------------------
000023D6                          2391          INCLUDE 'BCC_SUB.X68'
000023D6                          2392  BCC_SUB
000023D6  48E7 FFFE               2393          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
000023DA                          2394  
000023DA                          2395          * sets up the data registers
000023DA                          2396          *
000023DA                          2397          * A1 - the current opcode's address
000023DA                          2398          * A3 - the current position of the output
000023DA                          2399          * A4 - the location of the text for printing
000023DA                          2400          *
000023DA                          2401          * D1 - the actual opcode
000023DA                          2402          *
000023DA  227C 00000000           2403          MOVEA.L   #0,A1             ; load the current opcode into a register
000023E0  2279 00007750           2404          MOVEA.L   IN_CURR_A,A1
000023E6  2609                    2405          MOVE.L  A1,D3
000023E8  5483                    2406          ADDQ.L  #2,D3
000023EA  3219                    2407          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
000023EC                          2408  
000023EC  267C 00000000           2409          MOVEA.L   #0,A3
000023F2  2679 0000775C           2410          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
000023F8  49F9 000077D1           2411          LEA       BCC_STR,A4     ; move the to-be-printed string to A4
000023FE                          2412  
000023FE                          2413          * we need to append the string at ###_STR to the output string
000023FE                          2414          * we do this char by char (byte by byte) until we see a NULL (0)
000023FE                          2415          * in ###_STR
000023FE                          2416  
000023FE                          2417  BCC_COPY
000023FE  4A14                    2418          TST.B     (A4)      ; test the contents of A4
00002400  6790                    2419          BEQ       BRA_DONE  ; if we hit a 00, we're done copying
00002402                          2420  
00002402  16DC                    2421          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00002404  60F8                    2422          BRA       BCC_COPY      ; do it again
00002406                          2423  
00002406                          2424        
00002406                          2425          
00002406                          2426  -------------------- end include --------------------
00002406                          2427          INCLUDE 'BGE_SUB.X68'
00002406                          2428  BGE_SUB
00002406  48E7 FFFE               2429          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
0000240A                          2430  
0000240A                          2431          * sets up the data registers
0000240A                          2432          *
0000240A                          2433          * A1 - the current opcode's address
0000240A                          2434          * A3 - the current position of the output
0000240A                          2435          * A4 - the location of the text for printing
0000240A                          2436          *
0000240A                          2437          * D1 - the actual opcode
0000240A                          2438          *
0000240A  227C 00000000           2439          MOVEA.L   #0,A1             ; load the current opcode into a register
00002410  2279 00007750           2440          MOVEA.L   IN_CURR_A,A1
00002416  2609                    2441          MOVE.L  A1,D3
00002418  5483                    2442          ADDQ.L  #2,D3
0000241A  3219                    2443          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
0000241C                          2444  
0000241C  267C 00000000           2445          MOVEA.L   #0,A3
00002422  2679 0000775C           2446          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00002428  49F9 000077D7           2447          LEA       BGE_STR,A4     ; move the to-be-printed string to A4
0000242E                          2448  
0000242E                          2449          * we need to append the string at ###_STR to the output string
0000242E                          2450          * we do this char by char (byte by byte) until we see a NULL (0)
0000242E                          2451          * in ###_STR
0000242E                          2452  
0000242E                          2453  BGE_COPY
0000242E  4A14                    2454          TST.B     (A4)      ; test the contents of A4
00002430  6700 FF60               2455          BEQ       BRA_DONE  ; if we hit a 00, we're done copying
00002434                          2456  
00002434  16DC                    2457          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00002436  60F6                    2458          BRA       BGE_COPY      ; do it again
00002438                          2459  
00002438                          2460        
00002438                          2461  
00002438                          2462  
00002438                          2463  
00002438                          2464  
00002438                          2465  -------------------- end include --------------------
00002438                          2466          INCLUDE 'BLT_SUB.X68'
00002438                          2467  BLT_SUB
00002438  48E7 FFFE               2468          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
0000243C                          2469  
0000243C                          2470          * sets up the data registers
0000243C                          2471          *
0000243C                          2472          * A1 - the current opcode's address
0000243C                          2473          * A3 - the current position of the output
0000243C                          2474          * A4 - the location of the text for printing
0000243C                          2475          *
0000243C                          2476          * D1 - the actual opcode
0000243C                          2477          *
0000243C  227C 00000000           2478          MOVEA.L   #0,A1             ; load the current opcode into a register
00002442  2279 00007750           2479          MOVEA.L   IN_CURR_A,A1
00002448  2609                    2480          MOVE.L  A1,D3
0000244A  5483                    2481          ADDQ.L  #2,D3
0000244C  3219                    2482          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
0000244E                          2483  
0000244E  267C 00000000           2484          MOVEA.L   #0,A3
00002454  2679 0000775C           2485          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
0000245A  49F9 000077DD           2486          LEA       BLT_STR,A4     ; move the to-be-printed string to A4
00002460                          2487  
00002460                          2488          * we need to append the string at ###_STR to the output string
00002460                          2489          * we do this char by char (byte by byte) until we see a NULL (0)
00002460                          2490          * in ###_STR
00002460                          2491  
00002460                          2492  BLT_COPY
00002460  4A14                    2493          TST.B     (A4)      ; test the contents of A4
00002462  6700 FF2E               2494          BEQ       BRA_DONE  ; if we hit a 00, we're done copying
00002466                          2495  
00002466  16DC                    2496          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00002468  60F6                    2497          BRA       BLT_COPY      ; do it again
0000246A                          2498  
0000246A                          2499  -------------------- end include --------------------
0000246A                          2500          INCLUDE 'MOVEQ_SUB.X68'
0000246A                          2501  
0000246A                          2502  MOVEQ_SUB
0000246A  48E7 FFFE               2503          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
0000246E                          2504  
0000246E                          2505          * sets up the data registers
0000246E                          2506          *
0000246E                          2507          * A1 - the current opcode's address
0000246E                          2508          * A3 - the current position of the output
0000246E                          2509          * A4 - the location of the text for printing
0000246E                          2510          *
0000246E                          2511          * D1 - the actual opcode
0000246E                          2512          *
0000246E  227C 00000000           2513          MOVEA.L   #0,A1             ; load the current opcode into a register
00002474  2279 00007750           2514          MOVEA.L   IN_CURR_A,A1
0000247A  3219                    2515          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
0000247C                          2516  
0000247C  267C 00000000           2517          MOVEA.L   #0,A3
00002482  2679 0000775C           2518          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00002488  49F9 0000779A           2519          LEA       MOVEQ_STR,A4     ; move the to-be-printed string to A4
0000248E                          2520  
0000248E                          2521          * we need to append the string at MOVEQ_STR to the output string
0000248E                          2522          * we do this char by char (byte by byte) until we see a NULL (0)
0000248E                          2523          * in MOVEQ_STR
0000248E                          2524  
0000248E                          2525  MOVEQ_COPY
0000248E  4A14                    2526          TST.B     (A4)      ; test the contents of A4
00002490  6700 0006               2527          BEQ       MOVEQ_DONE  ; if we hit a 00, we're done copying
00002494                          2528  
00002494  16DC                    2529          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00002496  60F6                    2530          BRA       MOVEQ_COPY      ; do it again
00002498                          2531          
00002498                          2532  MOVEQ_DONE
00002498                          2533  
00002498  16FC 002E               2534          MOVE.B    #'.',(A3)+    ; print the size (it's always a .L)
0000249C  16FC 004C               2535          MOVE.B    #'L',(A3)+
000024A0  16FC 0009               2536          MOVE.B    #$09,(A3)+
000024A4                          2537  
000024A4                          2538          * print the source ( a single bit of data )
000024A4  16FC 0023               2539          MOVE.B    #'#',(A3)+
000024A8  16FC 0024               2540          MOVE.B    #'$',(A3)+
000024AC  2401                    2541          MOVE.L    D1,D2       ; keep a copy in D2
000024AE  0281 000000FF           2542          ANDI.L    #$FF,D1     ; isolate the data (last btye)
000024B4  23CB 0000775C           2543          MOVE.L    A3,OUT_CURR_A
000024BA  4EB8 1A5C               2544          JSR       PRINT_NUM   ; print it
000024BE  2202                    2545          MOVE.L    D2,D1       ; move old data back
000024C0                          2546  
000024C0                          2547          * print destination ( always a Dn )
000024C0  16FC 002C               2548          MOVE.B    #',',(A3)+
000024C4  16FC 0044               2549          MOVE.B    #'D',(A3)+
000024C8  3401                    2550          MOVE.W    D1,D2     ; make a copy of the opcode
000024CA  0242 0E00               2551          ANDI.W    #$E00,D2  ; isolate the register num
000024CE  E04A                    2552          LSR.W     #8,D2     ; move to end
000024D0  E24A                    2553          LSR.W     #1,D2
000024D2  0602 0030               2554          ADDI.B    #$30,D2   ; add to make ascii char
000024D6  16C2                    2555          MOVE.B    D2,(A3)+  ; print
000024D8                          2556  
000024D8  16FC 000A               2557          MOVE.B    #$0A,(A3)+
000024DC  16FC 000D               2558          MOVE.B    #$0D,(A3)+
000024E0                          2559  
000024E0  23C9 00007750           2560          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
000024E6  23CB 0000775C           2561          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
000024EC                          2562  
000024EC  4CDF 7FFF               2563          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
000024F0  4E75                    2564          RTS       ; return
000024F2                          2565  
000024F2                          2566  
000024F2                          2567  -------------------- end include --------------------
000024F2                          2568          INCLUDE 'DIVU_SUB.X68'
000024F2                          2569  DIVU_SUB
000024F2  48E7 FFFE               2570          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
000024F6                          2571  
000024F6                          2572          * sets up the data registers
000024F6                          2573          *
000024F6                          2574          * A1 - the current opcode's address
000024F6                          2575          * A3 - the current position of the output
000024F6                          2576          * A4 - the location of the text for printing
000024F6                          2577          *
000024F6                          2578          * D1 - the actual opcode
000024F6                          2579          *
000024F6  227C 00000000           2580          MOVEA.L   #0,A1             ; load the current opcode into a register
000024FC  2279 00007750           2581          MOVEA.L   IN_CURR_A,A1
00002502  3219                    2582          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00002504                          2583  
00002504  267C 00000000           2584          MOVEA.L   #0,A3
0000250A  2679 0000775C           2585          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00002510  49F9 000077C3           2586          LEA       DIVU_STR,A4     ; move the to-be-printed string to A4
00002516                          2587  
00002516                          2588          * we need to append the string at MOVE_STR to the output string
00002516                          2589          * we do this char by char (byte by byte) until we see a NULL (0)
00002516                          2590          * in MOVE_STR
00002516                          2591  
00002516                          2592  DIVU_COPY
00002516  4A14                    2593          TST.B     (A4)      ; test the contents of A4
00002518  6700 018E               2594          BEQ       MULS_DONE  ; if we hit a 00, we're done copying
0000251C                          2595  
0000251C  16DC                    2596          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
0000251E  60F6                    2597          BRA       DIVU_COPY      ; do it again
00002520                          2598          
00002520                          2599  
00002520                          2600  -------------------- end include --------------------
00002520                          2601          INCLUDE 'SUB_SUB.X68'
00002520                          2602  
00002520                          2603  SUB_SUB
00002520  48E7 FFFE               2604          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00002524                          2605  
00002524                          2606          * sets up the data registers
00002524                          2607          *
00002524                          2608          * A1 - the current opcode's address
00002524                          2609          * A3 - the current position of the output
00002524                          2610          * A4 - the location of the text for printing
00002524                          2611          *
00002524                          2612          * D1 - the actual opcode
00002524                          2613          *
00002524  227C 00000000           2614          MOVEA.L   #0,A1             ; load the current opcode into a register
0000252A  2279 00007750           2615          MOVEA.L   IN_CURR_A,A1
00002530  3219                    2616          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00002532                          2617  
00002532  267C 00000000           2618          MOVEA.L   #0,A3
00002538  2679 0000775C           2619          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
0000253E  49F9 000077B3           2620          LEA       SUB_STR,A4     ; move the to-be-printed string to A4
00002544                          2621  
00002544                          2622          * we need to append the string at SUB_STR to the output string
00002544                          2623          * we do this char by char (byte by byte) until we see a NULL (0)
00002544                          2624          * in SUB_STR
00002544                          2625  
00002544                          2626  SUB_COPY
00002544  4A14                    2627          TST.B     (A4)      ; test the contents of A4
00002546  6700 0006               2628          BEQ       SUB_DONE  ; if we hit a 00, we're done copying
0000254A                          2629  
0000254A  16DC                    2630          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
0000254C  60F6                    2631          BRA       SUB_COPY      ; do it again
0000254E                          2632          
0000254E                          2633  SUB_DONE
0000254E                          2634    
0000254E                          2635          * D4 = size       ( 0 = B, 1 = W, 2 = L)
0000254E                          2636          * D5 = direction  ( 0 = Dn first, 1 = <ea> first)
0000254E                          2637  
0000254E  3401                    2638          MOVE.W    D1,D2
00002550  EC4A                    2639          LSR.W     #6,D2
00002552  0242 0007               2640          ANDI.W    #7,D2
00002556                          2641  
00002556  B47C 0000               2642          CMP.W     #0,D2
0000255A  6700 002E               2643          BEQ       SUB_BYTE_DN
0000255E  B47C 0001               2644          CMP.W     #1,D2
00002562  6700 0032               2645          BEQ       SUB_WORD_DN
00002566  B47C 0002               2646          CMP.W     #2,D2
0000256A  6700 0036               2647          BEQ       SUB_LONG_DN
0000256E                          2648  
0000256E  B47C 0004               2649          CMP.W     #4,D2
00002572  6700 003A               2650          BEQ       SUB_BYTE_EA
00002576  B47C 0005               2651          CMP.W     #5,D2
0000257A  6700 003E               2652          BEQ       SUB_WORD_EA
0000257E  B47C 0006               2653          CMP.W     #6,D2
00002582  6700 0042               2654          BEQ       SUB_LONG_EA
00002586                          2655          
00002586                          2656          * if nothing is found just jump to the end
00002586  6000 004A               2657          BRA       SUB_PARAM_DONE
0000258A                          2658  
0000258A                          2659  SUB_BYTE_DN
0000258A  183C 0000               2660          MOVE.B    #0,D4
0000258E  1A3C 0000               2661          MOVE.B    #0,D5
00002592  6000 003E               2662          BRA       SUB_PARAM_DONE
00002596                          2663  
00002596                          2664  SUB_WORD_DN
00002596  183C 0001               2665          MOVE.B    #1,D4
0000259A  1A3C 0000               2666          MOVE.B    #0,D5
0000259E  6000 0032               2667          BRA       SUB_PARAM_DONE
000025A2                          2668  
000025A2                          2669  SUB_LONG_DN
000025A2  183C 0002               2670          MOVE.B    #2,D4
000025A6  1A3C 0000               2671          MOVE.B    #0,D5
000025AA  6000 0026               2672          BRA       SUB_PARAM_DONE
000025AE                          2673  
000025AE                          2674  SUB_BYTE_EA
000025AE  183C 0000               2675          MOVE.B    #0,D4
000025B2  1A3C 0001               2676          MOVE.B    #1,D5
000025B6  6000 001A               2677          BRA       SUB_PARAM_DONE
000025BA                          2678          
000025BA                          2679  SUB_WORD_EA
000025BA  183C 0001               2680          MOVE.B    #1,D4
000025BE  1A3C 0001               2681          MOVE.B    #1,D5
000025C2  6000 000E               2682          BRA       SUB_PARAM_DONE
000025C6                          2683  
000025C6                          2684  SUB_LONG_EA
000025C6  183C 0002               2685          MOVE.B    #2,D4
000025CA  1A3C 0001               2686          MOVE.B    #1,D5
000025CE  6000 0002               2687          BRA       SUB_PARAM_DONE
000025D2                          2688  
000025D2                          2689  SUB_PARAM_DONE
000025D2                          2690          
000025D2                          2691          * -------------------
000025D2                          2692          * print the size
000025D2                          2693          * -------------------
000025D2                          2694  
000025D2  16FC 002E               2695          MOVE.B    #'.',(A3)+
000025D6  B83C 0000               2696          CMP.B     #0,D4
000025DA  6700 0016               2697          BEQ       SUB_PRINT_SIZE_BYTE
000025DE  B83C 0001               2698          CMP.B     #1,D4
000025E2  6700 0016               2699          BEQ       SUB_PRINT_SIZE_WORD
000025E6  B83C 0002               2700          CMP.B     #2,D4
000025EA  6700 0016               2701          BEQ       SUB_PRINT_SIZE_LONG
000025EE                          2702  
000025EE  6000 001A               2703          BRA       SUB_PRINT_SIZE_DONE
000025F2                          2704  
000025F2                          2705  SUB_PRINT_SIZE_BYTE
000025F2  16FC 0042               2706          MOVE.B    #'B',(A3)+
000025F6  6000 0012               2707          BRA       SUB_PRINT_SIZE_DONE
000025FA                          2708  SUB_PRINT_SIZE_WORD
000025FA  16FC 0057               2709          MOVE.B    #'W',(A3)+
000025FE  6000 000A               2710          BRA       SUB_PRINT_SIZE_DONE
00002602                          2711  SUB_PRINT_SIZE_LONG
00002602  16FC 004C               2712          MOVE.B    #'L',(A3)+
00002606  6000 0002               2713          BRA       SUB_PRINT_SIZE_DONE
0000260A                          2714  
0000260A                          2715  SUB_PRINT_SIZE_DONE
0000260A  16FC 0009               2716          MOVE.B    #9,(A3)+
0000260E                          2717  
0000260E                          2718          * -------------------
0000260E                          2719          * check the direction
0000260E                          2720          * -------------------
0000260E                          2721  
0000260E  4A05                    2722          TST.B     D5
00002610  6700 000C               2723          BEQ       SUB_EA_DN
00002614  4EB9 0000265C           2724          JSR       SUB_DN_TO_EA
0000261A  6000 0008               2725          BRA       SUB_END
0000261E                          2726  
0000261E                          2727  SUB_EA_DN
0000261E  4EB9 0000263E           2728          JSR       SUB_EA_TO_DN
00002624                          2729  
00002624                          2730  SUB_END
00002624                          2731  
00002624  16FC 000A               2732          MOVE.B    #$0A,(A3)+
00002628  16FC 000D               2733          MOVE.B    #$0D,(A3)+
0000262C                          2734  
0000262C  23C9 00007750           2735          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
00002632  23CB 0000775C           2736          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
00002638                          2737  
00002638  4CDF 7FFF               2738          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
0000263C  4E75                    2739          RTS       ; return
0000263E                          2740  
0000263E                          2741  SUB_EA_TO_DN
0000263E                          2742  
0000263E  4EB8 17A2               2743          JSR       PRINT_SOURCE_SUB    ; the "source" is actually the source here
00002642  16FC 002C               2744          MOVE.B    #',',(A3)+
00002646  16FC 0044               2745          MOVE.B    #'D',(A3)+
0000264A  3401                    2746          MOVE.W    D1,D2
0000264C  E04A                    2747          LSR.W     #8,D2
0000264E  E24A                    2748          LSR.W     #1,D2
00002650  0242 0007               2749          ANDI.W    #7,D2
00002654  0642 0030               2750          ADDI.W    #$30,D2
00002658  16C2                    2751          MOVE.B    D2,(A3)+
0000265A                          2752  
0000265A  4E75                    2753          RTS
0000265C                          2754  SUB_DN_TO_EA
0000265C                          2755  
0000265C  16FC 0044               2756          MOVE.B    #'D',(A3)+
00002660  3401                    2757          MOVE.W    D1,D2
00002662  E04A                    2758          LSR.W     #8,D2
00002664  E24A                    2759          LSR.W     #1,D2
00002666  0242 0007               2760          ANDI.W    #7,D2
0000266A  0642 0030               2761          ADDI.W    #$30,D2
0000266E  16C2                    2762          MOVE.B    D2,(A3)+
00002670  16FC 002C               2763          MOVE.B    #',',(A3)+
00002674  4EB8 17A2               2764          JSR       PRINT_SOURCE_SUB    ; the "source" is actually the source here
00002678                          2765  
00002678  4E75                    2766          RTS
0000267A                          2767  
0000267A                          2768  
0000267A                          2769  -------------------- end include --------------------
0000267A                          2770          INCLUDE 'MULS_SUB.X68'
0000267A                          2771  MULS_SUB
0000267A  48E7 FFFE               2772          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
0000267E                          2773  
0000267E                          2774          * sets up the data registers
0000267E                          2775          *
0000267E                          2776          * A1 - the current opcode's address
0000267E                          2777          * A3 - the current position of the output
0000267E                          2778          * A4 - the location of the text for printing
0000267E                          2779          *
0000267E                          2780          * D1 - the actual opcode
0000267E                          2781          *
0000267E  227C 00000000           2782          MOVEA.L   #0,A1             ; load the current opcode into a register
00002684  2279 00007750           2783          MOVEA.L   IN_CURR_A,A1
0000268A  3219                    2784          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
0000268C                          2785  
0000268C  267C 00000000           2786          MOVEA.L   #0,A3
00002692  2679 0000775C           2787          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00002698  49F9 000077BC           2788          LEA       MULS_STR,A4     ; move the to-be-printed string to A4
0000269E                          2789  
0000269E                          2790          * we need to append the string at MOVE_STR to the output string
0000269E                          2791          * we do this char by char (byte by byte) until we see a NULL (0)
0000269E                          2792          * in MOVE_STR
0000269E                          2793  
0000269E                          2794  MULS_COPY
0000269E  4A14                    2795          TST.B     (A4)      ; test the contents of A4
000026A0  6700 0006               2796          BEQ       MULS_DONE  ; if we hit a 00, we're done copying
000026A4                          2797  
000026A4  16DC                    2798          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
000026A6  60F6                    2799          BRA       MULS_COPY      ; do it again
000026A8                          2800          
000026A8                          2801  MULS_DONE
000026A8  16FC 0009               2802          MOVE.B  #9,(A3)+
000026AC  13FC 0001 00007761      2803          MOVE.B  #1,SIZE_BUFFER
000026B4  4EB8 17A2               2804          JSR PRINT_SOURCE_SUB
000026B8  16FC 002C               2805          MOVE.B  #',',(A3)+
000026BC  16FC 0044               2806          MOVE.B  #'D',(A3)+
000026C0  C2BC 00000E00           2807          AND.L   #$0E00,D1
000026C6  E089                    2808          LSR.L   #8,D1
000026C8  E289                    2809          LSR.L   #1,D1
000026CA                          2810          
000026CA  23CB 0000775C           2811          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
000026D0                          2812  
000026D0  4EB8 1A5C               2813          JSR PRINT_NUM
000026D4                          2814          
000026D4  16FC 000A               2815          MOVE.B    #$0A,(A3)+
000026D8  16FC 000D               2816          MOVE.B    #$0D,(A3)+
000026DC                          2817  
000026DC  23C9 00007750           2818          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
000026E2  23CB 0000775C           2819          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
000026E8                          2820  
000026E8  4CDF 7FFF               2821          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
000026EC  4E75                    2822          RTS       ; return
000026EE                          2823  
000026EE                          2824  
000026EE                          2825  
000026EE                          2826  -------------------- end include --------------------
000026EE                          2827          INCLUDE 'AND_SUB.X68'
000026EE                          2828  
000026EE                          2829  AND_SUB
000026EE  48E7 FFFE               2830          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
000026F2                          2831  
000026F2                          2832          * sets up the data registers
000026F2                          2833          *
000026F2                          2834          * A1 - the current opcode's address
000026F2                          2835          * A3 - the current position of the output
000026F2                          2836          * A4 - the location of the text for printing
000026F2                          2837          *
000026F2                          2838          * D1 - the actual opcode
000026F2                          2839          *
000026F2  227C 00000000           2840          MOVEA.L   #0,A1             ; load the current opcode into a register
000026F8  2279 00007750           2841          MOVEA.L   IN_CURR_A,A1
000026FE  3219                    2842          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00002700                          2843  
00002700  267C 00000000           2844          MOVEA.L   #0,A3
00002706  2679 0000775C           2845          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
0000270C  49F9 000077CA           2846          LEA       AND_STR,A4     ; move the to-be-printed string to A4
00002712                          2847  
00002712                          2848          * we need to append the string at AND_STR to the output string
00002712                          2849          * we do this char by char (byte by byte) until we see a NULL (0)
00002712                          2850          * in AND_STR
00002712                          2851  
00002712                          2852  AND_COPY
00002712  4A14                    2853          TST.B     (A4)      ; test the contents of A4
00002714  6700 0006               2854          BEQ       AND_DONE  ; if we hit a 00, we're done copying
00002718                          2855  
00002718  16DC                    2856          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
0000271A  60F6                    2857          BRA       AND_COPY      ; do it again
0000271C                          2858          
0000271C                          2859  AND_DONE
0000271C                          2860    
0000271C                          2861          * D4 = size       ( 0 = B, 1 = W, 2 = L)
0000271C                          2862          * D5 = direction  ( 0 = Dn first, 1 = <ea> first)
0000271C                          2863  
0000271C  3401                    2864          MOVE.W    D1,D2
0000271E  EC4A                    2865          LSR.W     #6,D2
00002720  0242 0007               2866          ANDI.W    #7,D2
00002724                          2867  
00002724  B47C 0000               2868          CMP.W     #0,D2
00002728  6700 002E               2869          BEQ       AND_DN
0000272C  B47C 0001               2870          CMP.W     #1,D2
00002730  6700 0026               2871          BEQ       AND_DN
00002734  B47C 0002               2872          CMP.W     #2,D2
00002738  6700 001E               2873          BEQ       AND_DN
0000273C                          2874  
0000273C  B47C 0004               2875          CMP.W     #4,D2
00002740  6700 001E               2876          BEQ       AND_EA
00002744  B47C 0005               2877          CMP.W     #5,D2
00002748  6700 0016               2878          BEQ       AND_EA
0000274C  B47C 0006               2879          CMP.W     #6,D2
00002750  6700 000E               2880          BEQ       AND_EA
00002754                          2881          
00002754                          2882          * if nothing is found just jump to the end
00002754  6000 0012               2883          BRA       AND_PARAM_DONE
00002758                          2884  
00002758                          2885  AND_DN
00002758  1A3C 0000               2886          MOVE.B    #0,D5
0000275C  6000 000A               2887          BRA       AND_PARAM_DONE
00002760                          2888  
00002760                          2889  AND_EA
00002760  1A3C 0001               2890          MOVE.B    #1,D5
00002764  6000 0002               2891          BRA       AND_PARAM_DONE
00002768                          2892  
00002768                          2893  AND_PARAM_DONE
00002768                          2894          
00002768                          2895          * -------------------
00002768                          2896          * print the size
00002768                          2897          * -------------------
00002768                          2898  
00002768  4EB8 1742               2899          JSR       PRINT_SIZE_LATE_SUB
0000276C  16FC 0009               2900          MOVE.B    #9,(A3)+
00002770                          2901  
00002770                          2902          * -------------------
00002770                          2903          * check the direction
00002770                          2904          * -------------------
00002770                          2905  
00002770  4A05                    2906          TST.B     D5
00002772  6700 000C               2907          BEQ       AND_EA_DN
00002776  4EB9 000027BE           2908          JSR       AND_DN_TO_EA
0000277C  6000 0008               2909          BRA       AND_END
00002780                          2910  
00002780                          2911  AND_EA_DN
00002780  4EB9 000027A0           2912          JSR       AND_EA_TO_DN
00002786                          2913  
00002786                          2914  AND_END
00002786                          2915  
00002786  16FC 000A               2916          MOVE.B    #$0A,(A3)+
0000278A  16FC 000D               2917          MOVE.B    #$0D,(A3)+
0000278E                          2918  
0000278E  23C9 00007750           2919          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
00002794  23CB 0000775C           2920          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
0000279A                          2921  
0000279A  4CDF 7FFF               2922          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
0000279E  4E75                    2923          RTS       ; return
000027A0                          2924  
000027A0                          2925  AND_EA_TO_DN
000027A0                          2926  
000027A0  4EB8 17A2               2927          JSR       PRINT_SOURCE_SUB    ; the "source" is actually the source here
000027A4  16FC 002C               2928          MOVE.B    #',',(A3)+
000027A8  16FC 0044               2929          MOVE.B    #'D',(A3)+
000027AC  3401                    2930          MOVE.W    D1,D2
000027AE  E04A                    2931          LSR.W     #8,D2
000027B0  E24A                    2932          LSR.W     #1,D2
000027B2  0242 0007               2933          ANDI.W    #7,D2
000027B6  0642 0030               2934          ADDI.W    #$30,D2
000027BA  16C2                    2935          MOVE.B    D2,(A3)+
000027BC                          2936  
000027BC  4E75                    2937          RTS
000027BE                          2938  AND_DN_TO_EA
000027BE                          2939  
000027BE  16FC 0044               2940          MOVE.B    #'D',(A3)+
000027C2  3401                    2941          MOVE.W    D1,D2
000027C4  E04A                    2942          LSR.W     #8,D2
000027C6  E24A                    2943          LSR.W     #1,D2
000027C8  0242 0007               2944          ANDI.W    #7,D2
000027CC  0642 0030               2945          ADDI.W    #$30,D2
000027D0  16C2                    2946          MOVE.B    D2,(A3)+
000027D2  16FC 002C               2947          MOVE.B    #',',(A3)+
000027D6  4EB8 17A2               2948          JSR       PRINT_SOURCE_SUB    ; the "source" is actually the source here
000027DA                          2949  
000027DA  4E75                    2950          RTS
000027DC                          2951  
000027DC                          2952  
000027DC                          2953  -------------------- end include --------------------
000027DC                          2954          INCLUDE 'OR_SUB.X68'
000027DC                          2955  
000027DC                          2956  OR_SUB
000027DC  48E7 FFFE               2957          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
000027E0                          2958  
000027E0                          2959          * sets up the data registers
000027E0                          2960          *
000027E0                          2961          * A1 - the current opcode's address
000027E0                          2962          * A3 - the current position of the output
000027E0                          2963          * A4 - the location of the text for printing
000027E0                          2964          *
000027E0                          2965          * D1 - the actual opcode
000027E0                          2966          *
000027E0  227C 00000000           2967          MOVEA.L   #0,A1             ; load the current opcode into a register
000027E6  2279 00007750           2968          MOVEA.L   IN_CURR_A,A1
000027EC  3219                    2969          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
000027EE                          2970  
000027EE  267C 00000000           2971          MOVEA.L   #0,A3
000027F4  2679 0000775C           2972          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
000027FA  49F9 000077CE           2973          LEA       OR_STR,A4     ; move the to-be-printed string to A4
00002800                          2974  
00002800                          2975          * we need to append the string at OR_STR to the output string
00002800                          2976          * we do this char by char (byte by byte) until we see a NULL (0)
00002800                          2977          * in OR_STR
00002800                          2978  
00002800                          2979  OR_COPY
00002800  4A14                    2980          TST.B     (A4)      ; test the contents of A4
00002802  6700 0006               2981          BEQ       OR_DONE  ; if we hit a 00, we're done copying
00002806                          2982  
00002806  16DC                    2983          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00002808  60F6                    2984          BRA       OR_COPY      ; do it again
0000280A                          2985          
0000280A                          2986  OR_DONE
0000280A                          2987    
0000280A                          2988          * D5 = direction  ( 0 = Dn first, 1 = <ea> first)
0000280A                          2989  
0000280A  3401                    2990          MOVE.W    D1,D2
0000280C  EC4A                    2991          LSR.W     #6,D2
0000280E  0242 0007               2992          ANDI.W    #7,D2
00002812                          2993  
00002812  B47C 0000               2994          CMP.W     #0,D2
00002816  6700 002E               2995          BEQ       OR_DN
0000281A  B47C 0001               2996          CMP.W     #1,D2
0000281E  6700 0026               2997          BEQ       OR_DN
00002822  B47C 0002               2998          CMP.W     #2,D2
00002826  6700 001E               2999          BEQ       OR_DN
0000282A                          3000  
0000282A  B47C 0004               3001          CMP.W     #4,D2
0000282E  6700 001E               3002          BEQ       OR_EA
00002832  B47C 0005               3003          CMP.W     #5,D2
00002836  6700 0016               3004          BEQ       OR_EA
0000283A  B47C 0006               3005          CMP.W     #6,D2
0000283E  6700 000E               3006          BEQ       OR_EA
00002842                          3007          
00002842                          3008          * if nothing is found just jump to the end
00002842  6000 0012               3009          BRA       OR_PARAM_DONE
00002846                          3010  
00002846                          3011  OR_DN
00002846  1A3C 0000               3012          MOVE.B    #0,D5
0000284A  6000 000A               3013          BRA       OR_PARAM_DONE
0000284E                          3014  
0000284E                          3015  OR_EA
0000284E  1A3C 0001               3016          MOVE.B    #1,D5
00002852  6000 0002               3017          BRA       OR_PARAM_DONE
00002856                          3018  
00002856                          3019  OR_PARAM_DONE
00002856                          3020          
00002856                          3021          * -------------------
00002856                          3022          * print the size
00002856                          3023          * -------------------
00002856                          3024  
00002856  4EB8 1742               3025          JSR       PRINT_SIZE_LATE_SUB
0000285A  16FC 0009               3026          MOVE.B    #9,(A3)+
0000285E                          3027  
0000285E                          3028          * -------------------
0000285E                          3029          * check the direction
0000285E                          3030          * -------------------
0000285E                          3031  
0000285E  4A05                    3032          TST.B     D5
00002860  6700 000C               3033          BEQ       OR_EA_DN
00002864  4EB9 000028AC           3034          JSR       OR_DN_TO_EA
0000286A  6000 0008               3035          BRA       OR_END
0000286E                          3036  
0000286E                          3037  OR_EA_DN
0000286E  4EB9 0000288E           3038          JSR       OR_EA_TO_DN
00002874                          3039  
00002874                          3040  OR_END
00002874                          3041  
00002874  16FC 000A               3042          MOVE.B    #$0A,(A3)+
00002878  16FC 000D               3043          MOVE.B    #$0D,(A3)+
0000287C                          3044  
0000287C  23C9 00007750           3045          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
00002882  23CB 0000775C           3046          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
00002888                          3047  
00002888  4CDF 7FFF               3048          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
0000288C  4E75                    3049          RTS       ; return
0000288E                          3050  
0000288E                          3051  OR_EA_TO_DN
0000288E  4EB8 17A2               3052          JSR       PRINT_SOURCE_SUB    ; the "source" is actually the source here
00002892  16FC 002C               3053          MOVE.B    #',',(A3)+
00002896  16FC 0044               3054          MOVE.B    #'D',(A3)+
0000289A  3401                    3055          MOVE.W    D1,D2
0000289C  E04A                    3056          LSR.W     #8,D2
0000289E  E24A                    3057          LSR.W     #1,D2
000028A0  0242 0007               3058          ANDI.W    #7,D2
000028A4  0642 0030               3059          ADDI.W    #$30,D2
000028A8  16C2                    3060          MOVE.B    D2,(A3)+
000028AA                          3061  
000028AA  4E75                    3062          RTS
000028AC                          3063  OR_DN_TO_EA
000028AC                          3064  
000028AC  16FC 0044               3065          MOVE.B    #'D',(A3)+
000028B0  3401                    3066          MOVE.W    D1,D2
000028B2  E04A                    3067          LSR.W     #8,D2
000028B4  E24A                    3068          LSR.W     #1,D2
000028B6  0242 0007               3069          ANDI.W    #7,D2
000028BA  0642 0030               3070          ADDI.W    #$30,D2
000028BE  16C2                    3071          MOVE.B    D2,(A3)+
000028C0  16FC 002C               3072          MOVE.B    #',',(A3)+
000028C4  4EB8 17A2               3073          JSR       PRINT_SOURCE_SUB    ; the "source" is actually the source here
000028C8                          3074  
000028C8  4E75                    3075          RTS
000028CA                          3076  
000028CA                          3077  
000028CA                          3078  -------------------- end include --------------------
000028CA                          3079          INCLUDE 'ADD_SUB.X68'
000028CA                          3080  
000028CA                          3081  ADD_SUB
000028CA  48E7 FFFE               3082          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
000028CE                          3083  
000028CE                          3084          * sets up the data registers
000028CE                          3085          *
000028CE                          3086          * A1 - the current opcode's address
000028CE                          3087          * A3 - the current position of the output
000028CE                          3088          * A4 - the location of the text for printing
000028CE                          3089          *
000028CE                          3090          * D1 - the actual opcode
000028CE                          3091          *
000028CE  227C 00000000           3092          MOVEA.L   #0,A1             ; load the current opcode into a register
000028D4  2279 00007750           3093          MOVEA.L   IN_CURR_A,A1
000028DA  3219                    3094          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
000028DC                          3095  
000028DC  267C 00000000           3096          MOVEA.L   #0,A3
000028E2  2679 0000775C           3097          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
000028E8  49F9 000077A0           3098          LEA       ADD_STR,A4     ; move the to-be-printed string to A4
000028EE                          3099  
000028EE                          3100          * we need to append the string at ADD_STR to the output string
000028EE                          3101          * we do this char by char (byte by byte) until we see a NULL (0)
000028EE                          3102          * in ADD_STR
000028EE                          3103  
000028EE                          3104  ADD_COPY
000028EE  4A14                    3105          TST.B     (A4)      ; test the contents of A4
000028F0  6700 0006               3106          BEQ       ADD_DONE  ; if we hit a 00, we're done copying
000028F4                          3107  
000028F4  16DC                    3108          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
000028F6  60F6                    3109          BRA       ADD_COPY      ; do it again
000028F8                          3110          
000028F8                          3111  ADD_DONE
000028F8                          3112    
000028F8                          3113          * D4 = size       ( 0 = B, 1 = W, 2 = L)
000028F8                          3114  
000028F8  3401                    3115          MOVE.W    D1,D2
000028FA  EC4A                    3116          LSR.W     #6,D2
000028FC  0242 0007               3117          ANDI.W    #7,D2
00002900                          3118  
00002900  B47C 0000               3119          CMP.W     #0,D2
00002904  6700 002E               3120          BEQ       ADD_DN
00002908  B47C 0001               3121          CMP.W     #1,D2
0000290C  6700 0026               3122          BEQ       ADD_DN
00002910  B47C 0002               3123          CMP.W     #2,D2
00002914  6700 001E               3124          BEQ       ADD_DN
00002918                          3125  
00002918  B47C 0004               3126          CMP.W     #4,D2
0000291C  6700 001E               3127          BEQ       ADD_EA
00002920  B47C 0005               3128          CMP.W     #5,D2
00002924  6700 0016               3129          BEQ       ADD_EA
00002928  B47C 0006               3130          CMP.W     #6,D2
0000292C  6700 000E               3131          BEQ       ADD_EA
00002930                          3132          
00002930                          3133          * if nothing is found just jump to the end
00002930  6000 0012               3134          BRA       ADD_PARAM_DONE
00002934                          3135  
00002934                          3136  ADD_DN
00002934  1A3C 0000               3137          MOVE.B    #0,D5
00002938  6000 000A               3138          BRA       ADD_PARAM_DONE
0000293C                          3139  
0000293C                          3140  ADD_EA
0000293C  1A3C 0001               3141          MOVE.B    #1,D5
00002940  6000 0002               3142          BRA       ADD_PARAM_DONE
00002944                          3143  
00002944                          3144  ADD_PARAM_DONE
00002944                          3145          
00002944                          3146          * -------------------
00002944                          3147          * print the size
00002944                          3148          * -------------------
00002944                          3149  
00002944  4EB8 1742               3150          JSR       PRINT_SIZE_LATE_SUB
00002948                          3151  
00002948  16FC 0009               3152          MOVE.B    #9,(A3)+
0000294C                          3153  
0000294C                          3154          * -------------------
0000294C                          3155          * check the direction
0000294C                          3156          * -------------------
0000294C                          3157  
0000294C  4A05                    3158          TST.B     D5
0000294E  6700 000C               3159          BEQ       ADD_EA_DN
00002952  4EB9 0000299A           3160          JSR       ADD_DN_TO_EA
00002958  6000 0008               3161          BRA       ADD_END
0000295C                          3162  
0000295C                          3163  ADD_EA_DN
0000295C  4EB9 0000297C           3164          JSR       ADD_EA_TO_DN
00002962                          3165  
00002962                          3166  ADD_END
00002962                          3167  
00002962  16FC 000A               3168          MOVE.B    #$0A,(A3)+
00002966  16FC 000D               3169          MOVE.B    #$0D,(A3)+
0000296A                          3170  
0000296A  23C9 00007750           3171          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
00002970  23CB 0000775C           3172          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
00002976                          3173  
00002976  4CDF 7FFF               3174          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
0000297A  4E75                    3175          RTS       ; return
0000297C                          3176  
0000297C                          3177  ADD_EA_TO_DN
0000297C                          3178  
0000297C  4EB8 17A2               3179          JSR       PRINT_SOURCE_SUB    ; the "source" is actually the source here
00002980  16FC 002C               3180          MOVE.B    #',',(A3)+
00002984  16FC 0044               3181          MOVE.B    #'D',(A3)+
00002988  3401                    3182          MOVE.W    D1,D2
0000298A  E04A                    3183          LSR.W     #8,D2
0000298C  E24A                    3184          LSR.W     #1,D2
0000298E  0242 0007               3185          ANDI.W    #7,D2
00002992  0642 0030               3186          ADDI.W    #$30,D2
00002996  16C2                    3187          MOVE.B    D2,(A3)+
00002998                          3188  
00002998  4E75                    3189          RTS
0000299A                          3190  ADD_DN_TO_EA
0000299A                          3191  
0000299A  16FC 0044               3192          MOVE.B    #'D',(A3)+
0000299E  3401                    3193          MOVE.W    D1,D2
000029A0  E04A                    3194          LSR.W     #8,D2
000029A2  E24A                    3195          LSR.W     #1,D2
000029A4  0242 0007               3196          ANDI.W    #7,D2
000029A8  0642 0030               3197          ADDI.W    #$30,D2
000029AC  16C2                    3198          MOVE.B    D2,(A3)+
000029AE  16FC 002C               3199          MOVE.B    #',',(A3)+
000029B2  4EB8 17A2               3200          JSR       PRINT_SOURCE_SUB    ; the "source" is actually the source here
000029B6                          3201  
000029B6  4E75                    3202          RTS
000029B8                          3203  
000029B8                          3204  
000029B8                          3205  -------------------- end include --------------------
000029B8                          3206          INCLUDE 'ADDA_SUB.X68'
000029B8                          3207  
000029B8                          3208  ADDA_SUB
000029B8  48E7 FFFE               3209          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
000029BC                          3210  
000029BC                          3211          * sets up the data registers
000029BC                          3212          *
000029BC                          3213          * A1 - the current opcode's address
000029BC                          3214          * A3 - the current position of the output
000029BC                          3215          * A4 - the location of the text for printing
000029BC                          3216          *
000029BC                          3217          * D1 - the actual opcode
000029BC                          3218          *
000029BC  227C 00000000           3219          MOVEA.L   #0,A1             ; load the current opcode into a register
000029C2  2279 00007750           3220          MOVEA.L   IN_CURR_A,A1
000029C8  3219                    3221          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
000029CA                          3222  
000029CA  267C 00000000           3223          MOVEA.L   #0,A3
000029D0  2679 0000775C           3224          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
000029D6  49F9 000077A4           3225          LEA       ADDA_STR,A4     ; move the to-be-printed string to A4
000029DC                          3226  
000029DC                          3227          * we need to append the string at ADDA_STR to the output string
000029DC                          3228          * we do this char by char (byte by byte) until we see a NULL (0)
000029DC                          3229          * in ADDA_STR
000029DC                          3230  
000029DC                          3231  ADDA_COPY
000029DC  4A14                    3232          TST.B     (A4)      ; test the contents of A4
000029DE  6700 0006               3233          BEQ       ADDA_AONE  ; if we hit a 00, we're done copying
000029E2                          3234  
000029E2  16DC                    3235          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
000029E4  60F6                    3236          BRA       ADDA_COPY      ; do it again
000029E6                          3237          
000029E6                          3238  ADDA_AONE
000029E6                          3239    
000029E6  16FC 002E               3240          MOVE.B    #'.',(A3)+
000029EA                          3241  
000029EA  3401                    3242          MOVE.W    D1,D2
000029EC  E04A                    3243          LSR.W     #8,D2
000029EE  0242 0001               3244          ANDI.W    #1,D2
000029F2                          3245  
000029F2  4A42                    3246          TST       D2
000029F4  6700 0006               3247          BEQ       ADDA_WORD_AN
000029F8  6000 0012               3248          BRA       ADDA_LONG_AN
000029FC                          3249  
000029FC                          3250  ADDA_WORD_AN
000029FC  13FC 0001 00007761      3251          MOVE.B    #1,SIZE_BUFFER
00002A04  16FC 0057               3252          MOVE.B    #'W',(A3)+
00002A08  6000 0012               3253          BRA       ADDA_PRINT_SIZE_DONE
00002A0C                          3254  
00002A0C                          3255  ADDA_LONG_AN
00002A0C  13FC 0002 00007761      3256          MOVE.B    #2,SIZE_BUFFER
00002A14  16FC 004C               3257          MOVE.B    #'L',(A3)+
00002A18  6000 0002               3258          BRA       ADDA_PRINT_SIZE_DONE
00002A1C                          3259  
00002A1C                          3260  ADDA_PRINT_SIZE_DONE
00002A1C  16FC 0009               3261          MOVE.B    #9,(A3)+
00002A20                          3262  
00002A20  4EB9 00002A40           3263          JSR       ADDA_EA_TO_AN
00002A26                          3264  
00002A26                          3265  ADDA_END
00002A26                          3266  
00002A26  16FC 000A               3267          MOVE.B    #$0A,(A3)+
00002A2A  16FC 000D               3268          MOVE.B    #$0D,(A3)+
00002A2E                          3269  
00002A2E  23C9 00007750           3270          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
00002A34  23CB 0000775C           3271          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
00002A3A                          3272  
00002A3A  4CDF 7FFF               3273          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
00002A3E  4E75                    3274          RTS       ; return
00002A40                          3275  
00002A40                          3276  ADDA_EA_TO_AN
00002A40                          3277  
00002A40  4EB8 17A2               3278          JSR       PRINT_SOURCE_SUB    ; the "source" is actually the source here
00002A44  16FC 002C               3279          MOVE.B    #',',(A3)+
00002A48  16FC 0041               3280          MOVE.B    #'A',(A3)+
00002A4C  3401                    3281          MOVE.W    D1,D2
00002A4E  E04A                    3282          LSR.W     #8,D2
00002A50  E24A                    3283          LSR.W     #1,D2
00002A52  0242 0007               3284          ANDI.W    #7,D2
00002A56  0642 0030               3285          ADDI.W    #$30,D2
00002A5A  16C2                    3286          MOVE.B    D2,(A3)+
00002A5C                          3287  
00002A5C  4E75                    3288          RTS
00002A5C  4E75                    3289  -------------------- end include --------------------
00002A5E                          3290          INCLUDE 'ASL_SUB.X68'
00002A5E                          3291  ASL_SUB
00002A5E  48E7 FFFE               3292          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00002A62                          3293  
00002A62                          3294          * sets up the data registers
00002A62                          3295          *
00002A62                          3296          * A1 - the current opcode's address
00002A62                          3297          * A3 - the current position of the output
00002A62                          3298          * A4 - the location of the text for printing
00002A62                          3299          *
00002A62                          3300          * D1 - the actual opcode
00002A62                          3301          *
00002A62  227C 00000000           3302          MOVEA.L   #0,A1             ; load the current opcode into a register
00002A68  2279 00007750           3303          MOVEA.L   IN_CURR_A,A1
00002A6E  3219                    3304          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00002A70                          3305  
00002A70  267C 00000000           3306          MOVEA.L   #0,A3
00002A76  2679 0000775C           3307          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00002A7C  49F9 000077EB           3308          LEA       ASL_STR,A4     ; move the to-be-printed string to A4
00002A82                          3309  
00002A82                          3310          * we need to append the string at ###_STR to the output string
00002A82                          3311          * we do this char by char (byte by byte) until we see a NULL (0)
00002A82                          3312          * in ###_STR
00002A82                          3313  
00002A82                          3314  ASL_COPY
00002A82  4A14                    3315          TST.B     (A4)      ; test the contents of A4
00002A84  6700 00EC               3316          BEQ       ROR_DONE  ; if we hit a 00, we're done copying
00002A88                          3317  
00002A88  16DC                    3318          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00002A8A  60F6                    3319          BRA       ASL_COPY      ; do it again
00002A8C                          3320          
00002A8C                          3321        
00002A8C                          3322  -------------------- end include --------------------
00002A8C                          3323          INCLUDE 'ASR_SUB.X68'
00002A8C                          3324  ASR_SUB
00002A8C  48E7 FFFE               3325          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00002A90                          3326  
00002A90                          3327          * sets up the data registers
00002A90                          3328          *
00002A90                          3329          * A1 - the current opcode's address
00002A90                          3330          * A3 - the current position of the output
00002A90                          3331          * A4 - the location of the text for printing
00002A90                          3332          *
00002A90                          3333          * D1 - the actual opcode
00002A90                          3334          *
00002A90  227C 00000000           3335          MOVEA.L   #0,A1             ; load the current opcode into a register
00002A96  2279 00007750           3336          MOVEA.L   IN_CURR_A,A1
00002A9C  3219                    3337          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00002A9E                          3338  
00002A9E  267C 00000000           3339          MOVEA.L   #0,A3
00002AA4  2679 0000775C           3340          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00002AAA  49F9 000077EF           3341          LEA       ASR_STR,A4     ; move the to-be-printed string to A4
00002AB0                          3342  
00002AB0                          3343          * we need to append the string at ###_STR to the output string
00002AB0                          3344          * we do this char by char (byte by byte) until we see a NULL (0)
00002AB0                          3345          * in ###_STR
00002AB0                          3346  
00002AB0                          3347  ASR_COPY
00002AB0  4A14                    3348          TST.B     (A4)      ; test the contents of A4
00002AB2  6700 00BE               3349          BEQ       ROR_DONE  ; if we hit a 00, we're done copying
00002AB6                          3350  
00002AB6  16DC                    3351          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00002AB8  60F6                    3352          BRA       ASR_COPY      ; do it again
00002ABA                          3353          
00002ABA                          3354     
00002ABA                          3355  -------------------- end include --------------------
00002ABA                          3356          INCLUDE 'LSL_SUB.X68'
00002ABA                          3357  LSL_SUB
00002ABA  48E7 FFFE               3358          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00002ABE                          3359  
00002ABE                          3360          * sets up the data registers
00002ABE                          3361          *
00002ABE                          3362          * A1 - the current opcode's address
00002ABE                          3363          * A3 - the current position of the output
00002ABE                          3364          * A4 - the location of the text for printing
00002ABE                          3365          *
00002ABE                          3366          * D1 - the actual opcode
00002ABE                          3367          *
00002ABE  227C 00000000           3368          MOVEA.L   #0,A1             ; load the current opcode into a register
00002AC4  2279 00007750           3369          MOVEA.L   IN_CURR_A,A1
00002ACA  3219                    3370          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00002ACC                          3371  
00002ACC  267C 00000000           3372          MOVEA.L   #0,A3
00002AD2  2679 0000775C           3373          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00002AD8  49F9 000077F3           3374          LEA       LSL_STR,A4     ; move the to-be-printed string to A4
00002ADE                          3375  
00002ADE                          3376          * we need to append the string at ###_STR to the output string
00002ADE                          3377          * we do this char by char (byte by byte) until we see a NULL (0)
00002ADE                          3378          * in ###_STR
00002ADE                          3379  
00002ADE                          3380  LSL_COPY
00002ADE  4A14                    3381          TST.B     (A4)      ; test the contents of A4
00002AE0  6700 0090               3382          BEQ       ROR_DONE  ; if we hit a 00, we're done copying
00002AE4                          3383  
00002AE4  16DC                    3384          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00002AE6  60F6                    3385          BRA       LSL_COPY      ; do it again
00002AE8                          3386  
00002AE8                          3387  -------------------- end include --------------------
00002AE8                          3388          INCLUDE 'LSR_SUB.X68'
00002AE8                          3389  LSR_SUB
00002AE8  48E7 FFFE               3390          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00002AEC                          3391  
00002AEC                          3392          * sets up the data registers
00002AEC                          3393          *
00002AEC                          3394          * A1 - the current opcode's address
00002AEC                          3395          * A3 - the current position of the output
00002AEC                          3396          * A4 - the location of the text for printing
00002AEC                          3397          *
00002AEC                          3398          * D1 - the actual opcode
00002AEC                          3399          *
00002AEC  227C 00000000           3400          MOVEA.L   #0,A1             ; load the current opcode into a register
00002AF2  2279 00007750           3401          MOVEA.L   IN_CURR_A,A1
00002AF8  3219                    3402          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00002AFA                          3403  
00002AFA  267C 00000000           3404          MOVEA.L   #0,A3
00002B00  2679 0000775C           3405          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00002B06  49F9 000077F7           3406          LEA       LSR_STR,A4     ; move the to-be-printed string to A4
00002B0C                          3407  
00002B0C                          3408          * we need to append the string at ###_STR to the output string
00002B0C                          3409          * we do this char by char (byte by byte) until we see a NULL (0)
00002B0C                          3410          * in ###_STR
00002B0C                          3411  
00002B0C                          3412  LSR_COPY
00002B0C  4A14                    3413          TST.B     (A4)      ; test the contents of A4
00002B0E  6700 0062               3414          BEQ       ROR_DONE  ; if we hit a 00, we're done copying
00002B12                          3415  
00002B12  16DC                    3416          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00002B14  60F6                    3417          BRA       LSR_COPY      ; do it again
00002B16                          3418  
00002B16                          3419  -------------------- end include --------------------
00002B16                          3420          INCLUDE 'ROL_SUB.X68'
00002B16                          3421  ROL_SUB
00002B16  48E7 FFFE               3422          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00002B1A                          3423  
00002B1A                          3424          * sets up the data registers
00002B1A                          3425          *
00002B1A                          3426          * A1 - the current opcode's address
00002B1A                          3427          * A3 - the current position of the output
00002B1A                          3428          * A4 - the location of the text for printing
00002B1A                          3429          *
00002B1A                          3430          * D1 - the actual opcode
00002B1A                          3431          *
00002B1A  227C 00000000           3432          MOVEA.L   #0,A1             ; load the current opcode into a register
00002B20  2279 00007750           3433          MOVEA.L   IN_CURR_A,A1
00002B26  3219                    3434          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00002B28                          3435  
00002B28  267C 00000000           3436          MOVEA.L   #0,A3
00002B2E  2679 0000775C           3437          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00002B34  49F9 000077E3           3438          LEA       ROL_STR,A4     ; move the to-be-printed string to A4
00002B3A                          3439  
00002B3A                          3440          * we need to append the string at ###_STR to the output string
00002B3A                          3441          * we do this char by char (byte by byte) until we see a NULL (0)
00002B3A                          3442          * in ###_STR
00002B3A                          3443  
00002B3A                          3444  ROL_COPY
00002B3A  4A14                    3445          TST.B     (A4)      ; test the contents of A4
00002B3C  6700 0034               3446          BEQ       ROR_DONE  ; if we hit a 00, we're done copying
00002B40                          3447  
00002B40  16DC                    3448          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00002B42  60F6                    3449          BRA       ROL_COPY      ; do it again
00002B44                          3450          
00002B44                          3451     
00002B44                          3452  -------------------- end include --------------------
00002B44                          3453          INCLUDE 'ROR_SUB.X68'
00002B44                          3454  ROR_SUB
00002B44  48E7 FFFE               3455          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00002B48                          3456  
00002B48                          3457          * sets up the data registers
00002B48                          3458          *
00002B48                          3459          * A1 - the current opcode's address
00002B48                          3460          * A3 - the current position of the output
00002B48                          3461          * A4 - the location of the text for printing
00002B48                          3462          *
00002B48                          3463          * D1 - the actual opcode
00002B48                          3464          *
00002B48  227C 00000000           3465          MOVEA.L   #0,A1             ; load the current opcode into a register
00002B4E  2279 00007750           3466          MOVEA.L   IN_CURR_A,A1
00002B54  3219                    3467          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00002B56                          3468  
00002B56  267C 00000000           3469          MOVEA.L   #0,A3
00002B5C  2679 0000775C           3470          MOVEA.L   OUT_CURR_A,A3 ; move the current output pointer to A3
00002B62  49F9 000077E7           3471          LEA       ROR_STR,A4     ; move the to-be-printed string to A4
00002B68                          3472  
00002B68                          3473          * we need to append the string at ###_STR to the output string
00002B68                          3474          * we do this char by char (byte by byte) until we see a NULL (0)
00002B68                          3475          * in ###_STR
00002B68                          3476  
00002B68                          3477  ROR_COPY
00002B68  4A14                    3478          TST.B     (A4)      ; test the contents of A4
00002B6A  6700 0006               3479          BEQ       ROR_DONE  ; if we hit a 00, we're done copying
00002B6E                          3480  
00002B6E  16DC                    3481          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00002B70  60F6                    3482          BRA       ROR_COPY      ; do it again
00002B72                          3483          
00002B72                          3484  ROR_DONE
00002B72  3001                    3485            MOVE.W    D1, D0
00002B74  0240 00C0               3486            ANDI.W    #$00C0,D0
00002B78  EC48                    3487            LSR.W     #6,D0
00002B7A                          3488            
00002B7A                          3489            *mem shift, get EA
00002B7A  B03C 0003               3490            CMP.B     #3,D0
00002B7E  6700 00A4               3491            BEQ       ROR_EA
00002B82                          3492  
00002B82                          3493            * we always print the period (2E in ASCII)
00002B82  16FC 002E               3494            MOVE.B    #$2E,(A3)+
00002B86                          3495  
00002B86                          3496            * switch to the correct subroutine
00002B86  B03C 0000               3497            CMP.B     #0,D0
00002B8A  6700 0066               3498            BEQ       ROR_PRINT_SIZE_BYTE
00002B8E  B03C 0001               3499            CMP.B     #1,D0
00002B92  6700 0064               3500            BEQ       ROR_PRINT_SIZE_WORD
00002B96  B03C 0002               3501            CMP.B     #2,D0
00002B9A  6700 0062               3502            BEQ       ROR_PRINT_SIZE_LONG
00002B9E                          3503            
00002B9E                          3504  ROR_PRINT_SIZE_END
00002B9E                          3505            * print a tab and return
00002B9E  16FC 0009               3506            MOVE.B    #9,(A3)+
00002BA2  3001                    3507            MOVE.W    D1, D0
00002BA4  0240 0020               3508            ANDI.W    #$0020,D0
00002BA8  EA48                    3509            LSR.W     #5,D0
00002BAA                          3510            
00002BAA  3E01                    3511            MOVE.W    D1,D7
00002BAC  B03C 0000               3512            CMP.B #0,D0
00002BB0  6700 0052               3513            BEQ   ROR_IMM
00002BB4                          3514            
00002BB4                          3515            *DATA REGISTER
00002BB4                          3516     
00002BB4  16FC 0044               3517            MOVE.B    #'D',(A3)+
00002BB8  CE7C 0E00               3518            AND.W #$0E00,D7
00002BBC  E04F                    3519            LSR.W #8,D7
00002BBE  E24F                    3520            LSR.W #1,D7
00002BC0  0607 0030               3521            ADD.B #$30,D7
00002BC4  16C7                    3522            MOVE.B    D7,(A3)+
00002BC6                          3523            
00002BC6                          3524  ROR_DEST          *GET DATA REGISTER
00002BC6  16FC 002C               3525            MOVE.B    #',',(A3)+
00002BCA  16FC 0044               3526            MOVE.B    #'D',(A3)+
00002BCE                          3527   
00002BCE  0241 0007               3528            ANDI.W    #$0007,D1
00002BD2                          3529  
00002BD2  0601 0030               3530            ADD.B     #$30,D1
00002BD6  16C1                    3531            MOVE.B    D1,(A3)+
00002BD8                          3532            
00002BD8                          3533  ROR_FIN          
00002BD8  16FC 000A               3534            MOVE.B    #$0A,(A3)+
00002BDC  16FC 000D               3535            MOVE.B    #$0D,(A3)+
00002BE0                          3536   
00002BE0  23C9 00007750           3537          MOVE.L    A1,IN_CURR_A  ; move the current A1 back to the input pointer
00002BE6  23CB 0000775C           3538          MOVE.L    A3,OUT_CURR_A ; move the current A3 back to the output pointer
00002BEC                          3539  
00002BEC  4CDF 7FFF               3540          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
00002BF0  4E75                    3541          RTS       ; return
00002BF2                          3542  
00002BF2                          3543  ROR_PRINT_SIZE_BYTE
00002BF2  16FC 0042               3544            MOVE.B    #$42,(A3)+
00002BF6  60A6                    3545            BRA       ROR_PRINT_SIZE_END
00002BF8                          3546  
00002BF8                          3547  ROR_PRINT_SIZE_WORD
00002BF8  16FC 0057               3548            MOVE.B    #$57,(A3)+
00002BFC  60A0                    3549            BRA       ROR_PRINT_SIZE_END
00002BFE                          3550  
00002BFE                          3551  ROR_PRINT_SIZE_LONG
00002BFE  16FC 004C               3552            MOVE.B    #$4C,(A3)+
00002C02  609A                    3553            BRA       ROR_PRINT_SIZE_END
00002C04                          3554  ROR_IMM
00002C04  16FC 0023               3555      MOVE.B    #'#',(A3)+
00002C08  CE7C 0E00               3556      AND.W #$0E00,D7
00002C0C  E04F                    3557      LSR.W #8,D7
00002C0E  E24F                    3558      LSR.W #1,D7
00002C10                          3559  
00002C10  4A47                    3560      TST.W D7
00002C12  6700 000A               3561      BEQ   ROR_EIGHT
00002C16                          3562            
00002C16  0607 0030               3563      ADD.B #$30,D7
00002C1A  16C7                    3564      MOVE.B D7,(A3)+
00002C1C                          3565  
00002C1C  60A8                    3566      BRA ROR_DEST
00002C1E                          3567  
00002C1E                          3568  ROR_EIGHT
00002C1E  16FC 0038               3569      MOVE.B #'8',(A3)+
00002C22  60A2                    3570      BRA    ROR_DEST
00002C24                          3571  
00002C24                          3572  ROR_EA
00002C24  16FC 002E               3573      MOVE.B    #$2E,(A3)+
00002C28  16FC 0057               3574      MOVE.B    #$57,(A3)+
00002C2C  16FC 0009               3575      MOVE.B #$09,(A3)+
00002C30  4EB8 17A2               3576      JSR PRINT_SOURCE_SUB
00002C34  60A2                    3577      BRA ROR_FIN
00002C36                          3578  
00002C36                          3579  
00002C36                          3580  
00002C36                          3581  
00002C36                          3582  
00002C36                          3583  -------------------- end include --------------------
00002C36                          3584  
00002C36                          3585  
00002C36                          3586  
00002C36                          3587  
00002C36                          3588  -------------------- end include --------------------
00002C36                          3589      INCLUDE 'OPCODE_TEST.X68'
00007000                          3590      ORG    $7000
00007000                          3591  MAIN    
00007000                          3592      *NOP
00007000  4E71                    3593      NOP
00007002                          3594      
00007002                          3595      *MOVE
00007002  1200                    3596      MOVE.B  D0,D1
00007004  18D3                    3597      MOVE.B  (A3),(A4)+
00007006  1B1C                    3598      MOVE.B  (A4)+,-(A5)
00007008  11E5 6000               3599      MOVE.B  -(A5),$6000
0000700C  11F8 6000 7000          3600      MOVE.B  $6000,$7000
00007012  13F8 7000 00008000      3601      MOVE.B  $7000,$8000
0000701A  11F9 00008000 7000      3602      MOVE.B  $8000,$7000
00007022  13F9 00008000 00009000  3603      MOVE.B  $8000,$9000
0000702C  11FC 0070 4000          3604      MOVE.B  #$70,$4000
00007032  13FC 0070 0000A000      3605      MOVE.B  #$70,$A000
0000703A  3205                    3606      MOVE.W  D5,D1
0000703C  3441                    3607      MOVE.W  D1,A2 
0000703E  368A                    3608      MOVE.W  A2,(A3)
00007040  38D3                    3609      MOVE.W  (A3),(A4)+ 
00007042  3B1C                    3610      MOVE.W  (A4)+,-(A5) 
00007044  31E5 6000               3611      MOVE.W  -(A5),$6000 
00007048  31F8 6001 7000          3612      MOVE.W  $6001,$7000
0000704E  33F8 7001 00008000      3613      MOVE.W  $7001,$8000
00007056  31F9 00008001 7000      3614      MOVE.W  $8001,$7000
0000705E  33F9 00008001 00009000  3615      MOVE.W  $8001,$9000 
00007068  31FC 0050 4000          3616      MOVE.W  #$50,$4000
0000706E  33FC 0050 0000A000      3617      MOVE.W  #$50,$A000
00007076  31FC 5000 4000          3618      MOVE.W  #$5000,$4000
0000707C  33FC 5000 0000A000      3619      MOVE.W  #$5000,$A000
00007084  2200                    3620      MOVE.L  D0,D1 
00007086  268A                    3621      MOVE.L  A2,(A3)
00007088  28D3                    3622      MOVE.L  (A3),(A4)+
0000708A  2B1C                    3623      MOVE.L  (A4)+,-(A5)
0000708C  21E5 6000               3624      MOVE.L  -(A5),$6000
00007090  21F8 6000 7001          3625      MOVE.L  $6000,$7001
00007096  23F8 7000 00008001      3626      MOVE.L  $7000,$8001             
0000709E  21F9 00008000 7001      3627      MOVE.L  $8000,$7001            
000070A6  23F9 00008000 00009001  3628      MOVE.L  $8000,$9001             
000070B0  21FC 00000070 4000      3629      MOVE.L  #$70,$4000              
000070B8  23FC 00000070 0000A003  3630      MOVE.L  #$70,$A003              
000070C2  21FC 00007000 4500      3631      MOVE.L  #$7000,$4500            
000070CA  23FC 00007000 0000A000  3632      MOVE.L  #$7000,$A000            
000070D4  21FC 70000020 4000      3633      MOVE.L  #$70000020,$4000        
000070DC  23FC 70000030 0000A000  3634      MOVE.L  #$70000030,$A000
000070E6                          3635          
000070E6                          3636      *MOVEA
000070E6  3040                    3637      MOVEA.W  D0,A0                  
000070E8  3248                    3638      MOVEA.W  A0,A1                  
000070EA  3451                    3639      MOVEA.W  (A1),A2               
000070EC  365A                    3640      MOVEA.W  (A2)+,A3              
000070EE  3863                    3641      MOVEA.W  -(A3),A4              
000070F0  3A78 4000               3642      MOVEA.W  $4000,A5               
000070F4  3C79 0000A000           3643      MOVEA.W  $A000,A6              
000070FA  3E7C 0070               3644      MOVEA.W  #$70,A7                
000070FE  307C 7000               3645      MOVEA.W  #$7000,A0             
00007102  2040                    3646      MOVEA.L  D0,A0                 
00007104  2248                    3647      MOVEA.L  A0,A1                 
00007106  2451                    3648      MOVEA.L  (A1),A2               
00007108  265A                    3649      MOVEA.L  (A2)+,A3              
0000710A  2863                    3650      MOVEA.L  -(A3),A4               
0000710C  2A78 4000               3651      MOVEA.L  $4000,A5               
00007110  2C79 0000A000           3652      MOVEA.L  $A000,A6              
00007116  2E7C 00000070           3653      MOVEA.L  #$70,A7               
0000711C                          3654      
0000711C  207C 00007000           3655      MOVEA.L  #$7000,A0             
00007122  227C 70000000           3656      MOVEA.L  #$70000000,A1         
00007128                          3657      
00007128                          3658      *MOVEQ
00007128  7E70                    3659      MOVEQ  #$70,D7
0000712A  70FF                    3660      MOVEQ  #$FF,D0                  
0000712C                          3661      
0000712C                          3662      *MOVEM
0000712C  4CD3 AA55               3663      MOVEM.L  (A3),D0/D2/D4/D6/A1/A3/A5/A7            
00007130  4CDC AA55               3664      MOVEM.L  (A4)+,D0/D2/D4/D6/A1/A3/A5/A7          
00007134  4CF8 AA55 6000          3665      MOVEM.L  $6000,D0/D2/D4/D6/A1/A3/A5/A7          
0000713A  4CF9 AA55 00008000      3666      MOVEM.L  $8000,D0/D2/D4/D6/A1/A3/A5/A7          
00007142  4CDF FFFF               3667      MOVEM.L  (SP)+,D0-D7/A0-A7                           
00007146  48D3 55AA               3668      MOVEM.L  A0/A2/A4/A6/D1/D3/D5/D7,(A3)           
0000714A  48E5 55AA               3669      MOVEM.L  A0/A2/A4/A6/D1/D3/D5/D7,-(A5)           
0000714E  48F8 55AA 6000          3670      MOVEM.L  A0/A2/A4/A6/D1/D3/D5/D7,$6000          
00007154  48F9 55AA 00008000      3671      MOVEM.L  A0/A2/A4/A6/D1/D3/D5/D7,$8000          
0000715C  48E7 FFFF               3672      MOVEM.L  A7-A0/D7-D0,-(SP)                           
00007160  4C93 AA55               3673      MOVEM.W  (A3),D0/D2/D4/D6/A1/A3/A5/A7            
00007164  4C9C AA55               3674      MOVEM.W  (A4)+,D0/D2/D4/D6/A1/A3/A5/A7
00007168                          3675     
00007168                          3676      *BUG      
00007168  4CB8 AA55 6000          3677      MOVEM.W  $6000,D0/D2/D4/D6/A1/A3/A5/A7           
0000716E  4CB9 AA55 00008000      3678      MOVEM.W  $8000,D0/D2/D4/D6/A1/A3/A5/A7
00007176                          3679             
00007176  4C9F FFFF               3680      MOVEM.W  (SP)+,D0-D7/A0-A7                          
0000717A  4893 55AA               3681      MOVEM.W  A0/A2/A4/A6/D1/D3/D5/D7,(A3)            
0000717E  48A5 55AA               3682      MOVEM.W  A0/A2/A4/A6/D1/D3/D5/D7,-(A5)           
00007182  48B8 55AA 6000          3683      MOVEM.W  A0/A2/A4/A6/D1/D3/D5/D7,$6000           
00007188  48B9 55AA 00008000      3684      MOVEM.W  A0/A2/A4/A6/D1/D3/D5/D7,$8000           
00007190  48A7 FFFF               3685      MOVEM.W  A7-A0/D7-D0,-(SP)                       
00007194                          3686      
00007194                          3687      *ADD
00007194  D000                    3688      ADD.B  D0,D0                 
00007196  D411                    3689      ADD.B  (A1),D2                
00007198  D61A                    3690      ADD.B  (A2)+,D3              
0000719A  D823                    3691      ADD.B  -(A3),D4               
0000719C  DA38 4000               3692      ADD.B  $4000,D5              
000071A0  DC39 0000A000           3693      ADD.B  $A000,D6               
000071A6  0607 0070               3694      ADD.B  #$70,D7                   
000071AA  D200                    3695      ADD.B  D0,D1                 
000071AC  D513                    3696      ADD.B  D2,(A3)                
000071AE  D71C                    3697      ADD.B  D3,(A4)+               
000071B0  D925                    3698      ADD.B  D4,-(A5)               
000071B2  DB38 6000               3699      ADD.B  D5,$6000              
000071B6  DD39 00008000           3700      ADD.B  D6,$8000                  
000071BC  D040                    3701      ADD.W  D0,D0                 
000071BE  D248                    3702      ADD.W  A0,D1                 
000071C0  D451                    3703      ADD.W  (A1),D2                
000071C2  D65A                    3704      ADD.W  (A2)+,D3               
000071C4  D863                    3705      ADD.W  -(A3),D4               
000071C6  DA78 4000               3706      ADD.W  $4000,D5               
000071CA  DC79 0000A000           3707      ADD.W  $A000,D6               
000071D0  0647 0070               3708      ADD.W  #$70,D7               
000071D4  0640 7000               3709      ADD.W  #$7000,D0                  
000071D8  D240                    3710      ADD.W  D0,D1                  
000071DA  D4C1                    3711      ADD.W  D1,A2                 
000071DC  D553                    3712      ADD.W  D2,(A3)               
000071DE  D75C                    3713      ADD.W  D3,(A4)+               
000071E0  D965                    3714      ADD.W  D4,-(A5)              
000071E2  DB78 6000               3715      ADD.W  D5,$6000              
000071E6  DD79 00008000           3716      ADD.W  D6,$8000                  
000071EC  D080                    3717      ADD.L  D0,D0                  
000071EE  D288                    3718      ADD.L  A0,D1                 
000071F0  D491                    3719      ADD.L  (A1),D2               
000071F2  D69A                    3720      ADD.L  (A2)+,D3               
000071F4  D8A3                    3721      ADD.L  -(A3),D4              
000071F6  DAB8 4000               3722      ADD.L  $4000,D5              
000071FA  DCB9 0000A000           3723      ADD.L  $A000,D6              
00007200  0687 00000070           3724      ADD.L  #$70,D7                
00007206  0680 00007000           3725      ADD.L  #$7000,D0              
0000720C  0681 70000000           3726      ADD.L  #$70000000,D1             
00007212  D280                    3727      ADD.L  D0,D1                 
00007214  D5C1                    3728      ADD.L  D1,A2                  
00007216  D593                    3729      ADD.L  D2,(A3)               
00007218  D79C                    3730      ADD.L  D3,(A4)+              
0000721A  D9A5                    3731      ADD.L  D4,-(A5)              
0000721C  DBB8 6000               3732      ADD.L  D5,$6000              
00007220  DDB9 00008000           3733      ADD.L  D6,$8000              
00007226                          3734      
00007226                          3735      *ADDA
00007226  D0C0                    3736      ADDA.W  D0,A0                
00007228  D2C8                    3737      ADDA.W  A0,A1                 
0000722A  D4D1                    3738      ADDA.W  (A1),A2               
0000722C  D6DA                    3739      ADDA.W  (A2)+,A3             
0000722E  D8E3                    3740      ADDA.W  -(A3),A4              
00007230  DAF8 4000               3741      ADDA.W  $4000,A5             
00007234  DCF9 0000A000           3742      ADDA.W  $A000,A6             
0000723A  DEFC 0070               3743      ADDA.W  #$70,A7              
0000723E  D0FC 7000               3744      ADDA.W  #$7000,A0                 
00007242  D1C0                    3745      ADDA.L  D0,A0                 
00007244  D3C8                    3746      ADDA.L  A0,A1                
00007246  D5D1                    3747      ADDA.L  (A1),A2              
00007248  D7DA                    3748      ADDA.L  (A2)+,A3              
0000724A  D9E3                    3749      ADDA.L  -(A3),A4              
0000724C  DBF8 4000               3750      ADDA.L  $4000,A5             
00007250  DDF9 0000A000           3751      ADDA.L  $A000,A6              
00007256  DFFC 00000070           3752      ADDA.L  #$70,A7               
0000725C  D1FC 00007000           3753      ADDA.L  #$7000,A0            
00007262  D3FC 70000000           3754      ADDA.L  #$70000000,A1         
00007268                          3755      
00007268                          3756      *ADDI
00007268  0601 0070               3757      ADDI.B  #$70,D1               
0000726C  0613 0070               3758      ADDI.B  #$70,(A3)              
00007270  061C 0070               3759      ADDI.B  #$70,(A4)+             
00007274  0625 0070               3760      ADDI.B  #$70,-(A5)             
00007278  0638 0070 6000          3761      ADDI.B  #$70,$6000             
0000727E  0639 0070 00008000      3762      ADDI.B  #$70,$8000             
00007286  0641 0070               3763      ADDI.W  #$70,D1                
0000728A  0653 0070               3764      ADDI.W  #$70,(A3)              
0000728E  065C 7000               3765      ADDI.W  #$7000,(A4)+          
00007292  0665 0070               3766      ADDI.W  #$70,-(A5)             
00007296  0678 7000 6000          3767      ADDI.W  #$7000,$6000          
0000729C  0679 0070 00008000      3768      ADDI.W  #$70,$8000             
000072A4  0681 00000070           3769      ADDI.L  #$70,D1                
000072AA  0693 70000000           3770      ADDI.L  #$70000000,(A3)        
000072B0  069C 00000070           3771      ADDI.L  #$70,(A4)+             
000072B6  06A5 00007000           3772      ADDI.L  #$7000,-(A5)          
000072BC  06B8 70000000 6000      3773      ADDI.L  #$70000000,$6000       
000072C4  06B9 00000070 00008000  3774      ADDI.L  #$70,$8000         
000072CE                          3775  
000072CE                          3776      *ADDQ
000072CE  5201                    3777      ADDQ.B  #$1,D1                        
000072D0  5613                    3778      ADDQ.B  #$3,(A3)              
000072D2  581C                    3779      ADDQ.B  #$4,(A4)+             
000072D4  5A25                    3780      ADDQ.B  #$5,-(A5)              
000072D6  5C38 6000               3781      ADDQ.B  #$6,$6000              
000072DA  5E39 00008000           3782      ADDQ.B  #$7,$8000             
000072E0  5039 0000A000           3783      ADDQ.B  #$8,$A000 
000072E6  5241                    3784      ADDQ.W  #$1,D1                
000072E8  544A                    3785      ADDQ.W  #$2,A2                
000072EA  5653                    3786      ADDQ.W  #$3,(A3)              
000072EC  585C                    3787      ADDQ.W  #$4,(A4)+             
000072EE  5A65                    3788      ADDQ.W  #$5,-(A5)              
000072F0  5C78 6000               3789      ADDQ.W  #$6,$6000              
000072F4  5E79 00008000           3790      ADDQ.W  #$7,$8000             
000072FA  5079 0000A000           3791      ADDQ.W  #$8,$A000       
00007300  5281                    3792      ADDQ.L  #$1,D1                
00007302  548A                    3793      ADDQ.L  #$2,A2                
00007304  5693                    3794      ADDQ.L  #$3,(A3)              
00007306  589C                    3795      ADDQ.L  #$4,(A4)+             
00007308  5AA5                    3796      ADDQ.L  #$5,-(A5)              
0000730A  5CB8 6000               3797      ADDQ.L  #$6,$6000              
0000730E  5EB9 00008000           3798      ADDQ.L  #$7,$8000             
00007314  50B9 0000A000           3799      ADDQ.L  #$8,$A000       
0000731A                          3800  
0000731A                          3801      *SUB
0000731A  9000                    3802      SUB.B  D0,D0                 
0000731C  9411                    3803      SUB.B  (A1),D2                
0000731E  961A                    3804      SUB.B  (A2)+,D3              
00007320  9823                    3805      SUB.B  -(A3),D4               
00007322  9A38 4000               3806      SUB.B  $4000,D5              
00007326  9C39 0000A000           3807      SUB.B  $A000,D6                    
0000732C  9200                    3808      SUB.B  D0,D1                 
0000732E  9513                    3809      SUB.B  D2,(A3)                
00007330  971C                    3810      SUB.B  D3,(A4)+               
00007332  9925                    3811      SUB.B  D4,-(A5)               
00007334  9B38 6000               3812      SUB.B  D5,$6000              
00007338  9D39 00008000           3813      SUB.B  D6,$8000                  
0000733E  9040                    3814      SUB.W  D0,D0                 
00007340  9248                    3815      SUB.W  A0,D1                 
00007342  9451                    3816      SUB.W  (A1),D2                
00007344  965A                    3817      SUB.W  (A2)+,D3               
00007346  9863                    3818      SUB.W  -(A3),D4               
00007348  9A78 4000               3819      SUB.W  $4000,D5               
0000734C  9C79 0000A000           3820      SUB.W  $A000,D6                       
00007352  9240                    3821      SUB.W  D0,D1                     
00007354  9553                    3822      SUB.W  D2,(A3)               
00007356  975C                    3823      SUB.W  D3,(A4)+               
00007358  9965                    3824      SUB.W  D4,-(A5)              
0000735A  9B78 6000               3825      SUB.W  D5,$6000              
0000735E  9D79 00008000           3826      SUB.W  D6,$8000              
00007364                          3827      
00007364  9080                    3828      SUB.L  D0,D0                  
00007366  9288                    3829      SUB.L  A0,D1                 
00007368  9491                    3830      SUB.L  (A1),D2               
0000736A  969A                    3831      SUB.L  (A2)+,D3               
0000736C  98A3                    3832      SUB.L  -(A3),D4              
0000736E  9AB8 4000               3833      SUB.L  $4000,D5              
00007372  9CB9 0000A000           3834      SUB.L  $A000,D6               
00007378  9280                    3835      SUB.L  D0,D1                    
0000737A  9593                    3836      SUB.L  D2,(A3)               
0000737C  979C                    3837      SUB.L  D3,(A4)+              
0000737E  99A5                    3838      SUB.L  D4,-(A5)              
00007380  9BB8 6000               3839      SUB.L  D5,$6000              
00007384  9DB9 00008000           3840      SUB.L  D6,$8000    
0000738A                          3841      
0000738A                          3842      *SUBI
0000738A  0400 0012               3843      SUBI.B  #$12,D0
0000738E  0461 1234               3844      SUBI.W  #$1234,-(A1)
00007392  04B8 1234AAAA 1234      3845      SUBI.L  #$1234AAAA,$1234
0000739A  04B9 1234AAAA 1234AAAA  3846      SUBI.L  #$1234AAAA,$1234AAAA
000073A4                          3847  
000073A4                          3848      *MULS
000073A4  C1C0                    3849      MULS  D0,D0                                 
000073A6  C5D1                    3850      MULS  (A1),D2               
000073A8  C7DA                    3851      MULS  (A2)+,D3               
000073AA  C9E3                    3852      MULS  -(A3),D4              
000073AC  CBF8 4000               3853      MULS  $4000,D5              
000073B0  CDF9 0000A000           3854      MULS  $A000,D6              
000073B6  CFFC 0070               3855      MULS  #$70,D7                
000073BA  C1FC 7000               3856      MULS  #$7000,D0          
000073BE                          3857  
000073BE                          3858      *DIVU
000073BE  80C0                    3859      DIVU  D0,D0                                 
000073C0  84D1                    3860      DIVU  (A1),D2               
000073C2  86DA                    3861      DIVU  (A2)+,D3               
000073C4  88E3                    3862      DIVU  -(A3),D4              
000073C6  8AF8 4000               3863      DIVU  $4000,D5              
000073CA  8CF9 0000A000           3864      DIVU  $A000,D6              
000073D0  8EFC 0070               3865      DIVU  #$70,D7                
000073D4  80FC 7000               3866      DIVU  #$7000,D0   
000073D8                          3867           
000073D8                          3868      *LEA                  
000073D8  45D1                    3869      LEA (A1),A2                            
000073DA  4BF8 4000               3870      LEA $4000,A5               
000073DE  4DF9 0000A000           3871      LEA $A000,A6         
000073E4                          3872      
000073E4                          3873      *AND
000073E4  C000                    3874      AND.B  D0,D0                 
000073E6  C411                    3875      AND.B  (A1),D2                
000073E8  C61A                    3876      AND.B  (A2)+,D3              
000073EA  C823                    3877      AND.B  -(A3),D4               
000073EC  CA38 4000               3878      AND.B  $4000,D5              
000073F0  CC39 0000A000           3879      AND.B  $A000,D6               
000073F6  CE3C 0070               3880      AND.B  #$70,D7               
000073FA  C200                    3881      AND.B  D0,D1                 
000073FC  C513                    3882      AND.B  D2,(A3)                
000073FE  C71C                    3883      AND.B  D3,(A4)+               
00007400  C925                    3884      AND.B  D4,-(A5)               
00007402  CB38 6000               3885      AND.B  D5,$6000              
00007406  CD39 00008000           3886      AND.B  D6,$8000              
0000740C  C040                    3887      AND.W  D0,D0                                 
0000740E  C451                    3888      AND.W  (A1),D2                
00007410  C65A                    3889      AND.W  (A2)+,D3               
00007412  C863                    3890      AND.W  -(A3),D4               
00007414  CA78 4000               3891      AND.W  $4000,D5               
00007418  CC79 0000A000           3892      AND.W  $A000,D6               
0000741E  CE7C 0070               3893      AND.W  #$70,D7               
00007422  C07C 7000               3894      AND.W  #$7000,D0              
00007426  C240                    3895      AND.W  D0,D1                                 
00007428  C553                    3896      AND.W  D2,(A3)               
0000742A  C75C                    3897      AND.W  D3,(A4)+               
0000742C  C965                    3898      AND.W  D4,-(A5)              
0000742E  CB78 6000               3899      AND.W  D5,$6000              
00007432  CD79 00008000           3900      AND.W  D6,$8000              
00007438  C080                    3901      AND.L  D0,D0                                
0000743A  C491                    3902      AND.L  (A1),D2               
0000743C  C69A                    3903      AND.L  (A2)+,D3               
0000743E  C8A3                    3904      AND.L  -(A3),D4              
00007440  CAB8 4000               3905      AND.L  $4000,D5              
00007444  CCB9 0000A000           3906      AND.L  $A000,D6              
0000744A  CEBC 00000070           3907      AND.L  #$70,D7                
00007450  C0BC 00007000           3908      AND.L  #$7000,D0              
00007456  C2BC 70000000           3909      AND.L  #$70000000,D1         
0000745C  C280                    3910      AND.L  D0,D1                                  
0000745E  C593                    3911      AND.L  D2,(A3)               
00007460  C79C                    3912      AND.L  D3,(A4)+              
00007462  C9A5                    3913      AND.L  D4,-(A5)              
00007464  CBB8 6000               3914      AND.L  D5,$6000              
00007468  CDB9 00008000           3915      AND.L  D6,$8000
0000746E                          3916      
0000746E                          3917      *OR
0000746E  8000                    3918      OR.B  D0,D0                 
00007470  8411                    3919      OR.B  (A1),D2                
00007472  861A                    3920      OR.B  (A2)+,D3              
00007474  8823                    3921      OR.B  -(A3),D4               
00007476  8A38 4000               3922      OR.B  $4000,D5              
0000747A  8C39 0000A000           3923      OR.B  $A000,D6               
00007480  8E3C 0070               3924      OR.B  #$70,D7               
00007484  8200                    3925      OR.B  D0,D1                 
00007486  8513                    3926      OR.B  D2,(A3)                
00007488  871C                    3927      OR.B  D3,(A4)+               
0000748A  8925                    3928      OR.B  D4,-(A5)               
0000748C  8B38 6000               3929      OR.B  D5,$6000              
00007490  8D39 00008000           3930      OR.B  D6,$8000              
00007496  8040                    3931      OR.W  D0,D0                                
00007498  8451                    3932      OR.W  (A1),D2                
0000749A  865A                    3933      OR.W  (A2)+,D3               
0000749C  8863                    3934      OR.W  -(A3),D4               
0000749E  8A78 4000               3935      OR.W  $4000,D5               
000074A2  8C79 0000A000           3936      OR.W  $A000,D6               
000074A8  8E7C 0070               3937      OR.W  #$70,D7               
000074AC  807C 7000               3938      OR.W  #$7000,D0              
000074B0  8240                    3939      OR.W  D0,D1                              
000074B2  8553                    3940      OR.W  D2,(A3)               
000074B4  875C                    3941      OR.W  D3,(A4)+               
000074B6  8965                    3942      OR.W  D4,-(A5)              
000074B8  8B78 6000               3943      OR.W  D5,$6000              
000074BC  8D79 00008000           3944      OR.W  D6,$8000              
000074C2  8080                    3945      OR.L  D0,D0                                  
000074C4  8491                    3946      OR.L  (A1),D2               
000074C6  869A                    3947      OR.L  (A2)+,D3               
000074C8  88A3                    3948      OR.L  -(A3),D4              
000074CA  8AB8 4000               3949      OR.L  $4000,D5              
000074CE  8CB9 0000A000           3950      OR.L  $A000,D6              
000074D4  8EBC 00000070           3951      OR.L  #$70,D7                
000074DA  80BC 00007000           3952      OR.L  #$7000,D0              
000074E0  82BC 70000000           3953      OR.L  #$70000000,D1         
000074E6  8280                    3954      OR.L  D0,D1                             
000074E8  8593                    3955      OR.L  D2,(A3)               
000074EA  879C                    3956      OR.L  D3,(A4)+              
000074EC  89A5                    3957      OR.L  D4,-(A5)              
000074EE  8BB8 6000               3958      OR.L  D5,$6000              
000074F2  8DB9 00008000           3959      OR.L  D6,$8000             
000074F8                          3960      
000074F8                          3961      *ASL/ASR
000074F8  E1D0                    3962      ASL     (A0)
000074FA  E0D9                    3963      ASR     (A1)+
000074FC  E1E2                    3964      ASL     -(A2)
000074FE  E0F8 4000               3965      ASR     $4000
00007502  E1F9 0000A000           3966      ASL     $A000
00007508  EF00                    3967      ASL.B   #$7,D0
0000750A  E141                    3968      ASL.W   #$8,D1
0000750C  E7A2                    3969      ASL.L   D3,D2
0000750E                          3970      
0000750E                          3971      *LSL/LSR
0000750E  E3D3                    3972      LSL     (A3)
00007510  E2DC                    3973      LSR     (A4)+
00007512  E3E5                    3974      LSL     -(A5)
00007514  E2F8 4000               3975      LSR     $4000
00007518  E3F9 0000A000           3976      LSL     $A000
0000751E  EF08                    3977      LSL.B   #$7,D0
00007520  E149                    3978      LSL.W   #$8,D1
00007522  EBA9                    3979      LSL.L   D5,D1
00007524                          3980      
00007524                          3981      *ROL/ROR
00007524  E7D6                    3982      ROL     (A6)
00007526  E6D8                    3983      ROR     (A0)+
00007528  E7E1                    3984      ROL     -(A1)
0000752A  E6F8 4000               3985      ROR     $4000
0000752E  E7F9 0000A000           3986      ROL     $A000
00007534  EF18                    3987      ROL.B    #$7,D0
00007536  E159                    3988      ROL.W    #$8,D1
00007538  EFB9                    3989      ROL.L    D7,D1
0000753A                          3990      
0000753A                          3991      *Bcc
0000753A  6400 001E               3992      BCC     FARGONE
0000753E  6D00 001A               3993      BLT     FARGONE
00007542  6C00 0016               3994      BGE     FARGONE
00007546  6000 0012               3995      BRA     FARGONE
0000754A                          3996      
0000754A                          3997      *JSR
0000754A  4EB9 0000755A           3998      JSR     FARGONE
00007550  4EB9 0000A000           3999      JSR     $A000
00007556  4EB8 4000               4000      JSR     $4000
0000755A                          4001      
0000755A                          4002      *RTS
0000755A  4E75                    4003  FARGONE    RTS
0000755C                          4004      
0000755C                          4005  
0000755C                          4006      
0000755C                          4007  
0000755C                          4008  
0000755C                          4009  
0000755C                          4010  
0000755C                          4011  
0000755C                          4012  
0000755C                          4013  
0000755C                          4014  
0000755C                          4015  
0000755C                          4016  
0000755C                          4017  
0000755C                          4018  
0000755C                          4019  
0000755C                          4020  
0000755C                          4021  
0000755C                          4022  
0000755C                          4023  
0000755C                          4024  -------------------- end include --------------------
0000755C                          4025                  
0000755C= 57 65 6C 63 6F 6D ...   4026  WELCOME_MSG          dc.b    'Welcome to the MC68000 Microprocessor Disassembler',CR,LF,0   
00007591= 50 6C 65 61 73 65 ...   4027  START_ADD_MSG        dc.b    'Please enter Start memory address in hexadecimal: ',0
000075C4= 50 6C 65 61 73 65 ...   4028  END_ADD_MSG          dc.b    'Please enter End address in hexadecimal(greater than start address): ',0
0000760A= 45 52 52 4F 52 3A ...   4029  INPUT_ERROR_MSG      dc.b    'ERROR: Invalid address entered. Please try again.',CR,LF,0
0000763E= 45 52 52 4F 52 3A ...   4030  END_ADD_SMALLER_MSG  dc.b    'ERROR: End address can not be less than starting address',CR,LF,0
00007679= 45 52 52 4F 52 3A ...   4031  ADDR_BELOW_MSG       dc.b    'ERROR: Address below minimum. enter address greater than or equal to $7000',CR,LF,0
000076C6= 45 52 52 4F 52 3A ...   4032  ADDR_ABOVE_MSG       dc.b    'ERROR: Address above maximum. enter address less than or equal to $00FFFFFE',CR,LF,0
00007714= 45 52 52 4F 52 3A ...   4033  EVEN_CHECK_MSG        dc.b    'ERROR: odd address entered. please enter even address',CR,LF,0       
0000774C                          4034  IN_START_A           ds.b    4        allocate 4 bytes of memory to store starting memory address input  
00007750                          4035  IN_CURR_A         ds.b    4        allocate 4 bytes of memory to store current memory address
00007754                          4036  IN_END_A             ds.b    4        allocate 4 bytes of memory to store ending memory address input
00007758                          4037  OUT_START_A          ds.b    4         allocate 4 bytes of memory to store starting program output
0000775C                          4038  OUT_CURR_A          ds.b    4         allocate 4 bytes of memory to store current program output
00007760                          4039  IS_VALID            ds.b    1         allocate a byte for whether for error checking
00007761                          4040  SIZE_BUFFER         ds.b    1         allocate a byte for the current size of the op-code
00007762                          4041        
00007762                          4042  
00007762                          4043      INCLUDE 'CONSTANTS.X68'
00007762                          4044  
00007762  =00000020               4045  INSTRUCTIONS_PER_SCREEN   EQU   32
00007762                          4046  
00007762                          4047  PRINT_NUM_STACK DS.B  8
0000776A                          4048  
0000776A= 44 41 54 41 09 24 00    4049  BAD_COMMAND_STR DC.B  'DATA',$09,'$',0
00007771                          4050  
00007771= 4E 4F 50 0A 0D 00       4051  NOP_STR DC.B  'NOP',$0A,$0D,0
00007777  =00004E71               4052  NOP_S   EQU   $4E71
00007777  =0000FFFF               4053  NOP_P   EQU   $FFFF
00007777                          4054  
00007777= 4D 4F 56 45 41 00       4055  MOVEA_STR  DC.B  'MOVEA',0
0000777D  =00000040               4056  MOVEA_S    EQU   $0040
0000777D  =0000C1C0               4057  MOVEA_P    EQU   $C1C0
0000777D                          4058  
0000777D= 4D 4F 56 45 00          4059  MOVE_STR   DC.B  'MOVE',0
00007782  =00000000               4060  MOVE_S     EQU   $0000
00007782  =0000C000               4061  MOVE_P     EQU   $C000
00007782                          4062  
00007782= 52 54 53 00             4063  RTS_STR    DC.B  'RTS',0
00007786  =00004E75               4064  RTS_S      EQU   $4E75
00007786  =0000FFFF               4065  RTS_P      EQU   $FFFF
00007786                          4066  
00007786= 4A 53 52 00             4067  JSR_STR    DC.B  'JSR',0
0000778A  =00004E80               4068  JSR_S      EQU   $4E80
0000778A  =0000FFC0               4069  JSR_P      EQU   $FFC0
0000778A                          4070  
0000778A= 4D 4F 56 45 4D 00       4071  MOVEM_STR  DC.B  'MOVEM',0
00007790  =00004880               4072  MOVEM_S    EQU   $4880
00007790  =0000FB80               4073  MOVEM_P    EQU   $FB80
00007790                          4074  
00007790= 4C 45 41 00             4075  LEA_STR    DC.B   'LEA',0
00007794  =000041C0               4076  LEA_S      EQU    $41C0
00007794  =0000F1C0               4077  LEA_P      EQU    $F1C0
00007794                          4078  
00007794= 42 52 41 09 24 00       4079  BRA_STR    DC.B  'BRA',$09,'$',0
0000779A  =00006000               4080  BRA_S      EQU   $6000
0000779A  =0000FF00               4081  BRA_P      EQU   $FF00
0000779A                          4082  
0000779A= 4D 4F 56 45 51 00       4083  MOVEQ_STR  DC.B  'MOVEQ',0
000077A0  =00007000               4084  MOVEQ_S    EQU   $7000
000077A0  =0000F100               4085  MOVEQ_P    EQU   $F100
000077A0                          4086  
000077A0= 41 44 44 00             4087  ADD_STR    DC.B  'ADD',0
000077A4  =0000D000               4088  ADD_S      EQU   $D000
000077A4  =0000F000               4089  ADD_P      EQU   $F000
000077A4                          4090  
000077A4= 41 44 44 41 00          4091  ADDA_STR   DC.B  'ADDA',0
000077A9  =0000D0C0               4092  ADDA_S     EQU   $D0C0
000077A9  =0000F0C0               4093  ADDA_P     EQU   $F0C0
000077A9                          4094  
000077A9= 41 44 44 49 00          4095  ADDI_STR   DC.B  'ADDI',0
000077AE  =00000600               4096  ADDI_S     EQU   $0600
000077AE  =0000FF00               4097  ADDI_P     EQU   $FF00
000077AE                          4098  
000077AE= 41 44 44 51 00          4099  ADDQ_STR   DC.B  'ADDQ',0
000077B3  =00005000               4100  ADDQ_S     EQU   $5000
000077B3  =0000F100               4101  ADDQ_P     EQU   $F100
000077B3                          4102  
000077B3= 53 55 42 00             4103  SUB_STR    DC.B  'SUB',0
000077B7  =00009000               4104  SUB_S      EQU   $9000
000077B7  =0000F000               4105  SUB_P      EQU   $F000
000077B7                          4106  
000077B7= 53 55 42 49 00          4107  SUBI_STR   DC.B  'SUBI',0
000077BC  =00000400               4108  SUBI_S     EQU   $0400
000077BC  =0000FF00               4109  SUBI_P     EQU   $FF00
000077BC                          4110  
000077BC= 4D 55 4C 53 2E 57 00    4111  MULS_STR   DC.B  'MULS.W',0
000077C3  =0000C1C0               4112  MULS_S     EQU   $C1C0
000077C3  =0000F1C0               4113  MULS_P     EQU   $F1C0
000077C3                          4114  
000077C3= 44 49 56 55 2E 57 00    4115  DIVU_STR   DC.B  'DIVU.W',0
000077CA  =000080C0               4116  DIVU_S     EQU   $80C0
000077CA  =0000F1C0               4117  DIVU_P     EQU   $F1C0
000077CA                          4118  
000077CA= 41 4E 44 00             4119  AND_STR    DC.B  'AND',0
000077CE  =0000C000               4120  AND_S      EQU   $C000
000077CE  =0000F000               4121  AND_P      EQU   $F000
000077CE                          4122  
000077CE= 4F 52 00                4123  OR_STR     DC.B  'OR',0
000077D1  =00008000               4124  OR_S       EQU   $8000
000077D1  =0000F000               4125  OR_P       EQU   $F000
000077D1                          4126  
000077D1= 42 43 43 09 24 00       4127  BCC_STR DC.B    'BCC',$09,'$',0
000077D7  =00006400               4128  BCC_S   EQU     $6400
000077D7  =0000FF00               4129  BCC_P   EQU     $FF00
000077D7                          4130  
000077D7= 42 47 45 09 24 00       4131  BGE_STR DC.B    'BGE',$09,'$',0
000077DD  =00006C00               4132  BGE_S   EQU     $6C00
000077DD  =0000FF00               4133  BGE_P   EQU     $FF00
000077DD                          4134  
000077DD= 42 4C 54 09 24 00       4135  BLT_STR DC.B    'BLT',$09,'$',0
000077E3  =00006D00               4136  BLT_S   EQU     $6D00
000077E3  =0000FF00               4137  BLT_P   EQU     $FF00
000077E3                          4138  
000077E3                          4139  
000077E3= 52 4F 4C 00             4140  ROL_STR DC.B    'ROL',0
000077E7  =0000E118               4141  ROL_S   EQU     $E118
000077E7  =0000F118               4142  ROL_P   EQU     $F118
000077E7  =0000E7C0               4143  ROLM_S   EQU     $E7C0
000077E7  =0000FFC0               4144  ROLM_P   EQU     $FFC0
000077E7                          4145  
000077E7= 52 4F 52 00             4146  ROR_STR DC.B    'ROR',0
000077EB  =0000E018               4147  ROR_S   EQU     $E018
000077EB  =0000F118               4148  ROR_P   EQU     $F118
000077EB  =0000E6C0               4149  RORM_S   EQU     $E6C0
000077EB  =0000FFC0               4150  RORM_P   EQU     $FFC0
000077EB                          4151  
000077EB= 41 53 4C 00             4152  ASL_STR DC.B    'ASL',0
000077EF  =0000E100               4153  ASL_S   EQU     $E100
000077EF  =0000E118               4154  ASL_P   EQU     $E118
000077EF  =0000E1C0               4155  ASLM_S   EQU     $E1C0
000077EF  =0000FFC0               4156  ASLM_P   EQU     $FFC0
000077EF                          4157  
000077EF= 41 53 52 00             4158  ASR_STR DC.B    'ASR',0
000077F3  =0000E000               4159  ASR_S   EQU     $E000
000077F3  =0000E118               4160  ASR_P   EQU     $E118
000077F3  =0000E0C0               4161  ASRM_S   EQU     $E0C0
000077F3  =0000FFC0               4162  ASRM_P   EQU     $FFC0
000077F3                          4163  
000077F3= 4C 53 4C 00             4164  LSL_STR DC.B    'LSL',0
000077F7  =0000E108               4165  LSL_S   EQU     $E108
000077F7  =0000E118               4166  LSL_P   EQU     $E118
000077F7  =0000E3C0               4167  LSLM_S   EQU     $E3C0
000077F7  =0000FFC0               4168  LSLM_P   EQU     $FFC0
000077F7                          4169  
000077F7= 4C 53 52 00             4170  LSR_STR DC.B    'LSR',0
000077FB  =0000E008               4171  LSR_S   EQU     $E008
000077FB  =0000E118               4172  LSR_P   EQU     $E118
000077FB  =0000E2C0               4173  LSRM_S   EQU     $E2C0
000077FB  =0000FFC0               4174  LSRM_P   EQU     $FFC0
000077FB                          4175  
000077FB                          4176  
000077FB                          4177  
000077FB                          4178  
000077FB                          4179  -------------------- end include --------------------
000077FB                          4180  
000077FB                          4181          
000077FB                          4182  
000077FB                          4183       *SIMHALT             ; halt simulator
000077FB                          4184       
000077FB                          4185  
000077FB                          4186      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABOVE_MAX_ERROR     1200
ADDA_AONE           29E6
ADDA_COPY           29DC
ADDA_EA_TO_AN       2A40
ADDA_END            2A26
ADDA_LONG_AN        2A0C
ADDA_P              F0C0
ADDA_PRINT_SIZE_DONE  2A1C
ADDA_S              D0C0
ADDA_STR            77A4
ADDA_SUB            29B8
ADDA_WORD_AN        29FC
ADDI_BYTE_DN        1D4C
ADDI_BYTE_EA        1D70
ADDI_COPY           1D06
ADDI_DONE           1D10
ADDI_EA_TO_DN       1E12
ADDI_END            1DF8
ADDI_LONG_DN        1D64
ADDI_LONG_EA        1D88
ADDI_P              FF00
ADDI_PARAM_DONE     1D94
ADDI_PRINT_ADDR_DONE  1DF0
ADDI_PRINT_ADDR_LONG  1E48
ADDI_PRINT_ADDR_WORD  1E30
ADDI_PRINT_AL       1DEA
ADDI_PRINT_SIZE_BYTE  1DB4
ADDI_PRINT_SIZE_DONE  1DCC
ADDI_PRINT_SIZE_LONG  1DC4
ADDI_PRINT_SIZE_WORD  1DBC
ADDI_S              600
ADDI_STR            77A9
ADDI_SUB            1CE2
ADDI_WORD_DN        1D58
ADDI_WORD_EA        1D7C
ADDQ_BYTE_DN        2284
ADDQ_BYTE_EA        22A8
ADDQ_COPY           223E
ADDQ_DONE           2248
ADDQ_END            231E
ADDQ_LONG_DN        229C
ADDQ_LONG_EA        22C0
ADDQ_P              F100
ADDQ_PARAM_DONE     22CC
ADDQ_PRINT_NUM      2338
ADDQ_PRINT_SIZE_BYTE  22EC
ADDQ_PRINT_SIZE_DONE  2304
ADDQ_PRINT_SIZE_LONG  22FC
ADDQ_PRINT_SIZE_WORD  22F4
ADDQ_S              5000
ADDQ_STR            77AE
ADDQ_SUB            221A
ADDQ_WORD_DN        2290
ADDQ_WORD_EA        22B4
ADDQ_ZERO_IS_EIGHT  2350
ADDR_ABOVE_MSG      76C6
ADDR_BELOW_MSG      7679
ADD_COPY            28EE
ADD_DN              2934
ADD_DN_TO_EA        299A
ADD_DONE            28F8
ADD_EA              293C
ADD_EA_DN           295C
ADD_EA_TO_DN        297C
ADD_END             2962
ADD_P               F000
ADD_PARAM_DONE      2944
ADD_S               D000
ADD_STR             77A0
ADD_SUB             28CA
ALPHA_TO_HEX        11B0
AND_COPY            2712
AND_DN              2758
AND_DN_TO_EA        27BE
AND_DONE            271C
AND_EA              2760
AND_EA_DN           2780
AND_EA_TO_DN        27A0
AND_END             2786
AND_P               F000
AND_PARAM_DONE      2768
AND_S               C000
AND_STR             77CA
AND_SUB             26EE
ASLM_P              FFC0
ASLM_S              E1C0
ASL_COPY            2A82
ASL_P               E118
ASL_S               E100
ASL_STR             77EB
ASL_SUB             2A5E
ASRM_P              FFC0
ASRM_S              E0C0
ASR_COPY            2AB0
ASR_P               E118
ASR_S               E000
ASR_STR             77EF
ASR_SUB             2A8C
BAD_COMMAND_STR     776A
BAD_COMMAND_SUB     1AB8
BCC_COPY            23FE
BCC_P               FF00
BCC_S               6400
BCC_STR             77D1
BCC_SUB             23D6
BCMD_COPY           1AE4
BCMD_DONE           1AEE
BELOW_MIN_ERROR     11F2
BGE_COPY            242E
BGE_P               FF00
BGE_S               6C00
BGE_STR             77D7
BGE_SUB             2406
BLT_COPY            2460
BLT_P               FF00
BLT_S               6D00
BLT_STR             77DD
BLT_SUB             2438
BRA_COPY            2388
BRA_DONE            2392
BRA_FINISH          23A8
BRA_GETWORD         23CC
BRA_P               FF00
BRA_S               6000
BRA_STR             7794
BRA_SUB             2360
CK_INPUT_SIZE       115C
CMD_CHECK           16C2
CMD_IDENTIFY        122C
CNV_LOOP            1196
CONTINUE_END1       1088
CONTINUE_END2       109E
CONTINUE_START1     1038
CONTINUE_START2     104E
CONVERT             1194
CR                  D
DIGIT_TO_ASCII      1B48
DIGIT_TO_HEX        11B8
DIVU_COPY           2516
DIVU_P              F1C0
DIVU_S              80C0
DIVU_STR            77C3
DIVU_SUB            24F2
END_ADD_MSG         75C4
END_ADD_SMALLER_MSG  763E
END_IDENTIFY        16BC
END_MAIN_LOOP       10F4
EVEN                121A
EVEN_CHECK          120E
EVEN_CHECK_MSG      7714
FARGONE             755A
FINAL_PRINT_LOOP    1108
FINAL_PRINT_LOOP_END  1158
FINAL_PRINT_LOOP_NEWLINE  1136
FINAL_PRINT_LOOP_SKIP  1120
FINAL_PRINT_LOOP_WAIT  1148
FINISH              11AE
INPUT_ERROR_MSG     760A
INPUT_ODD           1220
INSTRUCTIONS_PER_SCREEN  20
INVALID_INP_ED      1184
INVALID_INP_ST      1174
IN_CURR_A           7750
IN_END_A            7754
IN_START_A          774C
IS_VALID            7760
JSR_ABSL            1FDE
JSR_ABSW            1FF0
JSR_CONVERT         2024
JSR_COPY            1FBC
JSR_DIGIT           2032
JSR_DONE            1FC6
JSR_FINISH          2038
JSR_GETBYTE         2002
JSR_P               FFC0
JSR_S               4E80
JSR_STR             7786
JSR_SUB             1F98
KEEP_COUNT          11C0
LEA_COPY            21D4
LEA_DONE            21DE
LEA_P               F1C0
LEA_S               41C0
LEA_STR             7790
LEA_SUB             21B0
LF                  A
LSLM_P              FFC0
LSLM_S              E3C0
LSL_COPY            2ADE
LSL_P               E118
LSL_S               E108
LSL_STR             77F3
LSL_SUB             2ABA
LSRM_P              FFC0
LSRM_S              E2C0
LSR_COPY            2B0C
LSR_P               E118
LSR_S               E008
LSR_STR             77F7
LSR_SUB             2AE8
MAIN                7000
MAIN_LOOP           10DA
MIN_MAX_CHECK       11D2
MOVEA_COPY          1E84
MOVEA_DONE          1E8E
MOVEA_P             C1C0
MOVEA_S             40
MOVEA_STR           7777
MOVEA_SUB           1E60
MOVEM_COPY          2076
MOVEM_DIRECTION     209E
MOVEM_DONE          2080
MOVEM_END           20C2
MOVEM_MEM_TO_REG    2146
MOVEM_MEM_TO_REG_A_DONE  217E
MOVEM_MEM_TO_REG_A_LOOP  2154
MOVEM_MEM_TO_REG_A_SKIP  2176
MOVEM_MEM_TO_REG_D_DONE  21AA
MOVEM_MEM_TO_REG_D_LOOP  2182
MOVEM_MEM_TO_REG_D_SKIP  21A2
MOVEM_P             FB80
MOVEM_REG_TO_MEM    20DC
MOVEM_REG_TO_MEM_A_DONE  2138
MOVEM_REG_TO_MEM_A_LOOP  2110
MOVEM_REG_TO_MEM_A_SKIP  2130
MOVEM_REG_TO_MEM_D_DONE  210C
MOVEM_REG_TO_MEM_D_LOOP  20E2
MOVEM_REG_TO_MEM_D_SKIP  2104
MOVEM_RTM           20BC
MOVEM_S             4880
MOVEM_SIZE_W        209A
MOVEM_STR           778A
MOVEM_SUB           2052
MOVEQ_COPY          248E
MOVEQ_DONE          2498
MOVEQ_P             F100
MOVEQ_S             7000
MOVEQ_STR           779A
MOVEQ_SUB           246A
MOVE_COPY           1EDC
MOVE_DONE           1EE6
MOVE_P              C000
MOVE_S              0
MOVE_STR            777D
MOVE_SUB            1EB8
MULS_COPY           269E
MULS_DONE           26A8
MULS_P              F1C0
MULS_S              C1C0
MULS_STR            77BC
MULS_SUB            267A
NAN                 1B5E
NEGATIVE            16DA
NOP_COPY            1F34
NOP_DONE            1F3E
NOP_P               FFFF
NOP_S               4E71
NOP_STR             7771
NOP_SUB             1F10
OR_COPY             2800
OR_DN               2846
OR_DN_TO_EA         28AC
OR_DONE             280A
OR_EA               284E
OR_EA_DN            286E
OR_EA_TO_DN         288E
OR_END              2874
OR_P                F000
OR_PARAM_DONE       2856
OR_S                8000
OR_STR              77CE
OR_SUB              27DC
OUT_CURR_A          775C
OUT_START_A         7758
PRINT_DEST_END      1928
PRINT_DEST_MEM      191E
PRINT_DEST_MEMORY   19AE
PRINT_DEST_MEMORY_ABS_L  19EC
PRINT_DEST_MEMORY_ABS_W  19D0
PRINT_DEST_MEMORY_IMM  1A06
PRINT_DEST_MEMORY_IMM_L  1A1E
PRINT_DEST_MEMORY_IMM_W  1A3C
PRINT_DEST_REGISTER  192E
PRINT_DEST_REGISTER_AN  196E
PRINT_DEST_REGISTER_ANMINUS  199A
PRINT_DEST_REGISTER_ANPAREN  1976
PRINT_DEST_REGISTER_ANPLUS  1986
PRINT_DEST_REGISTER_DN  1966
PRINT_DEST_SUB      18FC
PRINT_NUM           1A5C
PRINT_NUM_CONV      1AA4
PRINT_NUM_CONV_DIG  1AB2
PRINT_NUM_LOOP1     1A70
PRINT_NUM_LOOP1_END  1A8C
PRINT_NUM_LOOP2     1A8C
PRINT_NUM_LOOP2_END  1A98
PRINT_NUM_STACK     7762
PRINT_SIZE_EARLY_BYTE  1708
PRINT_SIZE_EARLY_END  1738
PRINT_SIZE_EARLY_LONG  1728
PRINT_SIZE_EARLY_SUB  16E0
PRINT_SIZE_EARLY_WORD  1718
PRINT_SIZE_LATE_BYTE  1768
PRINT_SIZE_LATE_END  1798
PRINT_SIZE_LATE_LONG  1788
PRINT_SIZE_LATE_SUB  1742
PRINT_SIZE_LATE_WORD  1778
PRINT_SOURCE_END    17D2
PRINT_SOURCE_MEM    17C8
PRINT_SOURCE_MEMORY  185A
PRINT_SOURCE_MEMORY_ABS_L  1894
PRINT_SOURCE_MEMORY_ABS_W  1878
PRINT_SOURCE_MEMORY_IMM  18AE
PRINT_SOURCE_MEMORY_IMM_L  18BE
PRINT_SOURCE_MEMORY_IMM_W  18DC
PRINT_SOURCE_REGISTER  17DE
PRINT_SOURCE_REGISTER_AN  181A
PRINT_SOURCE_REGISTER_ANMINUS  1846
PRINT_SOURCE_REGISTER_ANPAREN  1822
PRINT_SOURCE_REGISTER_ANPLUS  1832
PRINT_SOURCE_REGISTER_DN  1812
PRINT_SOURCE_SUB    17A2
RD_END_INPUT        105C
RD_START_INPUT      100C
ROLM_P              FFC0
ROLM_S              E7C0
ROL_COPY            2B3A
ROL_P               F118
ROL_S               E118
ROL_STR             77E3
ROL_SUB             2B16
RORM_P              FFC0
RORM_S              E6C0
ROR_COPY            2B68
ROR_DEST            2BC6
ROR_DONE            2B72
ROR_EA              2C24
ROR_EIGHT           2C1E
ROR_FIN             2BD8
ROR_IMM             2C04
ROR_P               F118
ROR_PRINT_SIZE_BYTE  2BF2
ROR_PRINT_SIZE_END  2B9E
ROR_PRINT_SIZE_LONG  2BFE
ROR_PRINT_SIZE_WORD  2BF8
ROR_S               E018
ROR_STR             77E7
ROR_SUB             2B44
RTS_COPY            1F74
RTS_DONE            1F7E
RTS_P               FFFF
RTS_S               4E75
RTS_STR             7782
RTS_SUB             1F50
SIZE_BUFFER         7761
START               1000
START_ADD_MSG       7591
SUBI_BYTE_DN        1BCE
SUBI_BYTE_EA        1BF2
SUBI_COPY           1B88
SUBI_DONE           1B92
SUBI_EA_TO_DN       1C94
SUBI_END            1C7A
SUBI_LONG_DN        1BE6
SUBI_LONG_EA        1C0A
SUBI_P              FF00
SUBI_PARAM_DONE     1C16
SUBI_PRINT_ADDR_DONE  1C72
SUBI_PRINT_ADDR_LONG  1CCA
SUBI_PRINT_ADDR_WORD  1CB2
SUBI_PRINT_AL       1C6C
SUBI_PRINT_SIZE_BYTE  1C36
SUBI_PRINT_SIZE_DONE  1C4E
SUBI_PRINT_SIZE_LONG  1C46
SUBI_PRINT_SIZE_WORD  1C3E
SUBI_S              400
SUBI_STR            77B7
SUBI_SUB            1B64
SUBI_WORD_DN        1BDA
SUBI_WORD_EA        1BFE
SUB_BYTE_DN         258A
SUB_BYTE_EA         25AE
SUB_COPY            2544
SUB_DN_TO_EA        265C
SUB_DONE            254E
SUB_EA_DN           261E
SUB_EA_TO_DN        263E
SUB_END             2624
SUB_LONG_DN         25A2
SUB_LONG_EA         25C6
SUB_P               F000
SUB_PARAM_DONE      25D2
SUB_PRINT_SIZE_BYTE  25F2
SUB_PRINT_SIZE_DONE  260A
SUB_PRINT_SIZE_LONG  2602
SUB_PRINT_SIZE_WORD  25FA
SUB_S               9000
SUB_STR             77B3
SUB_SUB             2520
SUB_WORD_DN         2596
SUB_WORD_EA         25BA
WELCOME_MSG         755C
