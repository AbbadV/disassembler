00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 4/24/2017 1:39:40 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : main.X68
00000000                             3  * Written by : bisrat belayneh
00000000                             4  * Date       : 4/21/2017
00000000                             5  * Description: Displays welcome, Gets start and end address of memo to be decoded ,Define Out-start-addres,
00000000                             6  *               defines valid-flag (1 for code valid 0 for code invalid),defines constants for start and end 
00000000                             7  *               address of the program ,Sets out current add to out -start- add, Starts id running instruction
00000000                             8  *-----------------------------------------------------------
00000000  =0000000D                  9  CR              EQU     $0D                 ASCII code for carriage return
00000000  =0000000A                 10  LF              EQU     $0A                 ASCII code  for line feed  
00000000                            11  
00001000                            12      ORG    $1000
00001000                            13  START:                  ; first instruction of program
00001000                            14  
00001000                            15  * Put program code here
00001000                            16  *----------------------code for output------------------------
00001000  43F9 0000148E             17                  LEA             welcome_msg,A1   ; load welcome msg to A1
00001006  303C 000E                 18                  Move.W          #14,D0           ; move 14 to D0   
0000100A  4E4F                      19                  Trap            #15              ; display the string at A1   
0000100C                            20  
0000100C                            21     
0000100C  13FC 0001 0000164C        22      MOVE.B      #1,IS_VALID ; at the beginning assume the code is valid
00001014                            23  
00001014  33FC 3000 00001642        24      MOVE.W      #$3000,IN_START_A
0000101C  33F9 00001642 00001644    25      MOVE.W      IN_START_A,IN_CURR_A
00001026  33FC 300A 00001646        26      MOVE.W      #$300A,IN_END_A
0000102E                            27  
0000102E  33FC 4000 00001648        28      MOVE.W      #$4000,OUT_START_A
00001036  33F9 00001648 0000164A    29      MOVE.W      OUT_START_A,OUT_CURR_A
00001040                            30  
00001040  31FC 23FC 3000            31      MOVE.W      #$23FC,$3000
00001046                            32      *MOVE.L      #$23CF1234,$3002
00001046  21FC 1234ABCD 3002        33      MOVE.L      #$1234ABCD,$3002
0000104E                            34      *MOVE.W      #$4E71,$3004
0000104E  21FC 0000FFFF 3006        35      MOVE.L      #$0000FFFF,$3006
00001056                            36  
00001056                            37  LOOP
00001056  4EB9 0000108A             38      JSR         CMD_IDENTIFY
0000105C  3239 00001644             39      MOVE.W      IN_CURR_A,D1
00001062  3439 00001646             40      MOVE.W      IN_END_A,D2
00001068  B242                      41      CMP.W       D2,D1
0000106A  6E00 0004                 42      BGT         END_LOOP
0000106E  60E6                      43      BRA         LOOP
00001070                            44  
00001070                            45  END_LOOP
00001070                            46  
00001070                            47      * add a 00 to the very end of the output
00001070  3279 0000164A             48      MOVEA.W   OUT_CURR_A,A1
00001076  12FC 0000                 49      MOVE.B    #0,(A1)+
0000107A                            50  
0000107A  3279 00001648             51      MOVEA.W   OUT_START_A,A1
00001080  103C 000D                 52      MOVE.B    #13,D0
00001084  4E4F                      53      TRAP      #15
00001086                            54  
00001086  FFFF FFFF                 55      SIMHALT             ; halt simulator
0000108A                            56  
0000108A                            57  * Put variables and constants here
0000108A                            58    * INCLUDE     'OPCODE_TEST.X68'
0000108A                            59      INCLUDE     'CmdIdentify.X68'
0000108A                            60  
0000108A                            61  CMD_IDENTIFY
0000108A                            62  
0000108A  48E7 FFFE                 63          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
0000108E                            64    
0000108E  227C 00000000             65          MOVEA.L   #0,A1
00001094  3279 00001644             66          MOVEA.W   IN_CURR_A,A1  ; A1 is a pointer to the current position
0000109A  3211                      67          MOVE.W    (A1),D1       ; D1 is the current opcode
0000109C                            68          
0000109C                            69          * check NOP
0000109C  3401                      70          MOVE.W    D1,D2        ; move the value into D2 for temp storage
0000109E  363C FFFF                 71          MOVE.W    #NOP_P,D3    ; move values into registers for CMD_CHECK
000010A2  383C 4E71                 72          MOVE.W    #NOP_S,D4  
000010A6  3A3C 11AA                 73          MOVE.W    #NOP_SUB,D5
000010AA  4EB9 000010E0             74          JSR       CMD_CHECK
000010B0  BC3C 0001                 75          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
000010B4  6700 0024                 76          BEQ       END_IDENTIFY  ; skip to the end if it's equal
000010B8                            77  
000010B8                            78          * check MOVE
000010B8  3401                      79          MOVE.W    D1,D2        ; move the value into D2 for temp storage
000010BA  363C C000                 80          MOVE.W    #MOVE_P,D3    ; move values into registers for CMD_CHECK
000010BE  383C 0000                 81          MOVE.W    #MOVE_S,D4  
000010C2  3A3C 11EA                 82          MOVE.W    #MOVE_SUB,D5
000010C6  4EB9 000010E0             83          JSR       CMD_CHECK
000010CC  BC3C 0001                 84          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
000010D0  6700 0008                 85          BEQ       END_IDENTIFY  ; skip to the end if it's equal
000010D4                            86          
000010D4                            87          * if we hit here it's not a valid command
000010D4  4EB9 000010FE             88          JSR       BAD_COMMAND_SUB
000010DA                            89  
000010DA                            90  END_IDENTIFY
000010DA                            91  
000010DA  4CDF 7FFF                 92          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
000010DE  4E75                      93          RTS       ; return
000010E0                            94  
000010E0                            95  
000010E0                            96  CMD_CHECK
000010E0  48E7 0040                 97          MOVEM.L   A1,-(SP)   ; A1 is the only thing we need to keep from the
000010E4                            98                               ; parent routine
000010E4                            99          
000010E4  1C3C 0000                100          MOVE.B    #0,D6      ; we're storing the answer in D6
000010E8                           101  
000010E8  C443                     102          AND.W     D3,D2      ; get rid of all the unimportant parts
000010EA  B444                     103          CMP.W     D4,D2      ; compare the result with the signature of the cmd
000010EC  6600 000A                104          BNE       NEGATIVE   ; if they don't match skip everything else
000010F0                           105  
000010F0  2245                     106          MOVEA.L   D5,A1
000010F2  4E91                     107          JSR       (A1)        ; jump to the subroutine at D5
000010F4  1C3C 0001                108          MOVE.B    #1,D6
000010F8                           109   
000010F8                           110  NEGATIVE
000010F8  4CDF 0200                111          MOVEM.L   (SP)+,A1
000010FC  4E75                     112          RTS
000010FE                           113  
000010FE                           114  
000010FE                           115          INCLUDE 'BAD_COMMAND.X68'
000010FE                           116  
000010FE                           117  BAD_COMMAND_SUB
000010FE  48E7 FFFE                118          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
00001102                           119  
00001102  227C 00000000            120          MOVEA.L   #0,A1             ; load the current opcode into a register
00001108  3279 00001644            121          MOVEA.W   IN_CURR_A,A1
0000110E  3219                     122          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
00001110                           123  
00001110  267C 00000000            124          MOVEA.L   #0,A3
00001116  3679 0000164A            125          MOVEA.W   OUT_CURR_A,A3 ; move the current output pointer to A3
0000111C  49F9 0000164D            126          LEA       BAD_COMMAND_STR,A4 ; move the to-be-printed string to A4
00001122                           127  
00001122                           128          * we need to append the string at NOP_STR to the output string
00001122                           129          * we do this char by char (byte by byte) until we see a NULL (0)
00001122                           130          * in NOP_STR
00001122                           131  
00001122                           132          * the code is invalid of we find a bad command
00001122  13FC 0000 0000164C       133          MOVE.B    #0,IS_VALID
0000112A                           134  
0000112A                           135  BCMD_COPY
0000112A  4A14                     136          TST.B     (A4)  ; test the contents of A4
0000112C  6700 0006                137          BEQ       BCMD_DONE  ; if we hit a 00, we're done copying
00001130                           138  
00001130  16DC                     139          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00001132  60F6                     140          BRA       BCMD_COPY     ; do it again
00001134                           141  
00001134                           142  BCMD_DONE
00001134                           143  
00001134                           144          * convert the opcode into ASCII
00001134                           145          * digit 1
00001134  3401                     146          MOVE.W    D1,D2
00001136  E04A                     147          LSR.W     #8,D2   ; get the first digit all on it's own
00001138  E84A                     148          LSR.W     #4,D2
0000113A  0242 000F                149          ANDI.W    #$F,D2
0000113E  4EB9 0000118E            150          JSR       DIGIT_TO_ASCII 
00001144  16C2                     151          MOVE.B    D2,(A3)+
00001146                           152  
00001146                           153          * digit 2
00001146  3401                     154          MOVE.W    D1,D2
00001148  E04A                     155          LSR.W     #8,D2   ; get the second digit all on it's own
0000114A  0242 000F                156          ANDI.W    #$F,D2
0000114E  4EB9 0000118E            157          JSR       DIGIT_TO_ASCII 
00001154  16C2                     158          MOVE.B    D2,(A3)+
00001156                           159  
00001156                           160          * digit 3
00001156  3401                     161          MOVE.W    D1,D2
00001158  E84A                     162          LSR.W     #4,D2   ; get the third digit all on it's own
0000115A  0242 000F                163          ANDI.W    #$F,D2
0000115E  4EB9 0000118E            164          JSR       DIGIT_TO_ASCII 
00001164  16C2                     165          MOVE.B    D2,(A3)+
00001166                           166  
00001166                           167          * digit 4
00001166  3401                     168          MOVE.W    D1,D2
00001168  0242 000F                169          ANDI.W    #$F,D2  ; get the last digit all on it's own
0000116C  4EB9 0000118E            170          JSR       DIGIT_TO_ASCII 
00001172  16C2                     171          MOVE.B    D2,(A3)+
00001174                           172  
00001174                           173          * newline
00001174  16FC 000A                174          MOVE.B    #$0A,(A3)+
00001178  16FC 000D                175          MOVE.B    #$0D,(A3)+
0000117C                           176  
0000117C  33C9 00001644            177          MOVE.W    A1,IN_CURR_A  ; move the current A1 back to the input pointer
00001182  33CB 0000164A            178          MOVE.W    A3,OUT_CURR_A ; move the current A3 back to the output pointer
00001188                           179  
00001188  4CDF 7FFF                180          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
0000118C  4E75                     181          RTS       ; return
0000118E                           182  
0000118E                           183  
0000118E                           184  DIGIT_TO_ASCII
0000118E                           185  
0000118E  B43C 0000                186          CMP.B   #0,D2
00001192  6D00 0010                187          BLT     NAN
00001196  B43C 0009                188          CMP.B   #9,D2
0000119A  6E00 0008                189          BGT     NAN
0000119E                           190  
0000119E  0602 0030                191          ADDI.B  #$30,D2
000011A2  4E75                     192          RTS
000011A4                           193  
000011A4                           194  NAN
000011A4  0602 0041                195          ADDI.B  #$41,D2
000011A8                           196  
000011A8  4E75                     197          RTS
000011AA                           198          
000011AA                           199  
000011AA                           200  -------------------- end include --------------------
000011AA                           201          INCLUDE 'NOP_SUB.X68'
000011AA                           202  
000011AA                           203  NOP_SUB
000011AA  48E7 FFFE                204          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
000011AE                           205  
000011AE  227C 00000000            206          MOVEA.L   #0,A1             ; load the current opcode into a register
000011B4  3279 00001644            207          MOVEA.W   IN_CURR_A,A1
000011BA  3219                     208          MOVE.W    (A1)+,D1          ; not necessary here, but for other cmds
000011BC                           209  
000011BC  267C 00000000            210          MOVEA.L   #0,A3
000011C2  3679 0000164A            211          MOVEA.W   OUT_CURR_A,A3 ; move the current output pointer to A3
000011C8  49F9 00001654            212          LEA       NOP_STR,A4     ; move the to-be-printed string to A4
000011CE                           213  
000011CE                           214          * we need to append the string at NOP_STR to the output string
000011CE                           215          * we do this char by char (byte by byte) until we see a NULL (0)
000011CE                           216          * in NOP_STR
000011CE                           217  
000011CE                           218  NOP_COPY
000011CE  4A14                     219          TST.B     (A4)      ; test the contents of A4
000011D0  6700 0006                220          BEQ       NOP_DONE  ; if we hit a 00, we're done copying
000011D4                           221  
000011D4  16DC                     222          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
000011D6  60F6                     223          BRA       NOP_COPY      ; do it again
000011D8                           224          
000011D8                           225  NOP_DONE
000011D8                           226  
000011D8  33C9 00001644            227          MOVE.W    A1,IN_CURR_A  ; move the current A1 back to the input pointer
000011DE  33CB 0000164A            228          MOVE.W    A3,OUT_CURR_A ; move the current A3 back to the output pointer
000011E4                           229  
000011E4  4CDF 7FFF                230          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
000011E8  4E75                     231          RTS       ; return
000011EA                           232  
000011EA                           233  
000011EA                           234  -------------------- end include --------------------
000011EA                           235          INCLUDE 'MOVE_SUB.X68'
000011EA                           236  
000011EA                           237  MOVE_SUB
000011EA  48E7 FFFE                238          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
000011EE                           239         
000011EE                           240  
000011EE                           241          * sets up the data registers
000011EE                           242          *
000011EE                           243          * A1 - the current opcode's address
000011EE                           244          * A3 - the current position of the output
000011EE                           245          * A4 - the location of the text for printing
000011EE                           246          *
000011EE                           247          *
000011EE                           248          * D1 - the actual opcode
000011EE                           249          *
000011EE  227C 00000000            250          MOVEA.L   #0,A1             ; load the current opcode into a register
000011F4  3279 00001644            251          MOVEA.W   IN_CURR_A,A1
000011FA                           252          
000011FA  3219                     253          MOVE.W    (A1)+,D1          ; ***move A1 to next command or to parameter
000011FC                           254  
000011FC  267C 00000000            255          MOVEA.L   #0,A3
00001202  3679 0000164A            256          MOVEA.W   OUT_CURR_A,A3 ; move the current output pointer to A3
00001208  49F9 0000165A            257          LEA       MOVE_STR,A4     ; move the to-be-printed string to A4
0000120E                           258  
0000120E                           259          * we need to append the string at ###_STR to the output string
0000120E                           260          * we do this char by char (byte by byte) until we see a NULL (0)
0000120E                           261          * in ###_STR
0000120E                           262  
0000120E                           263  MOVE_COPY
0000120E  4A14                     264          TST.B     (A4)      ; test the contents of A4
00001210  6700 0006                265          BEQ       MOVE_DONE  ; if we hit a 00, we're done copying
00001214                           266  
00001214  16DC                     267          MOVE.B    (A4)+,(A3)+   ; copy A4 into A3, then increment both
00001216  60F6                     268          BRA       MOVE_COPY      ; do it again
00001218                           269          
00001218                           270  MOVE_DONE
00001218                           271          
00001218                           272          *get operation size
00001218  343C 3000                273          MOVE.W  #$3000,D2
0000121C  C441                     274          AND.W   D1,D2
0000121E  B47C 1000                275          CMP.W   #$1000,D2
00001222  6700 023A                276          BEQ MOVE_B
00001226  B47C 3000                277          CMP.W   #$3000,D2
0000122A  6700 0242                278          BEQ MOVE_W
0000122E  B47C 2000                279          CMP.W   #$2000,D2
00001232  6700 024A                280          BEQ MOVE_L
00001236                           281          
00001236                           282  MOVE_XMODE  ;get source EA
00001236  343C 0038                283          MOVE.W  #$38,D2
0000123A  C441                     284          AND.W   D1,D2
0000123C  E60A                     285          LSR.B   #3,D2
0000123E  1E3C 0007                286          MOVE.B  #$7,D7
00001242  CE01                     287          AND.B   D1,D7
00001244                           288          
00001244  B43C 0000                289          CMP.B   #$0,D2
00001248  6700 0082                290          BEQ MOVE_DATA
0000124C  B43C 0001                291          CMP.B   #$1,D2
00001250  6700 0082                292          BEQ MOVE_ADD
00001254  B43C 0002                293          CMP.B   #$2,D2
00001258  6700 0082                294          BEQ MOVE_IADD
0000125C  B43C 0003                295          CMP.B   #$3,D2
00001260  6700 0082                296          BEQ MOVE_ADDP
00001264  B43C 0004                297          CMP.B   #$4,D2
00001268  6700 0082                298          BEQ MOVE_PADD
0000126C  B43C 0007                299          CMP.B   #$7,D2
00001270  6700 00A2                300          BEQ MOVE_GETEA
00001274                           301  
00001274                           302  
00001274                           303                
00001274                           304  MOVE_AMODE
00001274  16FC 002C                305          MOVE.B  #',',(A3)+
00001278                           306                 
00001278  343C 01C0                307          MOVE.W  #$1C0,D2
0000127C  C441                     308          AND.W   D1,D2
0000127E  EC8A                     309          LSR.L   #6,D2
00001280                           310          
00001280  3E3C 0E00                311          MOVE.W  #$E00,D7
00001284  CE41                     312          AND.W   D1,D7
00001286  E04F                     313          LSR.W   #8,D7
00001288  E24F                     314          LSR.W   #1,D7
0000128A                           315          
0000128A  B43C 0000                316          CMP.B   #$0,D2
0000128E  6700 0064                317          BEQ MOVE_ADATA
00001292  B43C 0002                318          CMP.B   #$2,D2
00001296  6700 0064                319          BEQ MOVE_AIADD
0000129A  B43C 0003                320          CMP.B   #$3,D2
0000129E  6700 0064                321          BEQ MOVE_AADDP
000012A2  B43C 0004                322          CMP.B   #$4,D2
000012A6  6700 0064                323          BEQ MOVE_APADD
000012AA  B43C 0007                324          CMP.B   #$7,D2
000012AE  6700 011A                325          BEQ MOVE_AGETEA
000012B2                           326          
000012B2                           327   
000012B2                           328  
000012B2                           329  MOVE_FIN 
000012B2  16FC 000A                330          MOVE.B  #$A,(A3)+
000012B6  16FC 000D                331          MOVE.B  #$D,(A3)+       
000012BA  33C9 00001644            332          MOVE.W    A1,IN_CURR_A  ; move the current A1 back to the input pointer
000012C0  33CB 0000164A            333          MOVE.W    A3,OUT_CURR_A ; move the current A3 back to the output pointer
000012C6                           334  
000012C6  4CDF 7FFF                335          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
000012CA  4E75                     336          RTS       ; return
000012CC                           337  
000012CC                           338  MOVE_DATA
000012CC  4EB9 0000140C            339      JSR PRINTDN
000012D2  60A0                     340      BRA MOVE_AMODE
000012D4                           341  MOVE_ADD
000012D4  4EB9 00001416            342      JSR PRINTAN
000012DA  6098                     343      BRA MOVE_AMODE
000012DC                           344  MOVE_IADD
000012DC  4EB9 00001420            345      JSR PRINTIAN
000012E2  6090                     346      BRA MOVE_AMODE
000012E4                           347  MOVE_ADDP
000012E4  4EB9 00001432            348      JSR PRINTAP
000012EA  6088                     349      BRA MOVE_AMODE
000012EC                           350  MOVE_PADD
000012EC  4EB9 00001448            351      JSR PRINTPA
000012F2  6080                     352      BRA MOVE_AMODE
000012F4                           353  MOVE_ADATA
000012F4  4EB9 0000140C            354      JSR PRINTDN
000012FA  60B6                     355      BRA MOVE_FIN
000012FC                           356  MOVE_AIADD
000012FC  4EB9 00001420            357      JSR PRINTIAN
00001302  60AE                     358      BRA MOVE_FIN
00001304                           359  MOVE_AADDP
00001304  4EB9 00001432            360      JSR PRINTAP
0000130A  60A6                     361      BRA MOVE_FIN
0000130C                           362  MOVE_APADD
0000130C  4EB9 00001448            363      JSR PRINTPA
00001312  609E                     364      BRA MOVE_FIN
00001314                           365  MOVE_GETEA  
00001314  7600                     366      MOVE.L  #0,D3
00001316  BE7C 0000                367      CMP #0,D7
0000131A  6700 0012                368      BEQ MOVE_ABSW
0000131E  BE7C 0001                369      CMP #1,D7
00001322  6700 0020                370      BEQ MOVE_ABSL
00001326  BE7C 0004                371      CMP #4,D7
0000132A  6700 002E                372      BEQ MOVE_IMM
0000132E                           373  
0000132E                           374  
0000132E                           375  MOVE_ABSW
0000132E  16FC 0024                376                    MOVE.B  #'$',(A3)+
00001332  4EB9 00001394            377  MOVE_ABSW_LOOP    JSR MOVE_GETBYTE
00001338  5203                     378                    ADDQ.B    #1,D3
0000133A  B63C 0002                379                    CMP.B     #2,D3
0000133E  66F2                     380                    BNE   MOVE_ABSW_LOOP
00001340  6000 FF32                381                    BRA MOVE_AMODE
00001344                           382  MOVE_ABSL
00001344  16FC 0024                383                    MOVE.B  #'$',(A3)+
00001348                           384                 
00001348  4EB9 00001394            385  MOVE_ABSL_LOOP    JSR MOVE_GETBYTE
0000134E  5203                     386                    ADDQ.B    #1,D3
00001350  B63C 0004                387                    CMP.B     #4,D3
00001354  66F2                     388                    BNE   MOVE_ABSL_LOOP
00001356  6000 FF1C                389                    BRA MOVE_AMODE
0000135A                           390  MOVE_IMM
0000135A  16FC 0023                391                    MOVE.B  #'#',(A3)+
0000135E  16FC 0024                392                    MOVE.B  #'$',(A3)+
00001362  343C 3000                393                    MOVE.W    #$3000,D2
00001366  C441                     394                    AND.W     D1,D2
00001368  B47C 2000                395                    CMP.W     #$2000,D2
0000136C  6700 0014                396                    BEQ   MOVE_IMML_LOOP
00001370  4EB9 00001394            397  MOVE_IMMW_LOOP    JSR MOVE_GETBYTE
00001376  5203                     398                    ADDQ.B    #1,D3
00001378  B63C 0002                399                    CMP.B     #2,D3
0000137C  66F2                     400                    BNE   MOVE_IMMW_LOOP
0000137E  6000 FEF4                401                    BRA MOVE_AMODE                  
00001382  4EB9 00001394            402  MOVE_IMML_LOOP    JSR MOVE_GETBYTE
00001388  5203                     403                    ADDQ.B    #1,D3
0000138A  B63C 0004                404                    CMP.B     #4,D3
0000138E  66F2                     405                    BNE   MOVE_IMML_LOOP
00001390  6000 FEE2                406                    BRA MOVE_AMODE
00001394                           407  MOVE_GETBYTE
00001394  1A19                     408      MOVE.B  (A1)+,D5
00001396  1C05                     409      MOVE.B  D5,D6
00001398  CC3C 00F0                410      AND.B   #$F0,D6
0000139C  E80E                     411      LSR.B   #4,D6
0000139E  4EB9 000013B6            412      JSR MOVE_CONVERT
000013A4  16C6                     413      MOVE.B  D6,(A3)+
000013A6  1C05                     414      MOVE.B  D5,D6
000013A8  CC3C 000F                415      AND.B   #$F,D6
000013AC  4EB9 000013B6            416      JSR MOVE_CONVERT
000013B2  16C6                     417      MOVE.B  D6,(A3)+
000013B4  4E75                     418      RTS
000013B6                           419  MOVE_CONVERT
000013B6  BC3C 000A                420      CMP.B   #10,D6
000013BA  6D00 0008                421      BLT MOVE_DIGIT
000013BE  0606 0037                422      ADD.B   #$37,D6
000013C2  4E75                     423      RTS
000013C4                           424  MOVE_DIGIT
000013C4  0606 0030                425      ADD.B #$30,D6
000013C8  4E75                     426      RTS    
000013CA                           427  
000013CA                           428  
000013CA                           429  
000013CA                           430  MOVE_AGETEA 
000013CA  7600                     431      MOVE.L  #0,D3
000013CC  BE7C 0000                432      CMP #0,D7
000013D0  6700 000A                433      BEQ MOVE_ABSWD
000013D4  BE7C 0001                434      CMP #1,D7
000013D8  6700 0016                435      BEQ MOVE_ABSLD   
000013DC                           436  MOVE_ABSWD
000013DC  16FC 0024                437                    MOVE.B  #'$',(A3)+
000013E0  4EB8 1394                438  MOVE_ABSWD_LOOP    JSR MOVE_GETBYTE
000013E4  5203                     439                    ADDQ.B    #1,D3
000013E6  B63C 0002                440                    CMP.B     #2,D3
000013EA  66F4                     441                    BNE   MOVE_ABSWD_LOOP
000013EC  6000 FEC4                442                    BRA MOVE_FIN
000013F0                           443  MOVE_ABSLD
000013F0  16FC 0024                444                    MOVE.B  #'$',(A3)+
000013F4                           445                  
000013F4  4EB8 1394                446  MOVE_ABSLD_LOOP    JSR MOVE_GETBYTE
000013F8  5203                     447                    ADDQ.B    #1,D3
000013FA  B63C 0004                448                    CMP.B     #4,D3
000013FE  66F4                     449                    BNE   MOVE_ABSLD_LOOP
00001400  6000 FEB0                450                    BRA MOVE_FIN    
00001404                           451  PRINTNUM    ;takes value in D7 and prints it to output
00001404  0607 0030                452          ADD.B   #$30,D7
00001408  16C7                     453          MOVE.B  D7,(A3)+
0000140A  4E75                     454          RTS
0000140C                           455  PRINTDN     ;takes value in D7 and prints D#
0000140C  16FC 0044                456          MOVE.B  #'D',(A3)+
00001410  4EB8 1404                457          JSR PRINTNUM
00001414  4E75                     458          RTS
00001416                           459  PRINTAN     ;takes value in D7 and prints A#
00001416  16FC 0041                460          MOVE.B  #'A',(A3)+
0000141A  4EB8 1404                461          JSR PRINTNUM
0000141E  4E75                     462          RTS
00001420                           463  PRINTIAN    ;takes value in D7 and prints (A#)
00001420  16FC 0028                464          MOVE.B  #'(',(A3)+
00001424  16FC 0041                465          MOVE.B  #'A',(A3)+
00001428  4EB8 1404                466          JSR PRINTNUM
0000142C  16FC 0029                467          MOVE.B  #')',(A3)+
00001430  4E75                     468          RTS
00001432                           469  PRINTAP    ;takes value in D7 and prints (A#)+
00001432  16FC 0028                470          MOVE.B  #'(',(A3)+
00001436  16FC 0041                471          MOVE.B  #'A',(A3)+
0000143A  4EB8 1404                472          JSR PRINTNUM
0000143E  16FC 0029                473          MOVE.B  #')',(A3)+
00001442  16FC 002B                474          MOVE.B  #'+',(A3)+
00001446  4E75                     475          RTS
00001448                           476  PRINTPA    ;takes value in D7 and prints -(A#)
00001448  16FC 002D                477          MOVE.B  #'-',(A3)+
0000144C  16FC 0028                478          MOVE.B  #'(',(A3)+
00001450  16FC 0041                479          MOVE.B  #'A',(A3)+
00001454  4EB8 1404                480          JSR PRINTNUM
00001458  16FC 0029                481          MOVE.B  #')',(A3)+
0000145C  4E75                     482          RTS                
0000145E                           483  MOVE_B
0000145E  16FC 002E                484          MOVE.B  #'.',(A3)+
00001462  16FC 0042                485          MOVE.B  #'B',(A3)+
00001466  16FC 0009                486          MOVE.B  #$09,(A3)+
0000146A  6000 FDCA                487          BRA MOVE_XMODE
0000146E                           488  
0000146E                           489  MOVE_W
0000146E  16FC 002E                490          MOVE.B  #'.',(A3)+
00001472  16FC 0057                491          MOVE.B  #'W',(A3)+
00001476  16FC 0009                492          MOVE.B  #$09,(A3)+
0000147A  6000 FDBA                493          BRA MOVE_XMODE
0000147E                           494  MOVE_L
0000147E  16FC 002E                495          MOVE.B  #'.',(A3)+
00001482  16FC 004C                496          MOVE.B  #'L',(A3)+
00001486  16FC 0009                497          MOVE.B  #$09,(A3)+
0000148A  6000 FDAA                498          BRA MOVE_XMODE
0000148E                           499        
0000148E                           500  
0000148E                           501  
0000148E                           502  
0000148E                           503  
0000148E                           504  
0000148E                           505  
0000148E                           506  
0000148E                           507  -------------------- end include --------------------
0000148E                           508  
0000148E                           509  
0000148E                           510  
0000148E                           511  
0000148E                           512  
0000148E                           513  -------------------- end include --------------------
0000148E                           514  
0000148E= 57 65 6C 63 6F 6D ...    515  WELCOME_MSG          dc.b    'Welcome to the Motorola MC68000 Microprocessor Disassembler',CR,LF,0   
000014CC= 50 6C 65 61 73 65 ...    516  START_ADD_MSG        dc.b    'Please enter Start memory address in hexadecimal: ',0
000014FF= 50 6C 65 61 73 65 ...    517  END_ADD_MSG          dc.b    'Please enter End memory address in hexadecimal(must be greater than start address): ',0
00001554= 49 6E 76 61 6C 69 ...    518  INPUT_FAIL_MSG       dc.b    'Invalid address entered. Please try again.',CR,LF,0
00001581= 45 6E 64 20 61 64 ...    519  END_ADD_SMALLER_MSG  dc.b    'End address can not be less than starting address',CR,LF,0
000015B5= 41 64 64 72 65 73 ...    520  ADD_TOO_SMALL        dc.b    'Address below minimum. enter address greater than or equal to $7000',CR,LF,0
000015FB= 41 64 64 72 65 73 ...    521  ADD_TOO_BIG          dc.b    'Address above maximum. enter address less than or equal to $FFFFFFFE',CR,LF,0
00001642                           522  IN_START_A           ds.w    1        ; stores program starting memory address 
00001644                           523  IN_CURR_A            ds.w    1        ; stores current memory address
00001646                           524  IN_END_A             ds.w    1        ; stores program ending memory address 
00001648                           525  OUT_START_A          ds.w    1        ; stores program ending memory address 
0000164A                           526  OUT_CURR_A           ds.w    1        ; stores current memory address
0000164C                           527  IS_VALID             ds.b    1        ; stores whether or not the code is valid
0000164D                           528  
0000164D                           529      INCLUDE 'CONSTANTS.X68'
0000164D                           530  
0000164D= 44 41 54 41 20 24 00     531  BAD_COMMAND_STR DC.B  'DATA $',0
00001654                           532  
00001654= 4E 4F 50 0A 0D 00        533  NOP_STR DC.B  'NOP',$0A,$0D,0
0000165A  =00004E71                534  NOP_S   EQU   $4E71
0000165A  =0000FFFF                535  NOP_P   EQU   $FFFF
0000165A                           536  
0000165A= 4D 4F 56 45 00           537  MOVE_STR    DC.B    'MOVE',0
0000165F  =00000000                538  MOVE_S  EQU $0000
0000165F  =0000C000                539  MOVE_P  EQU $C000
0000165F                           540  
0000165F                           541  
0000165F                           542  
0000165F                           543  -------------------- end include --------------------
0000165F                           544  * BAD_COMMAND_STR DC.B  'DATA $',0
0000165F                           545  
0000165F                           546  * NOP_STR DC.B  'NOP',$0A,$0D,0
0000165F                           547  * NOP_S   EQU   $4E71
0000165F                           548  * NOP_P   EQU   $FFFF
0000165F                           549  
0000165F                           550  
0000165F                           551      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD_TOO_BIG         15FB
ADD_TOO_SMALL       15B5
BAD_COMMAND_STR     164D
BAD_COMMAND_SUB     10FE
BCMD_COPY           112A
BCMD_DONE           1134
CMD_CHECK           10E0
CMD_IDENTIFY        108A
CR                  D
DIGIT_TO_ASCII      118E
END_ADD_MSG         14FF
END_ADD_SMALLER_MSG  1581
END_IDENTIFY        10DA
END_LOOP            1070
INPUT_FAIL_MSG      1554
IN_CURR_A           1644
IN_END_A            1646
IN_START_A          1642
IS_VALID            164C
LF                  A
LOOP                1056
MOVE_AADDP          1304
MOVE_ABSL           1344
MOVE_ABSLD          13F0
MOVE_ABSLD_LOOP     13F4
MOVE_ABSL_LOOP      1348
MOVE_ABSW           132E
MOVE_ABSWD          13DC
MOVE_ABSWD_LOOP     13E0
MOVE_ABSW_LOOP      1332
MOVE_ADATA          12F4
MOVE_ADD            12D4
MOVE_ADDP           12E4
MOVE_AGETEA         13CA
MOVE_AIADD          12FC
MOVE_AMODE          1274
MOVE_APADD          130C
MOVE_B              145E
MOVE_CONVERT        13B6
MOVE_COPY           120E
MOVE_DATA           12CC
MOVE_DIGIT          13C4
MOVE_DONE           1218
MOVE_FIN            12B2
MOVE_GETBYTE        1394
MOVE_GETEA          1314
MOVE_IADD           12DC
MOVE_IMM            135A
MOVE_IMML_LOOP      1382
MOVE_IMMW_LOOP      1370
MOVE_L              147E
MOVE_P              C000
MOVE_PADD           12EC
MOVE_S              0
MOVE_STR            165A
MOVE_SUB            11EA
MOVE_W              146E
MOVE_XMODE          1236
NAN                 11A4
NEGATIVE            10F8
NOP_COPY            11CE
NOP_DONE            11D8
NOP_P               FFFF
NOP_S               4E71
NOP_STR             1654
NOP_SUB             11AA
OUT_CURR_A          164A
OUT_START_A         1648
PRINTAN             1416
PRINTAP             1432
PRINTDN             140C
PRINTIAN            1420
PRINTNUM            1404
PRINTPA             1448
START               1000
START_ADD_MSG       14CC
WELCOME_MSG         148E
