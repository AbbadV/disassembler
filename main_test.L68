00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 4/22/2017 7:10:58 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : main.X68
00000000                             3  * Written by : bisrat belayneh
00000000                             4  * Date       : 4/21/2017
00000000                             5  * Description: Displays welcome, Gets start and end address of memo to be decoded ,Define Out-start-addres,
00000000                             6  *               defines valid-flag (1 for code valid 0 for code invalid),defines constants for start and end 
00000000                             7  *               address of the program ,Sets out current add to out -start- add, Starts id running instruction
00000000                             8  *-----------------------------------------------------------
00000000  =0000000D                  9  CR              EQU     $0D                 ASCII code for carriage return
00000000  =0000000A                 10  LF              EQU     $0A                 ASCII code  for line feed  
00000000                            11  
00001000                            12      ORG    $1000
00001000                            13  START:                  ; first instruction of program
00001000                            14  
00001000                            15  * Put program code here
00001000                            16  *----------------------code for output------------------------
00001000  43F9 000010DC             17                  LEA             welcome_msg,A1   ; load welcome msg to A1
00001006  303C 000E                 18                  Move.W          #14,D0           ; move 14 to D0   
0000100A  4E4F                      19                  Trap            #15              ; display the string at A1   
0000100C                            20  
0000100C                            21     
0000100C                            22  
0000100C                            23  
0000100C  33FC 3000 00001290        24      MOVE.W      #$3000,IN_START_A
00001014  33F9 00001290 00001292    25      MOVE.W      IN_START_A,IN_CURR_A
0000101E  33FC 3006 00001294        26      MOVE.W      #$3006,IN_END_A
00001026                            27  
00001026  31FC 4E70 3000            28      MOVE.W      #$4E70,$3000
0000102C  31FC 3456 3002            29      MOVE.W      #$3456,$3002
00001032  31FC 4E70 3004            30      MOVE.W      #$4E70,$3004
00001038  31FC 4E70 3006            31      MOVE.W      #$4E70,$3006
0000103E                            32  
0000103E                            33  LOOP
0000103E  4EB9 0000105A             34      JSR         CMD_IDENTIFY
00001044  3239 00001292             35      MOVE.W      IN_CURR_A,D1
0000104A  B279 00001294             36      CMP.W       IN_END_A,D1
00001050  6700 0004                 37      BEQ         END_LOOP
00001054  60E8                      38      BRA         LOOP
00001056                            39  
00001056                            40  END_LOOP
00001056                            41  
00001056  FFFF FFFF                 42      SIMHALT             ; halt simulator
0000105A                            43  
0000105A                            44  * Put variables and constants here
0000105A                            45    * INCLUDE     'OPCODE_TEST.X68'
0000105A                            46      INCLUDE     'CmdIdentify.X68'
0000105A                            47  
0000105A                            48  CMD_IDENTIFY
0000105A                            49  
0000105A  48E7 FFFE                 50          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
0000105E                            51    
0000105E  227C 00001292             52          MOVEA.L   #IN_CURR_A,A1 ; A1 is a pointer to the current position
00001064  3451                      53          MOVEA.W   (A1),A2       ; A2 is the opcode at that position
00001066  3212                      54          MOVE.W    (A2),D1       ; D1 is the current opcode
00001068                            55          
00001068                            56          * check NOP
00001068  3401                      57          MOVE.W    D1,D2        ; move the value into D2 for temp storage
0000106A  363C FFFF                 58          MOVE.W    #NOP_P,D3    ; move values into registers for CMD_CHECK
0000106E  383C 4E70                 59          MOVE.W    #NOP_S,D4  
00001072  3A3C 10B0                 60          MOVE.W    #NOP_SUB,D5
00001076  4EB9 0000108A             61          JSR       CMD_CHECK
0000107C                            62  
0000107C  BC3C 0001                 63          CMP.B     #1,D6         ; check the answer CMD_CHECK gave us
00001080  6700 0002                 64          BEQ       END_IDENTIFY  ; skip to the end if it's equal
00001084                            65  
00001084                            66  END_IDENTIFY
00001084                            67  
00001084  4CDF 7FFF                 68          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
00001088  4E75                      69          RTS       ; return
0000108A                            70  
0000108A                            71  
0000108A                            72  CMD_CHECK
0000108A  48E7 0040                 73          MOVEM.L   A1,-(SP)   ; A1 is the only thing we need to keep from the
0000108E                            74                               ; parent routine
0000108E                            75          
0000108E  1C3C 0000                 76          MOVE.B    #0,D6      ; we're storing the answer in D6
00001092                            77  
00001092  C443                      78          AND.W     D3,D2      ; get rid of all the unimportant parts
00001094  B444                      79          CMP.W     D4,D2      ; compare the result with the signature of the cmd
00001096  6600 0010                 80          BNE       NEGATIVE   ; if they don't match skip everything else
0000109A                            81  
0000109A  227C 000010AE             82          MOVEA.L   #SUB_NUM,A1 ; make A1 place in memory
000010A0  2285                      83          MOVE.L    D5,(A1)
000010A2  4E91                      84          JSR       (A1)        ; jump to the subroutine at D5
000010A4  1C3C 0001                 85          MOVE.B    #1,D6
000010A8                            86   
000010A8                            87  NEGATIVE
000010A8  4CDF 0200                 88          MOVEM.L   (SP)+,A1
000010AC  4E75                      89          RTS
000010AE                            90  
000010AE                            91  
000010AE                            92  SUB_NUM   DS.W  1 ; allocate a bit of memory for the subroutine 
000010B0                            93                    ; JSR can only do (An) and immediate values, so we set A1 to
000010B0                            94                    ; this, put the data here and JSR's happy
000010B0                            95  
000010B0                            96          INCLUDE 'NOP_SUB.X68'
000010B0                            97  NOP_SUB
000010B0  48E7 FFFE                 98          MOVEM.L   D0-D7/A0-A6,-(SP) ; move the old registers onto the stack
000010B4                            99  
000010B4  2279 00001296            100          MOVEA.L   OUT_CURR_A,A1 ; move the current output pointer to A1
000010BA  2479 000010D6            101          MOVEA.L   NOP_STR,A2    ; move the to-be-printed string to A2
000010C0                           102  
000010C0                           103          * we need to append the string at NOP_STR to the output string
000010C0                           104          * we do this char by char (byte by byte) until we see a NULL (0)
000010C0                           105          * in NOP_STR
000010C0                           106  COPY
000010C0  4A12                     107          TST.B     (A2)  ; test the contents of A2
000010C2  6700 0006                108          BEQ       DONE  ; if we hit a 00, we're done copying
000010C6                           109  
000010C6  12DA                     110          MOVE.B    (A2)+,(A1)+   ; copy A2 into A1, then increment both
000010C8  60F6                     111          BRA       COPY          ; do it again
000010CA                           112          
000010CA                           113  DONE
000010CA                           114  
000010CA  23C9 00001296            115          MOVE.L    A1,OUT_CURR_A ; move the current A1 back to the output pointer
000010D0                           116  
000010D0  4CDF 7FFF                117          MOVEM.L   (SP)+,D0-D7/A0-A6 ; move the old registers back to the stack
000010D4  4E75                     118          RTS       ; return
000010D6                           119        
000010D6                           120  
000010D6  =00004E70                121  NOP_S   EQU   $4E70
000010D6  =0000FFFF                122  NOP_P   EQU   $FFFF
000010D6= 4E 4F 50 0A 0D 00        123  NOP_STR DC.B  'NOP',$0A,$0D,0
000010D6= 4E 4F 50 0A 0D 00        124  -------------------- end include --------------------
000010DC                           125  
000010DC                           126  -------------------- end include --------------------
000010DC                           127  
000010DC= 57 65 6C 63 6F 6D ...    128  WELCOME_MSG          dc.b    'Welcome to the Motorola MC68000 Microprocessor Disassembler',CR,LF,0   
0000111A= 50 6C 65 61 73 65 ...    129  START_ADD_MSG        dc.b    'Please enter Start memory address in hexadecimal: ',0
0000114D= 50 6C 65 61 73 65 ...    130  END_ADD_MSG          dc.b    'Please enter End memory address in hexadecimal(must be greater than start address): ',0
000011A2= 49 6E 76 61 6C 69 ...    131  INPUT_FAIL_MSG       dc.b    'Invalid address entered. Please try again.',CR,LF,0
000011CF= 45 6E 64 20 61 64 ...    132  END_ADD_SMALLER_MSG  dc.b    'End address can not be less than starting address',CR,LF,0
00001203= 41 64 64 72 65 73 ...    133  ADD_TOO_SMALL        dc.b    'Address below minimum. enter address greater than or equal to $7000',CR,LF,0
00001249= 41 64 64 72 65 73 ...    134  ADD_TOO_BIG          dc.b    'Address above maximum. enter address less than or equal to $FFFFFFFE',CR,LF,0
00001290                           135  IN_START_A           ds.w    1        ; stores program starting memory address 
00001292                           136  IN_CURR_A            ds.w    1         ; stores current memory address
00001294                           137  IN_END_A             ds.w    1         ; stores program ending memory address 
00001296                           138  OUT_CURR_A           ds.w    1         ; stores current memory address
00001298                           139  OUT_END_A            ds.w    1         ; stores program ending memory address 
0000129A                           140  
0000129A                           141      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD_TOO_BIG         1249
ADD_TOO_SMALL       1203
CMD_CHECK           108A
CMD_IDENTIFY        105A
COPY                10C0
CR                  D
DONE                10CA
END_ADD_MSG         114D
END_ADD_SMALLER_MSG  11CF
END_IDENTIFY        1084
END_LOOP            1056
INPUT_FAIL_MSG      11A2
IN_CURR_A           1292
IN_END_A            1294
IN_START_A          1290
LF                  A
LOOP                103E
NEGATIVE            10A8
NOP_P               FFFF
NOP_S               4E70
NOP_STR             10D6
NOP_SUB             10B0
OUT_CURR_A          1296
OUT_END_A           1298
START               1000
START_ADD_MSG       111A
SUB_NUM             10AE
WELCOME_MSG         10DC
